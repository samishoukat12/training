
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  email: string
  password: string
  cnic: string
  address: string
  phone: string
  role: Role
  permission: Permission
  emailApproval: boolean
  successStoriesId: string | null
  token: string | null
  createdAt: Date
  updateAt: Date
}

/**
 * Model MyCourse
 * 
 */
export type MyCourse = {
  id: string
  coursesId: string
  studentId: string
  createdAt: Date
  updateAt: Date
  courseApproval: boolean
  whyReject: string
  feeStatus: FeeStatus
  courseBatchesId: string
}

/**
 * Model MyCart
 * 
 */
export type MyCart = {
  id: string
  createdAt: Date
  updateAt: Date
  coursesId: string
  userId: string | null
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: string
  categoryName: string
  imageUrl: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model Courses
 * 
 */
export type Courses = {
  id: string
  courseName: string
  courseDesc: string
  courseIntro: string
  instructorId: string
  courseCategoryId: string
  createdAt: Date
  updateAt: Date
  courseStatus: Status
  whatYouLearn: Prisma.JsonValue[]
  coursePrice: string
}

/**
 * Model Lectures
 * 
 */
export type Lectures = {
  id: string
  lectureTitle: string
  lectureVideo: string
  coursesId: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model CourseBatches
 * 
 */
export type CourseBatches = {
  id: string
  name: string
  coursesId: string
  courseName: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model CourseAssignment
 * 
 */
export type CourseAssignment = {
  id: string
  name: string
  courseBatchesId: string
  coursesId: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model CourseQuiz
 * 
 */
export type CourseQuiz = {
  id: string
  courseBatchesId: string
  coursesId: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model Speaker
 * 
 */
export type Speaker = {
  id: string
  speakerName: string
  spkearDesc: string
  spekaerImage: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model Events
 * 
 */
export type Events = {
  id: string
  eventName: string
  eventDesc: string
  eventImage: string | null
  eventDate: Date
  speakerId: string
}

/**
 * Model Faq
 * 
 */
export type Faq = {
  id: string
  faqQuestion: string
  faqAnswer: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model SuccessStories
 * 
 */
export type SuccessStories = {
  id: string
  freelancingProfileUrl: string
  paymentProof: string
  description: string
  status: Status
  totalEarnedAmount: string
  city: string
  whyReject: string
}

/**
 * Model blogs
 * 
 */
export type blogs = {
  id: string
  blogTitle: string
  blogDescription: string
  createdAt: Date
  updateAt: Date
  featuredImage: string
  commentType: boolean
}

/**
 * Model Comments
 * 
 */
export type Comments = {
  id: string
  blogsId: string
  createdAt: Date
  comment: string
  userId: string | null
}

/**
 * Model ContactUs
 * 
 */
export type ContactUs = {
  id: string
  name: string
  subject: string
  message: string
  status: ContactUsStatus
  reply: string
}

/**
 * Model Attendence
 * 
 */
export type Attendence = {
  id: string
  attendence: boolean
  date: Date
  userId: string
}

/**
 * Model Fees
 * 
 */
export type Fees = {
  id: string
  amountPaid: string
  remainingAmount: string
  studentId: string
  studentName: string
  createdAt: Date
  updateAt: Date
}

/**
 * Model EnrollmentApproval
 * 
 */
export type EnrollmentApproval = {
  id: string
  studentName: string
  email: string
  course: string
  paymentMethod: string
  amount: string
  transactionId: string
  status: EnrollStatus
}

/**
 * Model Students
 * 
 */
export type Students = {
  id: string
  name: string
  email: string
  status: StudentStatus
}

/**
 * Model Staff
 * 
 */
export type Staff = {
  id: string
  name: string
  email: string
  role: StaffRole
  phone: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  STUDENT: 'STUDENT',
  TEACHER: 'TEACHER',
  ADMIN: 'ADMIN',
  SUPERADMIN: 'SUPERADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Permission: {
  FULL: 'FULL',
  FEESECTION: 'FEESECTION',
  BLOK: 'BLOK',
  UNBLOK: 'UNBLOK'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const FeeStatus: {
  PAID: 'PAID',
  HALFPAID: 'HALFPAID',
  PENDING: 'PENDING'
};

export type FeeStatus = (typeof FeeStatus)[keyof typeof FeeStatus]


export const Status: {
  PUBLISH: 'PUBLISH',
  UNPUBLISH: 'UNPUBLISH'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ContactUsStatus: {
  UNSEEN: 'UNSEEN',
  CONTACTED: 'CONTACTED',
  DECLINE: 'DECLINE',
  USEFUL: 'USEFUL'
};

export type ContactUsStatus = (typeof ContactUsStatus)[keyof typeof ContactUsStatus]


export const EnrollStatus: {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECT: 'REJECT'
};

export type EnrollStatus = (typeof EnrollStatus)[keyof typeof EnrollStatus]


export const StudentStatus: {
  ACTIVE: 'ACTIVE',
  OFFLINE: 'OFFLINE'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const StaffRole: {
  TEACHER: 'TEACHER',
  ADMIN: 'ADMIN'
};

export type StaffRole = (typeof StaffRole)[keyof typeof StaffRole]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): PrismaPromise<Prisma.JsonObject>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.myCourse`: Exposes CRUD operations for the **MyCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MyCourses
    * const myCourses = await prisma.myCourse.findMany()
    * ```
    */
  get myCourse(): Prisma.MyCourseDelegate<GlobalReject>;

  /**
   * `prisma.myCart`: Exposes CRUD operations for the **MyCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MyCarts
    * const myCarts = await prisma.myCart.findMany()
    * ```
    */
  get myCart(): Prisma.MyCartDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **Courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.CoursesDelegate<GlobalReject>;

  /**
   * `prisma.lectures`: Exposes CRUD operations for the **Lectures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lectures
    * const lectures = await prisma.lectures.findMany()
    * ```
    */
  get lectures(): Prisma.LecturesDelegate<GlobalReject>;

  /**
   * `prisma.courseBatches`: Exposes CRUD operations for the **CourseBatches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseBatches
    * const courseBatches = await prisma.courseBatches.findMany()
    * ```
    */
  get courseBatches(): Prisma.CourseBatchesDelegate<GlobalReject>;

  /**
   * `prisma.courseAssignment`: Exposes CRUD operations for the **CourseAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseAssignments
    * const courseAssignments = await prisma.courseAssignment.findMany()
    * ```
    */
  get courseAssignment(): Prisma.CourseAssignmentDelegate<GlobalReject>;

  /**
   * `prisma.courseQuiz`: Exposes CRUD operations for the **CourseQuiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseQuizs
    * const courseQuizs = await prisma.courseQuiz.findMany()
    * ```
    */
  get courseQuiz(): Prisma.CourseQuizDelegate<GlobalReject>;

  /**
   * `prisma.speaker`: Exposes CRUD operations for the **Speaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speaker.findMany()
    * ```
    */
  get speaker(): Prisma.SpeakerDelegate<GlobalReject>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **Events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.EventsDelegate<GlobalReject>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **Faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.FaqDelegate<GlobalReject>;

  /**
   * `prisma.successStories`: Exposes CRUD operations for the **SuccessStories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuccessStories
    * const successStories = await prisma.successStories.findMany()
    * ```
    */
  get successStories(): Prisma.SuccessStoriesDelegate<GlobalReject>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.blogsDelegate<GlobalReject>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<GlobalReject>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<GlobalReject>;

  /**
   * `prisma.attendence`: Exposes CRUD operations for the **Attendence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendences
    * const attendences = await prisma.attendence.findMany()
    * ```
    */
  get attendence(): Prisma.AttendenceDelegate<GlobalReject>;

  /**
   * `prisma.fees`: Exposes CRUD operations for the **Fees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fees.findMany()
    * ```
    */
  get fees(): Prisma.FeesDelegate<GlobalReject>;

  /**
   * `prisma.enrollmentApproval`: Exposes CRUD operations for the **EnrollmentApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnrollmentApprovals
    * const enrollmentApprovals = await prisma.enrollmentApproval.findMany()
    * ```
    */
  get enrollmentApproval(): Prisma.EnrollmentApprovalDelegate<GlobalReject>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **Students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.StudentsDelegate<GlobalReject>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.10.0
   * Query Engine version: 73e60b76d394f8d37d8ebd1f8918c79029f0db86
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    MyCourse: 'MyCourse',
    MyCart: 'MyCart',
    Category: 'Category',
    Courses: 'Courses',
    Lectures: 'Lectures',
    CourseBatches: 'CourseBatches',
    CourseAssignment: 'CourseAssignment',
    CourseQuiz: 'CourseQuiz',
    Speaker: 'Speaker',
    Events: 'Events',
    Faq: 'Faq',
    SuccessStories: 'SuccessStories',
    blogs: 'blogs',
    Comments: 'Comments',
    ContactUs: 'ContactUs',
    Attendence: 'Attendence',
    Fees: 'Fees',
    EnrollmentApproval: 'EnrollmentApproval',
    Students: 'Students',
    Staff: 'Staff'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    courses: number
    myCart: number
    myComments: number
    attendence: number
    fees: number
    myCourse: number
  }

  export type UserCountOutputTypeSelect = {
    courses?: boolean
    myCart?: boolean
    myComments?: boolean
    attendence?: boolean
    fees?: boolean
    myCourse?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    allCourses: number
  }

  export type CategoryCountOutputTypeSelect = {
    allCourses?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoryCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoryCountOutputType
    : S extends undefined
    ? never
    : S extends CategoryCountOutputTypeArgs
    ?'include' extends U
    ? CategoryCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
    : CategoryCountOutputType
  : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     * 
    **/
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type CoursesCountOutputType
   */


  export type CoursesCountOutputType = {
    lectures: number
    totalBatches: number
    assignment: number
    courseQuiz: number
    enrollList: number
    cartList: number
  }

  export type CoursesCountOutputTypeSelect = {
    lectures?: boolean
    totalBatches?: boolean
    assignment?: boolean
    courseQuiz?: boolean
    enrollList?: boolean
    cartList?: boolean
  }

  export type CoursesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CoursesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CoursesCountOutputType
    : S extends undefined
    ? never
    : S extends CoursesCountOutputTypeArgs
    ?'include' extends U
    ? CoursesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CoursesCountOutputType ? CoursesCountOutputType[P] : never
  } 
    : CoursesCountOutputType
  : CoursesCountOutputType




  // Custom InputTypes

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     * 
    **/
    select?: CoursesCountOutputTypeSelect | null
  }



  /**
   * Count Type CourseBatchesCountOutputType
   */


  export type CourseBatchesCountOutputType = {
    assignment: number
    quiz: number
    enrolledStudent: number
  }

  export type CourseBatchesCountOutputTypeSelect = {
    assignment?: boolean
    quiz?: boolean
    enrolledStudent?: boolean
  }

  export type CourseBatchesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CourseBatchesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CourseBatchesCountOutputType
    : S extends undefined
    ? never
    : S extends CourseBatchesCountOutputTypeArgs
    ?'include' extends U
    ? CourseBatchesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CourseBatchesCountOutputType ? CourseBatchesCountOutputType[P] : never
  } 
    : CourseBatchesCountOutputType
  : CourseBatchesCountOutputType




  // Custom InputTypes

  /**
   * CourseBatchesCountOutputType without action
   */
  export type CourseBatchesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CourseBatchesCountOutputType
     * 
    **/
    select?: CourseBatchesCountOutputTypeSelect | null
  }



  /**
   * Count Type SpeakerCountOutputType
   */


  export type SpeakerCountOutputType = {
    events: number
  }

  export type SpeakerCountOutputTypeSelect = {
    events?: boolean
  }

  export type SpeakerCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SpeakerCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SpeakerCountOutputType
    : S extends undefined
    ? never
    : S extends SpeakerCountOutputTypeArgs
    ?'include' extends U
    ? SpeakerCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SpeakerCountOutputType ? SpeakerCountOutputType[P] : never
  } 
    : SpeakerCountOutputType
  : SpeakerCountOutputType




  // Custom InputTypes

  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SpeakerCountOutputType
     * 
    **/
    select?: SpeakerCountOutputTypeSelect | null
  }



  /**
   * Count Type SuccessStoriesCountOutputType
   */


  export type SuccessStoriesCountOutputType = {
    user: number
  }

  export type SuccessStoriesCountOutputTypeSelect = {
    user?: boolean
  }

  export type SuccessStoriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SuccessStoriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SuccessStoriesCountOutputType
    : S extends undefined
    ? never
    : S extends SuccessStoriesCountOutputTypeArgs
    ?'include' extends U
    ? SuccessStoriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SuccessStoriesCountOutputType ? SuccessStoriesCountOutputType[P] : never
  } 
    : SuccessStoriesCountOutputType
  : SuccessStoriesCountOutputType




  // Custom InputTypes

  /**
   * SuccessStoriesCountOutputType without action
   */
  export type SuccessStoriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SuccessStoriesCountOutputType
     * 
    **/
    select?: SuccessStoriesCountOutputTypeSelect | null
  }



  /**
   * Count Type BlogsCountOutputType
   */


  export type BlogsCountOutputType = {
    comments: number
  }

  export type BlogsCountOutputTypeSelect = {
    comments?: boolean
  }

  export type BlogsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BlogsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BlogsCountOutputType
    : S extends undefined
    ? never
    : S extends BlogsCountOutputTypeArgs
    ?'include' extends U
    ? BlogsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BlogsCountOutputType ? BlogsCountOutputType[P] : never
  } 
    : BlogsCountOutputType
  : BlogsCountOutputType




  // Custom InputTypes

  /**
   * BlogsCountOutputType without action
   */
  export type BlogsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BlogsCountOutputType
     * 
    **/
    select?: BlogsCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    cnic: string | null
    address: string | null
    phone: string | null
    role: Role | null
    permission: Permission | null
    emailApproval: boolean | null
    successStoriesId: string | null
    token: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    cnic: string | null
    address: string | null
    phone: string | null
    role: Role | null
    permission: Permission | null
    emailApproval: boolean | null
    successStoriesId: string | null
    token: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    cnic: number
    address: number
    phone: number
    role: number
    permission: number
    emailApproval: number
    successStoriesId: number
    token: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cnic?: true
    address?: true
    phone?: true
    role?: true
    permission?: true
    emailApproval?: true
    successStoriesId?: true
    token?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cnic?: true
    address?: true
    phone?: true
    role?: true
    permission?: true
    emailApproval?: true
    successStoriesId?: true
    token?: true
    createdAt?: true
    updateAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cnic?: true
    address?: true
    phone?: true
    role?: true
    permission?: true
    emailApproval?: true
    successStoriesId?: true
    token?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    cnic: string
    address: string
    phone: string
    role: Role
    permission: Permission
    emailApproval: boolean
    successStoriesId: string | null
    token: string | null
    createdAt: Date
    updateAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cnic?: boolean
    address?: boolean
    phone?: boolean
    role?: boolean
    permission?: boolean
    courses?: boolean | CoursesFindManyArgs
    myCart?: boolean | MyCartFindManyArgs
    successStory?: boolean | SuccessStoriesArgs
    emailApproval?: boolean
    myComments?: boolean | CommentsFindManyArgs
    attendence?: boolean | AttendenceFindManyArgs
    fees?: boolean | FeesFindManyArgs
    successStoriesId?: boolean
    myCourse?: boolean | MyCourseFindManyArgs
    token?: boolean
    createdAt?: boolean
    updateAt?: boolean
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    courses?: boolean | CoursesFindManyArgs
    myCart?: boolean | MyCartFindManyArgs
    successStory?: boolean | SuccessStoriesArgs
    myComments?: boolean | CommentsFindManyArgs
    attendence?: boolean | AttendenceFindManyArgs
    fees?: boolean | FeesFindManyArgs
    myCourse?: boolean | MyCourseFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'courses' ? Array < CoursesGetPayload<S['include'][P]>>  :
        P extends 'myCart' ? Array < MyCartGetPayload<S['include'][P]>>  :
        P extends 'successStory' ? SuccessStoriesGetPayload<S['include'][P]> | null :
        P extends 'myComments' ? Array < CommentsGetPayload<S['include'][P]>>  :
        P extends 'attendence' ? Array < AttendenceGetPayload<S['include'][P]>>  :
        P extends 'fees' ? Array < FeesGetPayload<S['include'][P]>>  :
        P extends 'myCourse' ? Array < MyCourseGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'courses' ? Array < CoursesGetPayload<S['select'][P]>>  :
        P extends 'myCart' ? Array < MyCartGetPayload<S['select'][P]>>  :
        P extends 'successStory' ? SuccessStoriesGetPayload<S['select'][P]> | null :
        P extends 'myComments' ? Array < CommentsGetPayload<S['select'][P]>>  :
        P extends 'attendence' ? Array < AttendenceGetPayload<S['select'][P]>>  :
        P extends 'fees' ? Array < FeesGetPayload<S['select'][P]>>  :
        P extends 'myCourse' ? Array < MyCourseGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    courses<T extends CoursesFindManyArgs = {}>(args?: Subset<T, CoursesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Courses>>, PrismaPromise<Array<CoursesGetPayload<T>>>>;

    myCart<T extends MyCartFindManyArgs = {}>(args?: Subset<T, MyCartFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MyCart>>, PrismaPromise<Array<MyCartGetPayload<T>>>>;

    successStory<T extends SuccessStoriesArgs = {}>(args?: Subset<T, SuccessStoriesArgs>): CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories | null >, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T> | null >>;

    myComments<T extends CommentsFindManyArgs = {}>(args?: Subset<T, CommentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>;

    attendence<T extends AttendenceFindManyArgs = {}>(args?: Subset<T, AttendenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Attendence>>, PrismaPromise<Array<AttendenceGetPayload<T>>>>;

    fees<T extends FeesFindManyArgs = {}>(args?: Subset<T, FeesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Fees>>, PrismaPromise<Array<FeesGetPayload<T>>>>;

    myCourse<T extends MyCourseFindManyArgs = {}>(args?: Subset<T, MyCourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MyCourse>>, PrismaPromise<Array<MyCourseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model MyCourse
   */


  export type AggregateMyCourse = {
    _count: MyCourseCountAggregateOutputType | null
    _min: MyCourseMinAggregateOutputType | null
    _max: MyCourseMaxAggregateOutputType | null
  }

  export type MyCourseMinAggregateOutputType = {
    id: string | null
    coursesId: string | null
    studentId: string | null
    createdAt: Date | null
    updateAt: Date | null
    courseApproval: boolean | null
    whyReject: string | null
    feeStatus: FeeStatus | null
    courseBatchesId: string | null
  }

  export type MyCourseMaxAggregateOutputType = {
    id: string | null
    coursesId: string | null
    studentId: string | null
    createdAt: Date | null
    updateAt: Date | null
    courseApproval: boolean | null
    whyReject: string | null
    feeStatus: FeeStatus | null
    courseBatchesId: string | null
  }

  export type MyCourseCountAggregateOutputType = {
    id: number
    coursesId: number
    studentId: number
    createdAt: number
    updateAt: number
    courseApproval: number
    whyReject: number
    feeStatus: number
    courseBatchesId: number
    _all: number
  }


  export type MyCourseMinAggregateInputType = {
    id?: true
    coursesId?: true
    studentId?: true
    createdAt?: true
    updateAt?: true
    courseApproval?: true
    whyReject?: true
    feeStatus?: true
    courseBatchesId?: true
  }

  export type MyCourseMaxAggregateInputType = {
    id?: true
    coursesId?: true
    studentId?: true
    createdAt?: true
    updateAt?: true
    courseApproval?: true
    whyReject?: true
    feeStatus?: true
    courseBatchesId?: true
  }

  export type MyCourseCountAggregateInputType = {
    id?: true
    coursesId?: true
    studentId?: true
    createdAt?: true
    updateAt?: true
    courseApproval?: true
    whyReject?: true
    feeStatus?: true
    courseBatchesId?: true
    _all?: true
  }

  export type MyCourseAggregateArgs = {
    /**
     * Filter which MyCourse to aggregate.
     * 
    **/
    where?: MyCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCourses to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MyCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCourses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCourses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MyCourses
    **/
    _count?: true | MyCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MyCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MyCourseMaxAggregateInputType
  }

  export type GetMyCourseAggregateType<T extends MyCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateMyCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMyCourse[P]>
      : GetScalarType<T[P], AggregateMyCourse[P]>
  }




  export type MyCourseGroupByArgs = {
    where?: MyCourseWhereInput
    orderBy?: Enumerable<MyCourseOrderByWithAggregationInput>
    by: Array<MyCourseScalarFieldEnum>
    having?: MyCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MyCourseCountAggregateInputType | true
    _min?: MyCourseMinAggregateInputType
    _max?: MyCourseMaxAggregateInputType
  }


  export type MyCourseGroupByOutputType = {
    id: string
    coursesId: string
    studentId: string
    createdAt: Date
    updateAt: Date
    courseApproval: boolean
    whyReject: string
    feeStatus: FeeStatus
    courseBatchesId: string
    _count: MyCourseCountAggregateOutputType | null
    _min: MyCourseMinAggregateOutputType | null
    _max: MyCourseMaxAggregateOutputType | null
  }

  type GetMyCourseGroupByPayload<T extends MyCourseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MyCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MyCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MyCourseGroupByOutputType[P]>
            : GetScalarType<T[P], MyCourseGroupByOutputType[P]>
        }
      >
    >


  export type MyCourseSelect = {
    id?: boolean
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    student?: boolean | UserArgs
    studentId?: boolean
    createdAt?: boolean
    updateAt?: boolean
    courseApproval?: boolean
    whyReject?: boolean
    feeStatus?: boolean
    courseBatches?: boolean | CourseBatchesArgs
    courseBatchesId?: boolean
  }

  export type MyCourseInclude = {
    courses?: boolean | CoursesArgs
    student?: boolean | UserArgs
    courseBatches?: boolean | CourseBatchesArgs
  }

  export type MyCourseGetPayload<
    S extends boolean | null | undefined | MyCourseArgs,
    U = keyof S
      > = S extends true
        ? MyCourse
    : S extends undefined
    ? never
    : S extends MyCourseArgs | MyCourseFindManyArgs
    ?'include' extends U
    ? MyCourse  & {
    [P in TrueKeys<S['include']>]:
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :
        P extends 'student' ? UserGetPayload<S['include'][P]> :
        P extends 'courseBatches' ? CourseBatchesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :
        P extends 'student' ? UserGetPayload<S['select'][P]> :
        P extends 'courseBatches' ? CourseBatchesGetPayload<S['select'][P]> :  P extends keyof MyCourse ? MyCourse[P] : never
  } 
    : MyCourse
  : MyCourse


  type MyCourseCountArgs = Merge<
    Omit<MyCourseFindManyArgs, 'select' | 'include'> & {
      select?: MyCourseCountAggregateInputType | true
    }
  >

  export interface MyCourseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MyCourse that matches the filter.
     * @param {MyCourseFindUniqueArgs} args - Arguments to find a MyCourse
     * @example
     * // Get one MyCourse
     * const myCourse = await prisma.myCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MyCourseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MyCourseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MyCourse'> extends True ? CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>> : CheckSelect<T, Prisma__MyCourseClient<MyCourse | null >, Prisma__MyCourseClient<MyCourseGetPayload<T> | null >>

    /**
     * Find the first MyCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseFindFirstArgs} args - Arguments to find a MyCourse
     * @example
     * // Get one MyCourse
     * const myCourse = await prisma.myCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MyCourseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MyCourseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MyCourse'> extends True ? CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>> : CheckSelect<T, Prisma__MyCourseClient<MyCourse | null >, Prisma__MyCourseClient<MyCourseGetPayload<T> | null >>

    /**
     * Find zero or more MyCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MyCourses
     * const myCourses = await prisma.myCourse.findMany()
     * 
     * // Get first 10 MyCourses
     * const myCourses = await prisma.myCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const myCourseWithIdOnly = await prisma.myCourse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MyCourseFindManyArgs>(
      args?: SelectSubset<T, MyCourseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MyCourse>>, PrismaPromise<Array<MyCourseGetPayload<T>>>>

    /**
     * Create a MyCourse.
     * @param {MyCourseCreateArgs} args - Arguments to create a MyCourse.
     * @example
     * // Create one MyCourse
     * const MyCourse = await prisma.myCourse.create({
     *   data: {
     *     // ... data to create a MyCourse
     *   }
     * })
     * 
    **/
    create<T extends MyCourseCreateArgs>(
      args: SelectSubset<T, MyCourseCreateArgs>
    ): CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>>

    /**
     * Create many MyCourses.
     *     @param {MyCourseCreateManyArgs} args - Arguments to create many MyCourses.
     *     @example
     *     // Create many MyCourses
     *     const myCourse = await prisma.myCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MyCourseCreateManyArgs>(
      args?: SelectSubset<T, MyCourseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MyCourse.
     * @param {MyCourseDeleteArgs} args - Arguments to delete one MyCourse.
     * @example
     * // Delete one MyCourse
     * const MyCourse = await prisma.myCourse.delete({
     *   where: {
     *     // ... filter to delete one MyCourse
     *   }
     * })
     * 
    **/
    delete<T extends MyCourseDeleteArgs>(
      args: SelectSubset<T, MyCourseDeleteArgs>
    ): CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>>

    /**
     * Update one MyCourse.
     * @param {MyCourseUpdateArgs} args - Arguments to update one MyCourse.
     * @example
     * // Update one MyCourse
     * const myCourse = await prisma.myCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MyCourseUpdateArgs>(
      args: SelectSubset<T, MyCourseUpdateArgs>
    ): CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>>

    /**
     * Delete zero or more MyCourses.
     * @param {MyCourseDeleteManyArgs} args - Arguments to filter MyCourses to delete.
     * @example
     * // Delete a few MyCourses
     * const { count } = await prisma.myCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MyCourseDeleteManyArgs>(
      args?: SelectSubset<T, MyCourseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MyCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MyCourses
     * const myCourse = await prisma.myCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MyCourseUpdateManyArgs>(
      args: SelectSubset<T, MyCourseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MyCourse.
     * @param {MyCourseUpsertArgs} args - Arguments to update or create a MyCourse.
     * @example
     * // Update or create a MyCourse
     * const myCourse = await prisma.myCourse.upsert({
     *   create: {
     *     // ... data to create a MyCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MyCourse we want to update
     *   }
     * })
    **/
    upsert<T extends MyCourseUpsertArgs>(
      args: SelectSubset<T, MyCourseUpsertArgs>
    ): CheckSelect<T, Prisma__MyCourseClient<MyCourse>, Prisma__MyCourseClient<MyCourseGetPayload<T>>>

    /**
     * Find zero or more MyCourses that matches the filter.
     * @param {MyCourseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const myCourse = await prisma.myCourse.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MyCourseFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MyCourse.
     * @param {MyCourseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const myCourse = await prisma.myCourse.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MyCourseAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of MyCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseCountArgs} args - Arguments to filter MyCourses to count.
     * @example
     * // Count the number of MyCourses
     * const count = await prisma.myCourse.count({
     *   where: {
     *     // ... the filter for the MyCourses we want to count
     *   }
     * })
    **/
    count<T extends MyCourseCountArgs>(
      args?: Subset<T, MyCourseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MyCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MyCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MyCourseAggregateArgs>(args: Subset<T, MyCourseAggregateArgs>): PrismaPromise<GetMyCourseAggregateType<T>>

    /**
     * Group by MyCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MyCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MyCourseGroupByArgs['orderBy'] }
        : { orderBy?: MyCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MyCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMyCourseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MyCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MyCourseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    student<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    courseBatches<T extends CourseBatchesArgs = {}>(args?: Subset<T, CourseBatchesArgs>): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches | null >, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MyCourse findUnique
   */
  export type MyCourseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * Throw an Error if a MyCourse can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MyCourse to fetch.
     * 
    **/
    where: MyCourseWhereUniqueInput
  }


  /**
   * MyCourse findFirst
   */
  export type MyCourseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * Throw an Error if a MyCourse can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MyCourse to fetch.
     * 
    **/
    where?: MyCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCourses to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MyCourses.
     * 
    **/
    cursor?: MyCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCourses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCourses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MyCourses.
     * 
    **/
    distinct?: Enumerable<MyCourseScalarFieldEnum>
  }


  /**
   * MyCourse findMany
   */
  export type MyCourseFindManyArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * Filter, which MyCourses to fetch.
     * 
    **/
    where?: MyCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCourses to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MyCourses.
     * 
    **/
    cursor?: MyCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCourses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCourses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MyCourseScalarFieldEnum>
  }


  /**
   * MyCourse create
   */
  export type MyCourseCreateArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * The data needed to create a MyCourse.
     * 
    **/
    data: XOR<MyCourseCreateInput, MyCourseUncheckedCreateInput>
  }


  /**
   * MyCourse createMany
   */
  export type MyCourseCreateManyArgs = {
    /**
     * The data used to create many MyCourses.
     * 
    **/
    data: Enumerable<MyCourseCreateManyInput>
  }


  /**
   * MyCourse update
   */
  export type MyCourseUpdateArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * The data needed to update a MyCourse.
     * 
    **/
    data: XOR<MyCourseUpdateInput, MyCourseUncheckedUpdateInput>
    /**
     * Choose, which MyCourse to update.
     * 
    **/
    where: MyCourseWhereUniqueInput
  }


  /**
   * MyCourse updateMany
   */
  export type MyCourseUpdateManyArgs = {
    /**
     * The data used to update MyCourses.
     * 
    **/
    data: XOR<MyCourseUpdateManyMutationInput, MyCourseUncheckedUpdateManyInput>
    /**
     * Filter which MyCourses to update
     * 
    **/
    where?: MyCourseWhereInput
  }


  /**
   * MyCourse upsert
   */
  export type MyCourseUpsertArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * The filter to search for the MyCourse to update in case it exists.
     * 
    **/
    where: MyCourseWhereUniqueInput
    /**
     * In case the MyCourse found by the `where` argument doesn't exist, create a new MyCourse with this data.
     * 
    **/
    create: XOR<MyCourseCreateInput, MyCourseUncheckedCreateInput>
    /**
     * In case the MyCourse was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MyCourseUpdateInput, MyCourseUncheckedUpdateInput>
  }


  /**
   * MyCourse delete
   */
  export type MyCourseDeleteArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
    /**
     * Filter which MyCourse to delete.
     * 
    **/
    where: MyCourseWhereUniqueInput
  }


  /**
   * MyCourse deleteMany
   */
  export type MyCourseDeleteManyArgs = {
    /**
     * Filter which MyCourses to delete
     * 
    **/
    where?: MyCourseWhereInput
  }


  /**
   * MyCourse findRaw
   */
  export type MyCourseFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MyCourse aggregateRaw
   */
  export type MyCourseAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MyCourse without action
   */
  export type MyCourseArgs = {
    /**
     * Select specific fields to fetch from the MyCourse
     * 
    **/
    select?: MyCourseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCourseInclude | null
  }



  /**
   * Model MyCart
   */


  export type AggregateMyCart = {
    _count: MyCartCountAggregateOutputType | null
    _min: MyCartMinAggregateOutputType | null
    _max: MyCartMaxAggregateOutputType | null
  }

  export type MyCartMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updateAt: Date | null
    coursesId: string | null
    userId: string | null
  }

  export type MyCartMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updateAt: Date | null
    coursesId: string | null
    userId: string | null
  }

  export type MyCartCountAggregateOutputType = {
    id: number
    createdAt: number
    updateAt: number
    coursesId: number
    userId: number
    _all: number
  }


  export type MyCartMinAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    coursesId?: true
    userId?: true
  }

  export type MyCartMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    coursesId?: true
    userId?: true
  }

  export type MyCartCountAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    coursesId?: true
    userId?: true
    _all?: true
  }

  export type MyCartAggregateArgs = {
    /**
     * Filter which MyCart to aggregate.
     * 
    **/
    where?: MyCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MyCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCarts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MyCarts
    **/
    _count?: true | MyCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MyCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MyCartMaxAggregateInputType
  }

  export type GetMyCartAggregateType<T extends MyCartAggregateArgs> = {
        [P in keyof T & keyof AggregateMyCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMyCart[P]>
      : GetScalarType<T[P], AggregateMyCart[P]>
  }




  export type MyCartGroupByArgs = {
    where?: MyCartWhereInput
    orderBy?: Enumerable<MyCartOrderByWithAggregationInput>
    by: Array<MyCartScalarFieldEnum>
    having?: MyCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MyCartCountAggregateInputType | true
    _min?: MyCartMinAggregateInputType
    _max?: MyCartMaxAggregateInputType
  }


  export type MyCartGroupByOutputType = {
    id: string
    createdAt: Date
    updateAt: Date
    coursesId: string
    userId: string | null
    _count: MyCartCountAggregateOutputType | null
    _min: MyCartMinAggregateOutputType | null
    _max: MyCartMaxAggregateOutputType | null
  }

  type GetMyCartGroupByPayload<T extends MyCartGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MyCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MyCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MyCartGroupByOutputType[P]>
            : GetScalarType<T[P], MyCartGroupByOutputType[P]>
        }
      >
    >


  export type MyCartSelect = {
    id?: boolean
    createdAt?: boolean
    updateAt?: boolean
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type MyCartInclude = {
    courses?: boolean | CoursesArgs
    user?: boolean | UserArgs
  }

  export type MyCartGetPayload<
    S extends boolean | null | undefined | MyCartArgs,
    U = keyof S
      > = S extends true
        ? MyCart
    : S extends undefined
    ? never
    : S extends MyCartArgs | MyCartFindManyArgs
    ?'include' extends U
    ? MyCart  & {
    [P in TrueKeys<S['include']>]:
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :  P extends keyof MyCart ? MyCart[P] : never
  } 
    : MyCart
  : MyCart


  type MyCartCountArgs = Merge<
    Omit<MyCartFindManyArgs, 'select' | 'include'> & {
      select?: MyCartCountAggregateInputType | true
    }
  >

  export interface MyCartDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MyCart that matches the filter.
     * @param {MyCartFindUniqueArgs} args - Arguments to find a MyCart
     * @example
     * // Get one MyCart
     * const myCart = await prisma.myCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MyCartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MyCartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MyCart'> extends True ? CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>> : CheckSelect<T, Prisma__MyCartClient<MyCart | null >, Prisma__MyCartClient<MyCartGetPayload<T> | null >>

    /**
     * Find the first MyCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartFindFirstArgs} args - Arguments to find a MyCart
     * @example
     * // Get one MyCart
     * const myCart = await prisma.myCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MyCartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MyCartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MyCart'> extends True ? CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>> : CheckSelect<T, Prisma__MyCartClient<MyCart | null >, Prisma__MyCartClient<MyCartGetPayload<T> | null >>

    /**
     * Find zero or more MyCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MyCarts
     * const myCarts = await prisma.myCart.findMany()
     * 
     * // Get first 10 MyCarts
     * const myCarts = await prisma.myCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const myCartWithIdOnly = await prisma.myCart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MyCartFindManyArgs>(
      args?: SelectSubset<T, MyCartFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MyCart>>, PrismaPromise<Array<MyCartGetPayload<T>>>>

    /**
     * Create a MyCart.
     * @param {MyCartCreateArgs} args - Arguments to create a MyCart.
     * @example
     * // Create one MyCart
     * const MyCart = await prisma.myCart.create({
     *   data: {
     *     // ... data to create a MyCart
     *   }
     * })
     * 
    **/
    create<T extends MyCartCreateArgs>(
      args: SelectSubset<T, MyCartCreateArgs>
    ): CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>>

    /**
     * Create many MyCarts.
     *     @param {MyCartCreateManyArgs} args - Arguments to create many MyCarts.
     *     @example
     *     // Create many MyCarts
     *     const myCart = await prisma.myCart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MyCartCreateManyArgs>(
      args?: SelectSubset<T, MyCartCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MyCart.
     * @param {MyCartDeleteArgs} args - Arguments to delete one MyCart.
     * @example
     * // Delete one MyCart
     * const MyCart = await prisma.myCart.delete({
     *   where: {
     *     // ... filter to delete one MyCart
     *   }
     * })
     * 
    **/
    delete<T extends MyCartDeleteArgs>(
      args: SelectSubset<T, MyCartDeleteArgs>
    ): CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>>

    /**
     * Update one MyCart.
     * @param {MyCartUpdateArgs} args - Arguments to update one MyCart.
     * @example
     * // Update one MyCart
     * const myCart = await prisma.myCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MyCartUpdateArgs>(
      args: SelectSubset<T, MyCartUpdateArgs>
    ): CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>>

    /**
     * Delete zero or more MyCarts.
     * @param {MyCartDeleteManyArgs} args - Arguments to filter MyCarts to delete.
     * @example
     * // Delete a few MyCarts
     * const { count } = await prisma.myCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MyCartDeleteManyArgs>(
      args?: SelectSubset<T, MyCartDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MyCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MyCarts
     * const myCart = await prisma.myCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MyCartUpdateManyArgs>(
      args: SelectSubset<T, MyCartUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MyCart.
     * @param {MyCartUpsertArgs} args - Arguments to update or create a MyCart.
     * @example
     * // Update or create a MyCart
     * const myCart = await prisma.myCart.upsert({
     *   create: {
     *     // ... data to create a MyCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MyCart we want to update
     *   }
     * })
    **/
    upsert<T extends MyCartUpsertArgs>(
      args: SelectSubset<T, MyCartUpsertArgs>
    ): CheckSelect<T, Prisma__MyCartClient<MyCart>, Prisma__MyCartClient<MyCartGetPayload<T>>>

    /**
     * Find zero or more MyCarts that matches the filter.
     * @param {MyCartFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const myCart = await prisma.myCart.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MyCartFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MyCart.
     * @param {MyCartAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const myCart = await prisma.myCart.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MyCartAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of MyCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartCountArgs} args - Arguments to filter MyCarts to count.
     * @example
     * // Count the number of MyCarts
     * const count = await prisma.myCart.count({
     *   where: {
     *     // ... the filter for the MyCarts we want to count
     *   }
     * })
    **/
    count<T extends MyCartCountArgs>(
      args?: Subset<T, MyCartCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MyCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MyCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MyCartAggregateArgs>(args: Subset<T, MyCartAggregateArgs>): PrismaPromise<GetMyCartAggregateType<T>>

    /**
     * Group by MyCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MyCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MyCartGroupByArgs['orderBy'] }
        : { orderBy?: MyCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MyCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMyCartGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MyCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MyCartClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MyCart findUnique
   */
  export type MyCartFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * Throw an Error if a MyCart can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MyCart to fetch.
     * 
    **/
    where: MyCartWhereUniqueInput
  }


  /**
   * MyCart findFirst
   */
  export type MyCartFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * Throw an Error if a MyCart can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MyCart to fetch.
     * 
    **/
    where?: MyCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MyCarts.
     * 
    **/
    cursor?: MyCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCarts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MyCarts.
     * 
    **/
    distinct?: Enumerable<MyCartScalarFieldEnum>
  }


  /**
   * MyCart findMany
   */
  export type MyCartFindManyArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * Filter, which MyCarts to fetch.
     * 
    **/
    where?: MyCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyCarts to fetch.
     * 
    **/
    orderBy?: Enumerable<MyCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MyCarts.
     * 
    **/
    cursor?: MyCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyCarts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyCarts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MyCartScalarFieldEnum>
  }


  /**
   * MyCart create
   */
  export type MyCartCreateArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * The data needed to create a MyCart.
     * 
    **/
    data: XOR<MyCartCreateInput, MyCartUncheckedCreateInput>
  }


  /**
   * MyCart createMany
   */
  export type MyCartCreateManyArgs = {
    /**
     * The data used to create many MyCarts.
     * 
    **/
    data: Enumerable<MyCartCreateManyInput>
  }


  /**
   * MyCart update
   */
  export type MyCartUpdateArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * The data needed to update a MyCart.
     * 
    **/
    data: XOR<MyCartUpdateInput, MyCartUncheckedUpdateInput>
    /**
     * Choose, which MyCart to update.
     * 
    **/
    where: MyCartWhereUniqueInput
  }


  /**
   * MyCart updateMany
   */
  export type MyCartUpdateManyArgs = {
    /**
     * The data used to update MyCarts.
     * 
    **/
    data: XOR<MyCartUpdateManyMutationInput, MyCartUncheckedUpdateManyInput>
    /**
     * Filter which MyCarts to update
     * 
    **/
    where?: MyCartWhereInput
  }


  /**
   * MyCart upsert
   */
  export type MyCartUpsertArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * The filter to search for the MyCart to update in case it exists.
     * 
    **/
    where: MyCartWhereUniqueInput
    /**
     * In case the MyCart found by the `where` argument doesn't exist, create a new MyCart with this data.
     * 
    **/
    create: XOR<MyCartCreateInput, MyCartUncheckedCreateInput>
    /**
     * In case the MyCart was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MyCartUpdateInput, MyCartUncheckedUpdateInput>
  }


  /**
   * MyCart delete
   */
  export type MyCartDeleteArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
    /**
     * Filter which MyCart to delete.
     * 
    **/
    where: MyCartWhereUniqueInput
  }


  /**
   * MyCart deleteMany
   */
  export type MyCartDeleteManyArgs = {
    /**
     * Filter which MyCarts to delete
     * 
    **/
    where?: MyCartWhereInput
  }


  /**
   * MyCart findRaw
   */
  export type MyCartFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MyCart aggregateRaw
   */
  export type MyCartAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * MyCart without action
   */
  export type MyCartArgs = {
    /**
     * Select specific fields to fetch from the MyCart
     * 
    **/
    select?: MyCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MyCartInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    categoryName: string | null
    imageUrl: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    categoryName: string | null
    imageUrl: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    categoryName: number
    imageUrl: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    categoryName?: true
    imageUrl?: true
    createdAt?: true
    updateAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    categoryName?: true
    imageUrl?: true
    createdAt?: true
    updateAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    categoryName?: true
    imageUrl?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    categoryName: string
    imageUrl: string
    createdAt: Date
    updateAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    categoryName?: boolean
    allCourses?: boolean | CoursesFindManyArgs
    imageUrl?: boolean
    createdAt?: boolean
    updateAt?: boolean
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryInclude = {
    allCourses?: boolean | CoursesFindManyArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]:
        P extends 'allCourses' ? Array < CoursesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'allCourses' ? Array < CoursesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CategoryFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CategoryAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    allCourses<T extends CoursesFindManyArgs = {}>(args?: Subset<T, CoursesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Courses>>, PrismaPromise<Array<CoursesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     * 
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     * 
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     * 
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     * 
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     * 
    **/
    data: Enumerable<CategoryCreateManyInput>
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     * 
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     * 
    **/
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     * 
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     * 
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     * 
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     * 
    **/
    where?: CategoryWhereInput
  }


  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     * 
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Courses
   */


  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesMinAggregateOutputType = {
    id: string | null
    courseName: string | null
    courseDesc: string | null
    courseIntro: string | null
    instructorId: string | null
    courseCategoryId: string | null
    createdAt: Date | null
    updateAt: Date | null
    courseStatus: Status | null
    coursePrice: string | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: string | null
    courseName: string | null
    courseDesc: string | null
    courseIntro: string | null
    instructorId: string | null
    courseCategoryId: string | null
    createdAt: Date | null
    updateAt: Date | null
    courseStatus: Status | null
    coursePrice: string | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    courseName: number
    courseDesc: number
    courseIntro: number
    instructorId: number
    courseCategoryId: number
    createdAt: number
    updateAt: number
    courseStatus: number
    whatYouLearn: number
    coursePrice: number
    _all: number
  }


  export type CoursesMinAggregateInputType = {
    id?: true
    courseName?: true
    courseDesc?: true
    courseIntro?: true
    instructorId?: true
    courseCategoryId?: true
    createdAt?: true
    updateAt?: true
    courseStatus?: true
    coursePrice?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    courseName?: true
    courseDesc?: true
    courseIntro?: true
    instructorId?: true
    courseCategoryId?: true
    createdAt?: true
    updateAt?: true
    courseStatus?: true
    coursePrice?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    courseName?: true
    courseDesc?: true
    courseIntro?: true
    instructorId?: true
    courseCategoryId?: true
    createdAt?: true
    updateAt?: true
    courseStatus?: true
    whatYouLearn?: true
    coursePrice?: true
    _all?: true
  }

  export type CoursesAggregateArgs = {
    /**
     * Filter which Courses to aggregate.
     * 
    **/
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     * 
    **/
    orderBy?: Enumerable<CoursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type CoursesGroupByArgs = {
    where?: CoursesWhereInput
    orderBy?: Enumerable<CoursesOrderByWithAggregationInput>
    by: Array<CoursesScalarFieldEnum>
    having?: CoursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }


  export type CoursesGroupByOutputType = {
    id: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt: Date
    updateAt: Date
    courseStatus: Status
    whatYouLearn: JsonValue[]
    coursePrice: string
    _count: CoursesCountAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends CoursesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type CoursesSelect = {
    id?: boolean
    courseName?: boolean
    courseDesc?: boolean
    courseIntro?: boolean
    instructor?: boolean | UserArgs
    instructorId?: boolean
    courseCategory?: boolean | CategoryArgs
    courseCategoryId?: boolean
    createdAt?: boolean
    updateAt?: boolean
    lectures?: boolean | LecturesFindManyArgs
    totalBatches?: boolean | CourseBatchesFindManyArgs
    courseStatus?: boolean
    whatYouLearn?: boolean
    assignment?: boolean | CourseAssignmentFindManyArgs
    courseQuiz?: boolean | CourseQuizFindManyArgs
    enrollList?: boolean | MyCourseFindManyArgs
    cartList?: boolean | MyCartFindManyArgs
    coursePrice?: boolean
    _count?: boolean | CoursesCountOutputTypeArgs
  }

  export type CoursesInclude = {
    instructor?: boolean | UserArgs
    courseCategory?: boolean | CategoryArgs
    lectures?: boolean | LecturesFindManyArgs
    totalBatches?: boolean | CourseBatchesFindManyArgs
    assignment?: boolean | CourseAssignmentFindManyArgs
    courseQuiz?: boolean | CourseQuizFindManyArgs
    enrollList?: boolean | MyCourseFindManyArgs
    cartList?: boolean | MyCartFindManyArgs
    _count?: boolean | CoursesCountOutputTypeArgs
  }

  export type CoursesGetPayload<
    S extends boolean | null | undefined | CoursesArgs,
    U = keyof S
      > = S extends true
        ? Courses
    : S extends undefined
    ? never
    : S extends CoursesArgs | CoursesFindManyArgs
    ?'include' extends U
    ? Courses  & {
    [P in TrueKeys<S['include']>]:
        P extends 'instructor' ? UserGetPayload<S['include'][P]> :
        P extends 'courseCategory' ? CategoryGetPayload<S['include'][P]> :
        P extends 'lectures' ? Array < LecturesGetPayload<S['include'][P]>>  :
        P extends 'totalBatches' ? Array < CourseBatchesGetPayload<S['include'][P]>>  :
        P extends 'assignment' ? Array < CourseAssignmentGetPayload<S['include'][P]>>  :
        P extends 'courseQuiz' ? Array < CourseQuizGetPayload<S['include'][P]>>  :
        P extends 'enrollList' ? Array < MyCourseGetPayload<S['include'][P]>>  :
        P extends 'cartList' ? Array < MyCartGetPayload<S['include'][P]>>  :
        P extends '_count' ? CoursesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'instructor' ? UserGetPayload<S['select'][P]> :
        P extends 'courseCategory' ? CategoryGetPayload<S['select'][P]> :
        P extends 'lectures' ? Array < LecturesGetPayload<S['select'][P]>>  :
        P extends 'totalBatches' ? Array < CourseBatchesGetPayload<S['select'][P]>>  :
        P extends 'assignment' ? Array < CourseAssignmentGetPayload<S['select'][P]>>  :
        P extends 'courseQuiz' ? Array < CourseQuizGetPayload<S['select'][P]>>  :
        P extends 'enrollList' ? Array < MyCourseGetPayload<S['select'][P]>>  :
        P extends 'cartList' ? Array < MyCartGetPayload<S['select'][P]>>  :
        P extends '_count' ? CoursesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Courses ? Courses[P] : never
  } 
    : Courses
  : Courses


  type CoursesCountArgs = Merge<
    Omit<CoursesFindManyArgs, 'select' | 'include'> & {
      select?: CoursesCountAggregateInputType | true
    }
  >

  export interface CoursesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Courses that matches the filter.
     * @param {CoursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoursesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CoursesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Courses'> extends True ? CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>> : CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoursesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CoursesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Courses'> extends True ? CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>> : CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CoursesFindManyArgs>(
      args?: SelectSubset<T, CoursesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Courses>>, PrismaPromise<Array<CoursesGetPayload<T>>>>

    /**
     * Create a Courses.
     * @param {CoursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
    **/
    create<T extends CoursesCreateArgs>(
      args: SelectSubset<T, CoursesCreateArgs>
    ): CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>>

    /**
     * Create many Courses.
     *     @param {CoursesCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const courses = await prisma.courses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoursesCreateManyArgs>(
      args?: SelectSubset<T, CoursesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Courses.
     * @param {CoursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
    **/
    delete<T extends CoursesDeleteArgs>(
      args: SelectSubset<T, CoursesDeleteArgs>
    ): CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>>

    /**
     * Update one Courses.
     * @param {CoursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoursesUpdateArgs>(
      args: SelectSubset<T, CoursesUpdateArgs>
    ): CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>>

    /**
     * Delete zero or more Courses.
     * @param {CoursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoursesDeleteManyArgs>(
      args?: SelectSubset<T, CoursesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoursesUpdateManyArgs>(
      args: SelectSubset<T, CoursesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Courses.
     * @param {CoursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
    **/
    upsert<T extends CoursesUpsertArgs>(
      args: SelectSubset<T, CoursesUpsertArgs>
    ): CheckSelect<T, Prisma__CoursesClient<Courses>, Prisma__CoursesClient<CoursesGetPayload<T>>>

    /**
     * Find zero or more Courses that matches the filter.
     * @param {CoursesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const courses = await prisma.courses.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CoursesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Courses.
     * @param {CoursesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const courses = await prisma.courses.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CoursesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CoursesCountArgs>(
      args?: Subset<T, CoursesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursesGroupByArgs['orderBy'] }
        : { orderBy?: CoursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoursesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    instructor<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    courseCategory<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    lectures<T extends LecturesFindManyArgs = {}>(args?: Subset<T, LecturesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Lectures>>, PrismaPromise<Array<LecturesGetPayload<T>>>>;

    totalBatches<T extends CourseBatchesFindManyArgs = {}>(args?: Subset<T, CourseBatchesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseBatches>>, PrismaPromise<Array<CourseBatchesGetPayload<T>>>>;

    assignment<T extends CourseAssignmentFindManyArgs = {}>(args?: Subset<T, CourseAssignmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseAssignment>>, PrismaPromise<Array<CourseAssignmentGetPayload<T>>>>;

    courseQuiz<T extends CourseQuizFindManyArgs = {}>(args?: Subset<T, CourseQuizFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseQuiz>>, PrismaPromise<Array<CourseQuizGetPayload<T>>>>;

    enrollList<T extends MyCourseFindManyArgs = {}>(args?: Subset<T, MyCourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MyCourse>>, PrismaPromise<Array<MyCourseGetPayload<T>>>>;

    cartList<T extends MyCartFindManyArgs = {}>(args?: Subset<T, MyCartFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MyCart>>, PrismaPromise<Array<MyCartGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Courses findUnique
   */
  export type CoursesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * Throw an Error if a Courses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Courses to fetch.
     * 
    **/
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses findFirst
   */
  export type CoursesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * Throw an Error if a Courses can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Courses to fetch.
     * 
    **/
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     * 
    **/
    orderBy?: Enumerable<CoursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     * 
    **/
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     * 
    **/
    distinct?: Enumerable<CoursesScalarFieldEnum>
  }


  /**
   * Courses findMany
   */
  export type CoursesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * Filter, which Courses to fetch.
     * 
    **/
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     * 
    **/
    orderBy?: Enumerable<CoursesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     * 
    **/
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CoursesScalarFieldEnum>
  }


  /**
   * Courses create
   */
  export type CoursesCreateArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * The data needed to create a Courses.
     * 
    **/
    data: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
  }


  /**
   * Courses createMany
   */
  export type CoursesCreateManyArgs = {
    /**
     * The data used to create many Courses.
     * 
    **/
    data: Enumerable<CoursesCreateManyInput>
  }


  /**
   * Courses update
   */
  export type CoursesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * The data needed to update a Courses.
     * 
    **/
    data: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
    /**
     * Choose, which Courses to update.
     * 
    **/
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses updateMany
   */
  export type CoursesUpdateManyArgs = {
    /**
     * The data used to update Courses.
     * 
    **/
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     * 
    **/
    where?: CoursesWhereInput
  }


  /**
   * Courses upsert
   */
  export type CoursesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * The filter to search for the Courses to update in case it exists.
     * 
    **/
    where: CoursesWhereUniqueInput
    /**
     * In case the Courses found by the `where` argument doesn't exist, create a new Courses with this data.
     * 
    **/
    create: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
    /**
     * In case the Courses was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
  }


  /**
   * Courses delete
   */
  export type CoursesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
    /**
     * Filter which Courses to delete.
     * 
    **/
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses deleteMany
   */
  export type CoursesDeleteManyArgs = {
    /**
     * Filter which Courses to delete
     * 
    **/
    where?: CoursesWhereInput
  }


  /**
   * Courses findRaw
   */
  export type CoursesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Courses aggregateRaw
   */
  export type CoursesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Courses without action
   */
  export type CoursesArgs = {
    /**
     * Select specific fields to fetch from the Courses
     * 
    **/
    select?: CoursesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CoursesInclude | null
  }



  /**
   * Model Lectures
   */


  export type AggregateLectures = {
    _count: LecturesCountAggregateOutputType | null
    _min: LecturesMinAggregateOutputType | null
    _max: LecturesMaxAggregateOutputType | null
  }

  export type LecturesMinAggregateOutputType = {
    id: string | null
    lectureTitle: string | null
    lectureVideo: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type LecturesMaxAggregateOutputType = {
    id: string | null
    lectureTitle: string | null
    lectureVideo: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type LecturesCountAggregateOutputType = {
    id: number
    lectureTitle: number
    lectureVideo: number
    coursesId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type LecturesMinAggregateInputType = {
    id?: true
    lectureTitle?: true
    lectureVideo?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type LecturesMaxAggregateInputType = {
    id?: true
    lectureTitle?: true
    lectureVideo?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type LecturesCountAggregateInputType = {
    id?: true
    lectureTitle?: true
    lectureVideo?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type LecturesAggregateArgs = {
    /**
     * Filter which Lectures to aggregate.
     * 
    **/
    where?: LecturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     * 
    **/
    orderBy?: Enumerable<LecturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LecturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lectures
    **/
    _count?: true | LecturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LecturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LecturesMaxAggregateInputType
  }

  export type GetLecturesAggregateType<T extends LecturesAggregateArgs> = {
        [P in keyof T & keyof AggregateLectures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLectures[P]>
      : GetScalarType<T[P], AggregateLectures[P]>
  }




  export type LecturesGroupByArgs = {
    where?: LecturesWhereInput
    orderBy?: Enumerable<LecturesOrderByWithAggregationInput>
    by: Array<LecturesScalarFieldEnum>
    having?: LecturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LecturesCountAggregateInputType | true
    _min?: LecturesMinAggregateInputType
    _max?: LecturesMaxAggregateInputType
  }


  export type LecturesGroupByOutputType = {
    id: string
    lectureTitle: string
    lectureVideo: string
    coursesId: string
    createdAt: Date
    updateAt: Date
    _count: LecturesCountAggregateOutputType | null
    _min: LecturesMinAggregateOutputType | null
    _max: LecturesMaxAggregateOutputType | null
  }

  type GetLecturesGroupByPayload<T extends LecturesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LecturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LecturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LecturesGroupByOutputType[P]>
            : GetScalarType<T[P], LecturesGroupByOutputType[P]>
        }
      >
    >


  export type LecturesSelect = {
    id?: boolean
    lectureTitle?: boolean
    lectureVideo?: boolean
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type LecturesInclude = {
    courses?: boolean | CoursesArgs
  }

  export type LecturesGetPayload<
    S extends boolean | null | undefined | LecturesArgs,
    U = keyof S
      > = S extends true
        ? Lectures
    : S extends undefined
    ? never
    : S extends LecturesArgs | LecturesFindManyArgs
    ?'include' extends U
    ? Lectures  & {
    [P in TrueKeys<S['include']>]:
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :  P extends keyof Lectures ? Lectures[P] : never
  } 
    : Lectures
  : Lectures


  type LecturesCountArgs = Merge<
    Omit<LecturesFindManyArgs, 'select' | 'include'> & {
      select?: LecturesCountAggregateInputType | true
    }
  >

  export interface LecturesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Lectures that matches the filter.
     * @param {LecturesFindUniqueArgs} args - Arguments to find a Lectures
     * @example
     * // Get one Lectures
     * const lectures = await prisma.lectures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LecturesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LecturesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lectures'> extends True ? CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>> : CheckSelect<T, Prisma__LecturesClient<Lectures | null >, Prisma__LecturesClient<LecturesGetPayload<T> | null >>

    /**
     * Find the first Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesFindFirstArgs} args - Arguments to find a Lectures
     * @example
     * // Get one Lectures
     * const lectures = await prisma.lectures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LecturesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LecturesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lectures'> extends True ? CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>> : CheckSelect<T, Prisma__LecturesClient<Lectures | null >, Prisma__LecturesClient<LecturesGetPayload<T> | null >>

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lectures.findMany()
     * 
     * // Get first 10 Lectures
     * const lectures = await prisma.lectures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lecturesWithIdOnly = await prisma.lectures.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LecturesFindManyArgs>(
      args?: SelectSubset<T, LecturesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Lectures>>, PrismaPromise<Array<LecturesGetPayload<T>>>>

    /**
     * Create a Lectures.
     * @param {LecturesCreateArgs} args - Arguments to create a Lectures.
     * @example
     * // Create one Lectures
     * const Lectures = await prisma.lectures.create({
     *   data: {
     *     // ... data to create a Lectures
     *   }
     * })
     * 
    **/
    create<T extends LecturesCreateArgs>(
      args: SelectSubset<T, LecturesCreateArgs>
    ): CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>>

    /**
     * Create many Lectures.
     *     @param {LecturesCreateManyArgs} args - Arguments to create many Lectures.
     *     @example
     *     // Create many Lectures
     *     const lectures = await prisma.lectures.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LecturesCreateManyArgs>(
      args?: SelectSubset<T, LecturesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Lectures.
     * @param {LecturesDeleteArgs} args - Arguments to delete one Lectures.
     * @example
     * // Delete one Lectures
     * const Lectures = await prisma.lectures.delete({
     *   where: {
     *     // ... filter to delete one Lectures
     *   }
     * })
     * 
    **/
    delete<T extends LecturesDeleteArgs>(
      args: SelectSubset<T, LecturesDeleteArgs>
    ): CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>>

    /**
     * Update one Lectures.
     * @param {LecturesUpdateArgs} args - Arguments to update one Lectures.
     * @example
     * // Update one Lectures
     * const lectures = await prisma.lectures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LecturesUpdateArgs>(
      args: SelectSubset<T, LecturesUpdateArgs>
    ): CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>>

    /**
     * Delete zero or more Lectures.
     * @param {LecturesDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lectures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LecturesDeleteManyArgs>(
      args?: SelectSubset<T, LecturesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lectures = await prisma.lectures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LecturesUpdateManyArgs>(
      args: SelectSubset<T, LecturesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Lectures.
     * @param {LecturesUpsertArgs} args - Arguments to update or create a Lectures.
     * @example
     * // Update or create a Lectures
     * const lectures = await prisma.lectures.upsert({
     *   create: {
     *     // ... data to create a Lectures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lectures we want to update
     *   }
     * })
    **/
    upsert<T extends LecturesUpsertArgs>(
      args: SelectSubset<T, LecturesUpsertArgs>
    ): CheckSelect<T, Prisma__LecturesClient<Lectures>, Prisma__LecturesClient<LecturesGetPayload<T>>>

    /**
     * Find zero or more Lectures that matches the filter.
     * @param {LecturesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const lectures = await prisma.lectures.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: LecturesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Lectures.
     * @param {LecturesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const lectures = await prisma.lectures.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: LecturesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lectures.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
    **/
    count<T extends LecturesCountArgs>(
      args?: Subset<T, LecturesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LecturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LecturesAggregateArgs>(args: Subset<T, LecturesAggregateArgs>): PrismaPromise<GetLecturesAggregateType<T>>

    /**
     * Group by Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LecturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LecturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LecturesGroupByArgs['orderBy'] }
        : { orderBy?: LecturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LecturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLecturesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lectures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LecturesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Lectures findUnique
   */
  export type LecturesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * Throw an Error if a Lectures can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lectures to fetch.
     * 
    **/
    where: LecturesWhereUniqueInput
  }


  /**
   * Lectures findFirst
   */
  export type LecturesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * Throw an Error if a Lectures can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Lectures to fetch.
     * 
    **/
    where?: LecturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     * 
    **/
    orderBy?: Enumerable<LecturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
     * 
    **/
    cursor?: LecturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
     * 
    **/
    distinct?: Enumerable<LecturesScalarFieldEnum>
  }


  /**
   * Lectures findMany
   */
  export type LecturesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * Filter, which Lectures to fetch.
     * 
    **/
    where?: LecturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     * 
    **/
    orderBy?: Enumerable<LecturesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lectures.
     * 
    **/
    cursor?: LecturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LecturesScalarFieldEnum>
  }


  /**
   * Lectures create
   */
  export type LecturesCreateArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * The data needed to create a Lectures.
     * 
    **/
    data: XOR<LecturesCreateInput, LecturesUncheckedCreateInput>
  }


  /**
   * Lectures createMany
   */
  export type LecturesCreateManyArgs = {
    /**
     * The data used to create many Lectures.
     * 
    **/
    data: Enumerable<LecturesCreateManyInput>
  }


  /**
   * Lectures update
   */
  export type LecturesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * The data needed to update a Lectures.
     * 
    **/
    data: XOR<LecturesUpdateInput, LecturesUncheckedUpdateInput>
    /**
     * Choose, which Lectures to update.
     * 
    **/
    where: LecturesWhereUniqueInput
  }


  /**
   * Lectures updateMany
   */
  export type LecturesUpdateManyArgs = {
    /**
     * The data used to update Lectures.
     * 
    **/
    data: XOR<LecturesUpdateManyMutationInput, LecturesUncheckedUpdateManyInput>
    /**
     * Filter which Lectures to update
     * 
    **/
    where?: LecturesWhereInput
  }


  /**
   * Lectures upsert
   */
  export type LecturesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * The filter to search for the Lectures to update in case it exists.
     * 
    **/
    where: LecturesWhereUniqueInput
    /**
     * In case the Lectures found by the `where` argument doesn't exist, create a new Lectures with this data.
     * 
    **/
    create: XOR<LecturesCreateInput, LecturesUncheckedCreateInput>
    /**
     * In case the Lectures was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LecturesUpdateInput, LecturesUncheckedUpdateInput>
  }


  /**
   * Lectures delete
   */
  export type LecturesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
    /**
     * Filter which Lectures to delete.
     * 
    **/
    where: LecturesWhereUniqueInput
  }


  /**
   * Lectures deleteMany
   */
  export type LecturesDeleteManyArgs = {
    /**
     * Filter which Lectures to delete
     * 
    **/
    where?: LecturesWhereInput
  }


  /**
   * Lectures findRaw
   */
  export type LecturesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Lectures aggregateRaw
   */
  export type LecturesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Lectures without action
   */
  export type LecturesArgs = {
    /**
     * Select specific fields to fetch from the Lectures
     * 
    **/
    select?: LecturesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LecturesInclude | null
  }



  /**
   * Model CourseBatches
   */


  export type AggregateCourseBatches = {
    _count: CourseBatchesCountAggregateOutputType | null
    _min: CourseBatchesMinAggregateOutputType | null
    _max: CourseBatchesMaxAggregateOutputType | null
  }

  export type CourseBatchesMinAggregateOutputType = {
    id: string | null
    name: string | null
    coursesId: string | null
    courseName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseBatchesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    coursesId: string | null
    courseName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseBatchesCountAggregateOutputType = {
    id: number
    name: number
    coursesId: number
    courseName: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type CourseBatchesMinAggregateInputType = {
    id?: true
    name?: true
    coursesId?: true
    courseName?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseBatchesMaxAggregateInputType = {
    id?: true
    name?: true
    coursesId?: true
    courseName?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseBatchesCountAggregateInputType = {
    id?: true
    name?: true
    coursesId?: true
    courseName?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type CourseBatchesAggregateArgs = {
    /**
     * Filter which CourseBatches to aggregate.
     * 
    **/
    where?: CourseBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBatches to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseBatchesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CourseBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBatches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBatches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseBatches
    **/
    _count?: true | CourseBatchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseBatchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseBatchesMaxAggregateInputType
  }

  export type GetCourseBatchesAggregateType<T extends CourseBatchesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseBatches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseBatches[P]>
      : GetScalarType<T[P], AggregateCourseBatches[P]>
  }




  export type CourseBatchesGroupByArgs = {
    where?: CourseBatchesWhereInput
    orderBy?: Enumerable<CourseBatchesOrderByWithAggregationInput>
    by: Array<CourseBatchesScalarFieldEnum>
    having?: CourseBatchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseBatchesCountAggregateInputType | true
    _min?: CourseBatchesMinAggregateInputType
    _max?: CourseBatchesMaxAggregateInputType
  }


  export type CourseBatchesGroupByOutputType = {
    id: string
    name: string
    coursesId: string
    courseName: string
    createdAt: Date
    updateAt: Date
    _count: CourseBatchesCountAggregateOutputType | null
    _min: CourseBatchesMinAggregateOutputType | null
    _max: CourseBatchesMaxAggregateOutputType | null
  }

  type GetCourseBatchesGroupByPayload<T extends CourseBatchesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CourseBatchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseBatchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseBatchesGroupByOutputType[P]>
            : GetScalarType<T[P], CourseBatchesGroupByOutputType[P]>
        }
      >
    >


  export type CourseBatchesSelect = {
    id?: boolean
    name?: boolean
    assignment?: boolean | CourseAssignmentFindManyArgs
    quiz?: boolean | CourseQuizFindManyArgs
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    courseName?: boolean
    createdAt?: boolean
    updateAt?: boolean
    enrolledStudent?: boolean | MyCourseFindManyArgs
    _count?: boolean | CourseBatchesCountOutputTypeArgs
  }

  export type CourseBatchesInclude = {
    assignment?: boolean | CourseAssignmentFindManyArgs
    quiz?: boolean | CourseQuizFindManyArgs
    courses?: boolean | CoursesArgs
    enrolledStudent?: boolean | MyCourseFindManyArgs
    _count?: boolean | CourseBatchesCountOutputTypeArgs
  }

  export type CourseBatchesGetPayload<
    S extends boolean | null | undefined | CourseBatchesArgs,
    U = keyof S
      > = S extends true
        ? CourseBatches
    : S extends undefined
    ? never
    : S extends CourseBatchesArgs | CourseBatchesFindManyArgs
    ?'include' extends U
    ? CourseBatches  & {
    [P in TrueKeys<S['include']>]:
        P extends 'assignment' ? Array < CourseAssignmentGetPayload<S['include'][P]>>  :
        P extends 'quiz' ? Array < CourseQuizGetPayload<S['include'][P]>>  :
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :
        P extends 'enrolledStudent' ? Array < MyCourseGetPayload<S['include'][P]>>  :
        P extends '_count' ? CourseBatchesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'assignment' ? Array < CourseAssignmentGetPayload<S['select'][P]>>  :
        P extends 'quiz' ? Array < CourseQuizGetPayload<S['select'][P]>>  :
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :
        P extends 'enrolledStudent' ? Array < MyCourseGetPayload<S['select'][P]>>  :
        P extends '_count' ? CourseBatchesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CourseBatches ? CourseBatches[P] : never
  } 
    : CourseBatches
  : CourseBatches


  type CourseBatchesCountArgs = Merge<
    Omit<CourseBatchesFindManyArgs, 'select' | 'include'> & {
      select?: CourseBatchesCountAggregateInputType | true
    }
  >

  export interface CourseBatchesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CourseBatches that matches the filter.
     * @param {CourseBatchesFindUniqueArgs} args - Arguments to find a CourseBatches
     * @example
     * // Get one CourseBatches
     * const courseBatches = await prisma.courseBatches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseBatchesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseBatchesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CourseBatches'> extends True ? CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>> : CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches | null >, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T> | null >>

    /**
     * Find the first CourseBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesFindFirstArgs} args - Arguments to find a CourseBatches
     * @example
     * // Get one CourseBatches
     * const courseBatches = await prisma.courseBatches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseBatchesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseBatchesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CourseBatches'> extends True ? CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>> : CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches | null >, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T> | null >>

    /**
     * Find zero or more CourseBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseBatches
     * const courseBatches = await prisma.courseBatches.findMany()
     * 
     * // Get first 10 CourseBatches
     * const courseBatches = await prisma.courseBatches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseBatchesWithIdOnly = await prisma.courseBatches.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseBatchesFindManyArgs>(
      args?: SelectSubset<T, CourseBatchesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CourseBatches>>, PrismaPromise<Array<CourseBatchesGetPayload<T>>>>

    /**
     * Create a CourseBatches.
     * @param {CourseBatchesCreateArgs} args - Arguments to create a CourseBatches.
     * @example
     * // Create one CourseBatches
     * const CourseBatches = await prisma.courseBatches.create({
     *   data: {
     *     // ... data to create a CourseBatches
     *   }
     * })
     * 
    **/
    create<T extends CourseBatchesCreateArgs>(
      args: SelectSubset<T, CourseBatchesCreateArgs>
    ): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>>

    /**
     * Create many CourseBatches.
     *     @param {CourseBatchesCreateManyArgs} args - Arguments to create many CourseBatches.
     *     @example
     *     // Create many CourseBatches
     *     const courseBatches = await prisma.courseBatches.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseBatchesCreateManyArgs>(
      args?: SelectSubset<T, CourseBatchesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CourseBatches.
     * @param {CourseBatchesDeleteArgs} args - Arguments to delete one CourseBatches.
     * @example
     * // Delete one CourseBatches
     * const CourseBatches = await prisma.courseBatches.delete({
     *   where: {
     *     // ... filter to delete one CourseBatches
     *   }
     * })
     * 
    **/
    delete<T extends CourseBatchesDeleteArgs>(
      args: SelectSubset<T, CourseBatchesDeleteArgs>
    ): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>>

    /**
     * Update one CourseBatches.
     * @param {CourseBatchesUpdateArgs} args - Arguments to update one CourseBatches.
     * @example
     * // Update one CourseBatches
     * const courseBatches = await prisma.courseBatches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseBatchesUpdateArgs>(
      args: SelectSubset<T, CourseBatchesUpdateArgs>
    ): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>>

    /**
     * Delete zero or more CourseBatches.
     * @param {CourseBatchesDeleteManyArgs} args - Arguments to filter CourseBatches to delete.
     * @example
     * // Delete a few CourseBatches
     * const { count } = await prisma.courseBatches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseBatchesDeleteManyArgs>(
      args?: SelectSubset<T, CourseBatchesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseBatches
     * const courseBatches = await prisma.courseBatches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseBatchesUpdateManyArgs>(
      args: SelectSubset<T, CourseBatchesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseBatches.
     * @param {CourseBatchesUpsertArgs} args - Arguments to update or create a CourseBatches.
     * @example
     * // Update or create a CourseBatches
     * const courseBatches = await prisma.courseBatches.upsert({
     *   create: {
     *     // ... data to create a CourseBatches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseBatches we want to update
     *   }
     * })
    **/
    upsert<T extends CourseBatchesUpsertArgs>(
      args: SelectSubset<T, CourseBatchesUpsertArgs>
    ): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches>, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T>>>

    /**
     * Find zero or more CourseBatches that matches the filter.
     * @param {CourseBatchesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const courseBatches = await prisma.courseBatches.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CourseBatchesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CourseBatches.
     * @param {CourseBatchesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const courseBatches = await prisma.courseBatches.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CourseBatchesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of CourseBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesCountArgs} args - Arguments to filter CourseBatches to count.
     * @example
     * // Count the number of CourseBatches
     * const count = await prisma.courseBatches.count({
     *   where: {
     *     // ... the filter for the CourseBatches we want to count
     *   }
     * })
    **/
    count<T extends CourseBatchesCountArgs>(
      args?: Subset<T, CourseBatchesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseBatchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseBatchesAggregateArgs>(args: Subset<T, CourseBatchesAggregateArgs>): PrismaPromise<GetCourseBatchesAggregateType<T>>

    /**
     * Group by CourseBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseBatchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseBatchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseBatchesGroupByArgs['orderBy'] }
        : { orderBy?: CourseBatchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseBatchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseBatchesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseBatches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseBatchesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    assignment<T extends CourseAssignmentFindManyArgs = {}>(args?: Subset<T, CourseAssignmentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseAssignment>>, PrismaPromise<Array<CourseAssignmentGetPayload<T>>>>;

    quiz<T extends CourseQuizFindManyArgs = {}>(args?: Subset<T, CourseQuizFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CourseQuiz>>, PrismaPromise<Array<CourseQuizGetPayload<T>>>>;

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    enrolledStudent<T extends MyCourseFindManyArgs = {}>(args?: Subset<T, MyCourseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MyCourse>>, PrismaPromise<Array<MyCourseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CourseBatches findUnique
   */
  export type CourseBatchesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * Throw an Error if a CourseBatches can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseBatches to fetch.
     * 
    **/
    where: CourseBatchesWhereUniqueInput
  }


  /**
   * CourseBatches findFirst
   */
  export type CourseBatchesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * Throw an Error if a CourseBatches can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseBatches to fetch.
     * 
    **/
    where?: CourseBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBatches to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseBatchesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseBatches.
     * 
    **/
    cursor?: CourseBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBatches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBatches.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseBatches.
     * 
    **/
    distinct?: Enumerable<CourseBatchesScalarFieldEnum>
  }


  /**
   * CourseBatches findMany
   */
  export type CourseBatchesFindManyArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * Filter, which CourseBatches to fetch.
     * 
    **/
    where?: CourseBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseBatches to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseBatchesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseBatches.
     * 
    **/
    cursor?: CourseBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseBatches from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseBatches.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CourseBatchesScalarFieldEnum>
  }


  /**
   * CourseBatches create
   */
  export type CourseBatchesCreateArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * The data needed to create a CourseBatches.
     * 
    **/
    data: XOR<CourseBatchesCreateInput, CourseBatchesUncheckedCreateInput>
  }


  /**
   * CourseBatches createMany
   */
  export type CourseBatchesCreateManyArgs = {
    /**
     * The data used to create many CourseBatches.
     * 
    **/
    data: Enumerable<CourseBatchesCreateManyInput>
  }


  /**
   * CourseBatches update
   */
  export type CourseBatchesUpdateArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * The data needed to update a CourseBatches.
     * 
    **/
    data: XOR<CourseBatchesUpdateInput, CourseBatchesUncheckedUpdateInput>
    /**
     * Choose, which CourseBatches to update.
     * 
    **/
    where: CourseBatchesWhereUniqueInput
  }


  /**
   * CourseBatches updateMany
   */
  export type CourseBatchesUpdateManyArgs = {
    /**
     * The data used to update CourseBatches.
     * 
    **/
    data: XOR<CourseBatchesUpdateManyMutationInput, CourseBatchesUncheckedUpdateManyInput>
    /**
     * Filter which CourseBatches to update
     * 
    **/
    where?: CourseBatchesWhereInput
  }


  /**
   * CourseBatches upsert
   */
  export type CourseBatchesUpsertArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * The filter to search for the CourseBatches to update in case it exists.
     * 
    **/
    where: CourseBatchesWhereUniqueInput
    /**
     * In case the CourseBatches found by the `where` argument doesn't exist, create a new CourseBatches with this data.
     * 
    **/
    create: XOR<CourseBatchesCreateInput, CourseBatchesUncheckedCreateInput>
    /**
     * In case the CourseBatches was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CourseBatchesUpdateInput, CourseBatchesUncheckedUpdateInput>
  }


  /**
   * CourseBatches delete
   */
  export type CourseBatchesDeleteArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
    /**
     * Filter which CourseBatches to delete.
     * 
    **/
    where: CourseBatchesWhereUniqueInput
  }


  /**
   * CourseBatches deleteMany
   */
  export type CourseBatchesDeleteManyArgs = {
    /**
     * Filter which CourseBatches to delete
     * 
    **/
    where?: CourseBatchesWhereInput
  }


  /**
   * CourseBatches findRaw
   */
  export type CourseBatchesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseBatches aggregateRaw
   */
  export type CourseBatchesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseBatches without action
   */
  export type CourseBatchesArgs = {
    /**
     * Select specific fields to fetch from the CourseBatches
     * 
    **/
    select?: CourseBatchesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseBatchesInclude | null
  }



  /**
   * Model CourseAssignment
   */


  export type AggregateCourseAssignment = {
    _count: CourseAssignmentCountAggregateOutputType | null
    _min: CourseAssignmentMinAggregateOutputType | null
    _max: CourseAssignmentMaxAggregateOutputType | null
  }

  export type CourseAssignmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    courseBatchesId: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseAssignmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    courseBatchesId: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseAssignmentCountAggregateOutputType = {
    id: number
    name: number
    courseBatchesId: number
    coursesId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type CourseAssignmentMinAggregateInputType = {
    id?: true
    name?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseAssignmentMaxAggregateInputType = {
    id?: true
    name?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseAssignmentCountAggregateInputType = {
    id?: true
    name?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type CourseAssignmentAggregateArgs = {
    /**
     * Filter which CourseAssignment to aggregate.
     * 
    **/
    where?: CourseAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAssignments to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CourseAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAssignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAssignments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseAssignments
    **/
    _count?: true | CourseAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseAssignmentMaxAggregateInputType
  }

  export type GetCourseAssignmentAggregateType<T extends CourseAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseAssignment[P]>
      : GetScalarType<T[P], AggregateCourseAssignment[P]>
  }




  export type CourseAssignmentGroupByArgs = {
    where?: CourseAssignmentWhereInput
    orderBy?: Enumerable<CourseAssignmentOrderByWithAggregationInput>
    by: Array<CourseAssignmentScalarFieldEnum>
    having?: CourseAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseAssignmentCountAggregateInputType | true
    _min?: CourseAssignmentMinAggregateInputType
    _max?: CourseAssignmentMaxAggregateInputType
  }


  export type CourseAssignmentGroupByOutputType = {
    id: string
    name: string
    courseBatchesId: string
    coursesId: string
    createdAt: Date
    updateAt: Date
    _count: CourseAssignmentCountAggregateOutputType | null
    _min: CourseAssignmentMinAggregateOutputType | null
    _max: CourseAssignmentMaxAggregateOutputType | null
  }

  type GetCourseAssignmentGroupByPayload<T extends CourseAssignmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CourseAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type CourseAssignmentSelect = {
    id?: boolean
    name?: boolean
    CourseBatches?: boolean | CourseBatchesArgs
    courseBatchesId?: boolean
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type CourseAssignmentInclude = {
    CourseBatches?: boolean | CourseBatchesArgs
    courses?: boolean | CoursesArgs
  }

  export type CourseAssignmentGetPayload<
    S extends boolean | null | undefined | CourseAssignmentArgs,
    U = keyof S
      > = S extends true
        ? CourseAssignment
    : S extends undefined
    ? never
    : S extends CourseAssignmentArgs | CourseAssignmentFindManyArgs
    ?'include' extends U
    ? CourseAssignment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'CourseBatches' ? CourseBatchesGetPayload<S['include'][P]> :
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'CourseBatches' ? CourseBatchesGetPayload<S['select'][P]> :
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :  P extends keyof CourseAssignment ? CourseAssignment[P] : never
  } 
    : CourseAssignment
  : CourseAssignment


  type CourseAssignmentCountArgs = Merge<
    Omit<CourseAssignmentFindManyArgs, 'select' | 'include'> & {
      select?: CourseAssignmentCountAggregateInputType | true
    }
  >

  export interface CourseAssignmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CourseAssignment that matches the filter.
     * @param {CourseAssignmentFindUniqueArgs} args - Arguments to find a CourseAssignment
     * @example
     * // Get one CourseAssignment
     * const courseAssignment = await prisma.courseAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseAssignmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseAssignmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CourseAssignment'> extends True ? CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>> : CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment | null >, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T> | null >>

    /**
     * Find the first CourseAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentFindFirstArgs} args - Arguments to find a CourseAssignment
     * @example
     * // Get one CourseAssignment
     * const courseAssignment = await prisma.courseAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseAssignmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseAssignmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CourseAssignment'> extends True ? CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>> : CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment | null >, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T> | null >>

    /**
     * Find zero or more CourseAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseAssignments
     * const courseAssignments = await prisma.courseAssignment.findMany()
     * 
     * // Get first 10 CourseAssignments
     * const courseAssignments = await prisma.courseAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseAssignmentWithIdOnly = await prisma.courseAssignment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseAssignmentFindManyArgs>(
      args?: SelectSubset<T, CourseAssignmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CourseAssignment>>, PrismaPromise<Array<CourseAssignmentGetPayload<T>>>>

    /**
     * Create a CourseAssignment.
     * @param {CourseAssignmentCreateArgs} args - Arguments to create a CourseAssignment.
     * @example
     * // Create one CourseAssignment
     * const CourseAssignment = await prisma.courseAssignment.create({
     *   data: {
     *     // ... data to create a CourseAssignment
     *   }
     * })
     * 
    **/
    create<T extends CourseAssignmentCreateArgs>(
      args: SelectSubset<T, CourseAssignmentCreateArgs>
    ): CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>>

    /**
     * Create many CourseAssignments.
     *     @param {CourseAssignmentCreateManyArgs} args - Arguments to create many CourseAssignments.
     *     @example
     *     // Create many CourseAssignments
     *     const courseAssignment = await prisma.courseAssignment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseAssignmentCreateManyArgs>(
      args?: SelectSubset<T, CourseAssignmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CourseAssignment.
     * @param {CourseAssignmentDeleteArgs} args - Arguments to delete one CourseAssignment.
     * @example
     * // Delete one CourseAssignment
     * const CourseAssignment = await prisma.courseAssignment.delete({
     *   where: {
     *     // ... filter to delete one CourseAssignment
     *   }
     * })
     * 
    **/
    delete<T extends CourseAssignmentDeleteArgs>(
      args: SelectSubset<T, CourseAssignmentDeleteArgs>
    ): CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>>

    /**
     * Update one CourseAssignment.
     * @param {CourseAssignmentUpdateArgs} args - Arguments to update one CourseAssignment.
     * @example
     * // Update one CourseAssignment
     * const courseAssignment = await prisma.courseAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseAssignmentUpdateArgs>(
      args: SelectSubset<T, CourseAssignmentUpdateArgs>
    ): CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>>

    /**
     * Delete zero or more CourseAssignments.
     * @param {CourseAssignmentDeleteManyArgs} args - Arguments to filter CourseAssignments to delete.
     * @example
     * // Delete a few CourseAssignments
     * const { count } = await prisma.courseAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseAssignmentDeleteManyArgs>(
      args?: SelectSubset<T, CourseAssignmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseAssignments
     * const courseAssignment = await prisma.courseAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseAssignmentUpdateManyArgs>(
      args: SelectSubset<T, CourseAssignmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseAssignment.
     * @param {CourseAssignmentUpsertArgs} args - Arguments to update or create a CourseAssignment.
     * @example
     * // Update or create a CourseAssignment
     * const courseAssignment = await prisma.courseAssignment.upsert({
     *   create: {
     *     // ... data to create a CourseAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseAssignment we want to update
     *   }
     * })
    **/
    upsert<T extends CourseAssignmentUpsertArgs>(
      args: SelectSubset<T, CourseAssignmentUpsertArgs>
    ): CheckSelect<T, Prisma__CourseAssignmentClient<CourseAssignment>, Prisma__CourseAssignmentClient<CourseAssignmentGetPayload<T>>>

    /**
     * Find zero or more CourseAssignments that matches the filter.
     * @param {CourseAssignmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const courseAssignment = await prisma.courseAssignment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CourseAssignmentFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CourseAssignment.
     * @param {CourseAssignmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const courseAssignment = await prisma.courseAssignment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CourseAssignmentAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of CourseAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentCountArgs} args - Arguments to filter CourseAssignments to count.
     * @example
     * // Count the number of CourseAssignments
     * const count = await prisma.courseAssignment.count({
     *   where: {
     *     // ... the filter for the CourseAssignments we want to count
     *   }
     * })
    **/
    count<T extends CourseAssignmentCountArgs>(
      args?: Subset<T, CourseAssignmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAssignmentAggregateArgs>(args: Subset<T, CourseAssignmentAggregateArgs>): PrismaPromise<GetCourseAssignmentAggregateType<T>>

    /**
     * Group by CourseAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: CourseAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseAssignmentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseAssignmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CourseBatches<T extends CourseBatchesArgs = {}>(args?: Subset<T, CourseBatchesArgs>): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches | null >, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T> | null >>;

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CourseAssignment findUnique
   */
  export type CourseAssignmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * Throw an Error if a CourseAssignment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseAssignment to fetch.
     * 
    **/
    where: CourseAssignmentWhereUniqueInput
  }


  /**
   * CourseAssignment findFirst
   */
  export type CourseAssignmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * Throw an Error if a CourseAssignment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseAssignment to fetch.
     * 
    **/
    where?: CourseAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAssignments to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseAssignments.
     * 
    **/
    cursor?: CourseAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAssignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAssignments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseAssignments.
     * 
    **/
    distinct?: Enumerable<CourseAssignmentScalarFieldEnum>
  }


  /**
   * CourseAssignment findMany
   */
  export type CourseAssignmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * Filter, which CourseAssignments to fetch.
     * 
    **/
    where?: CourseAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAssignments to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseAssignmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseAssignments.
     * 
    **/
    cursor?: CourseAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAssignments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAssignments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CourseAssignmentScalarFieldEnum>
  }


  /**
   * CourseAssignment create
   */
  export type CourseAssignmentCreateArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * The data needed to create a CourseAssignment.
     * 
    **/
    data: XOR<CourseAssignmentCreateInput, CourseAssignmentUncheckedCreateInput>
  }


  /**
   * CourseAssignment createMany
   */
  export type CourseAssignmentCreateManyArgs = {
    /**
     * The data used to create many CourseAssignments.
     * 
    **/
    data: Enumerable<CourseAssignmentCreateManyInput>
  }


  /**
   * CourseAssignment update
   */
  export type CourseAssignmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * The data needed to update a CourseAssignment.
     * 
    **/
    data: XOR<CourseAssignmentUpdateInput, CourseAssignmentUncheckedUpdateInput>
    /**
     * Choose, which CourseAssignment to update.
     * 
    **/
    where: CourseAssignmentWhereUniqueInput
  }


  /**
   * CourseAssignment updateMany
   */
  export type CourseAssignmentUpdateManyArgs = {
    /**
     * The data used to update CourseAssignments.
     * 
    **/
    data: XOR<CourseAssignmentUpdateManyMutationInput, CourseAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CourseAssignments to update
     * 
    **/
    where?: CourseAssignmentWhereInput
  }


  /**
   * CourseAssignment upsert
   */
  export type CourseAssignmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * The filter to search for the CourseAssignment to update in case it exists.
     * 
    **/
    where: CourseAssignmentWhereUniqueInput
    /**
     * In case the CourseAssignment found by the `where` argument doesn't exist, create a new CourseAssignment with this data.
     * 
    **/
    create: XOR<CourseAssignmentCreateInput, CourseAssignmentUncheckedCreateInput>
    /**
     * In case the CourseAssignment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CourseAssignmentUpdateInput, CourseAssignmentUncheckedUpdateInput>
  }


  /**
   * CourseAssignment delete
   */
  export type CourseAssignmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
    /**
     * Filter which CourseAssignment to delete.
     * 
    **/
    where: CourseAssignmentWhereUniqueInput
  }


  /**
   * CourseAssignment deleteMany
   */
  export type CourseAssignmentDeleteManyArgs = {
    /**
     * Filter which CourseAssignments to delete
     * 
    **/
    where?: CourseAssignmentWhereInput
  }


  /**
   * CourseAssignment findRaw
   */
  export type CourseAssignmentFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseAssignment aggregateRaw
   */
  export type CourseAssignmentAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseAssignment without action
   */
  export type CourseAssignmentArgs = {
    /**
     * Select specific fields to fetch from the CourseAssignment
     * 
    **/
    select?: CourseAssignmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseAssignmentInclude | null
  }



  /**
   * Model CourseQuiz
   */


  export type AggregateCourseQuiz = {
    _count: CourseQuizCountAggregateOutputType | null
    _min: CourseQuizMinAggregateOutputType | null
    _max: CourseQuizMaxAggregateOutputType | null
  }

  export type CourseQuizMinAggregateOutputType = {
    id: string | null
    courseBatchesId: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseQuizMaxAggregateOutputType = {
    id: string | null
    courseBatchesId: string | null
    coursesId: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type CourseQuizCountAggregateOutputType = {
    id: number
    courseBatchesId: number
    coursesId: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type CourseQuizMinAggregateInputType = {
    id?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseQuizMaxAggregateInputType = {
    id?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
  }

  export type CourseQuizCountAggregateInputType = {
    id?: true
    courseBatchesId?: true
    coursesId?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type CourseQuizAggregateArgs = {
    /**
     * Filter which CourseQuiz to aggregate.
     * 
    **/
    where?: CourseQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseQuizs to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseQuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CourseQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseQuizs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseQuizs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseQuizs
    **/
    _count?: true | CourseQuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseQuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseQuizMaxAggregateInputType
  }

  export type GetCourseQuizAggregateType<T extends CourseQuizAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseQuiz[P]>
      : GetScalarType<T[P], AggregateCourseQuiz[P]>
  }




  export type CourseQuizGroupByArgs = {
    where?: CourseQuizWhereInput
    orderBy?: Enumerable<CourseQuizOrderByWithAggregationInput>
    by: Array<CourseQuizScalarFieldEnum>
    having?: CourseQuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseQuizCountAggregateInputType | true
    _min?: CourseQuizMinAggregateInputType
    _max?: CourseQuizMaxAggregateInputType
  }


  export type CourseQuizGroupByOutputType = {
    id: string
    courseBatchesId: string
    coursesId: string
    createdAt: Date
    updateAt: Date
    _count: CourseQuizCountAggregateOutputType | null
    _min: CourseQuizMinAggregateOutputType | null
    _max: CourseQuizMaxAggregateOutputType | null
  }

  type GetCourseQuizGroupByPayload<T extends CourseQuizGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CourseQuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseQuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseQuizGroupByOutputType[P]>
            : GetScalarType<T[P], CourseQuizGroupByOutputType[P]>
        }
      >
    >


  export type CourseQuizSelect = {
    id?: boolean
    courseBatches?: boolean | CourseBatchesArgs
    courseBatchesId?: boolean
    courses?: boolean | CoursesArgs
    coursesId?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type CourseQuizInclude = {
    courseBatches?: boolean | CourseBatchesArgs
    courses?: boolean | CoursesArgs
  }

  export type CourseQuizGetPayload<
    S extends boolean | null | undefined | CourseQuizArgs,
    U = keyof S
      > = S extends true
        ? CourseQuiz
    : S extends undefined
    ? never
    : S extends CourseQuizArgs | CourseQuizFindManyArgs
    ?'include' extends U
    ? CourseQuiz  & {
    [P in TrueKeys<S['include']>]:
        P extends 'courseBatches' ? CourseBatchesGetPayload<S['include'][P]> :
        P extends 'courses' ? CoursesGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'courseBatches' ? CourseBatchesGetPayload<S['select'][P]> :
        P extends 'courses' ? CoursesGetPayload<S['select'][P]> :  P extends keyof CourseQuiz ? CourseQuiz[P] : never
  } 
    : CourseQuiz
  : CourseQuiz


  type CourseQuizCountArgs = Merge<
    Omit<CourseQuizFindManyArgs, 'select' | 'include'> & {
      select?: CourseQuizCountAggregateInputType | true
    }
  >

  export interface CourseQuizDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CourseQuiz that matches the filter.
     * @param {CourseQuizFindUniqueArgs} args - Arguments to find a CourseQuiz
     * @example
     * // Get one CourseQuiz
     * const courseQuiz = await prisma.courseQuiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseQuizFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseQuizFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CourseQuiz'> extends True ? CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>> : CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz | null >, Prisma__CourseQuizClient<CourseQuizGetPayload<T> | null >>

    /**
     * Find the first CourseQuiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizFindFirstArgs} args - Arguments to find a CourseQuiz
     * @example
     * // Get one CourseQuiz
     * const courseQuiz = await prisma.courseQuiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseQuizFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseQuizFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CourseQuiz'> extends True ? CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>> : CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz | null >, Prisma__CourseQuizClient<CourseQuizGetPayload<T> | null >>

    /**
     * Find zero or more CourseQuizs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseQuizs
     * const courseQuizs = await prisma.courseQuiz.findMany()
     * 
     * // Get first 10 CourseQuizs
     * const courseQuizs = await prisma.courseQuiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseQuizWithIdOnly = await prisma.courseQuiz.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseQuizFindManyArgs>(
      args?: SelectSubset<T, CourseQuizFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CourseQuiz>>, PrismaPromise<Array<CourseQuizGetPayload<T>>>>

    /**
     * Create a CourseQuiz.
     * @param {CourseQuizCreateArgs} args - Arguments to create a CourseQuiz.
     * @example
     * // Create one CourseQuiz
     * const CourseQuiz = await prisma.courseQuiz.create({
     *   data: {
     *     // ... data to create a CourseQuiz
     *   }
     * })
     * 
    **/
    create<T extends CourseQuizCreateArgs>(
      args: SelectSubset<T, CourseQuizCreateArgs>
    ): CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>>

    /**
     * Create many CourseQuizs.
     *     @param {CourseQuizCreateManyArgs} args - Arguments to create many CourseQuizs.
     *     @example
     *     // Create many CourseQuizs
     *     const courseQuiz = await prisma.courseQuiz.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseQuizCreateManyArgs>(
      args?: SelectSubset<T, CourseQuizCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CourseQuiz.
     * @param {CourseQuizDeleteArgs} args - Arguments to delete one CourseQuiz.
     * @example
     * // Delete one CourseQuiz
     * const CourseQuiz = await prisma.courseQuiz.delete({
     *   where: {
     *     // ... filter to delete one CourseQuiz
     *   }
     * })
     * 
    **/
    delete<T extends CourseQuizDeleteArgs>(
      args: SelectSubset<T, CourseQuizDeleteArgs>
    ): CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>>

    /**
     * Update one CourseQuiz.
     * @param {CourseQuizUpdateArgs} args - Arguments to update one CourseQuiz.
     * @example
     * // Update one CourseQuiz
     * const courseQuiz = await prisma.courseQuiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseQuizUpdateArgs>(
      args: SelectSubset<T, CourseQuizUpdateArgs>
    ): CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>>

    /**
     * Delete zero or more CourseQuizs.
     * @param {CourseQuizDeleteManyArgs} args - Arguments to filter CourseQuizs to delete.
     * @example
     * // Delete a few CourseQuizs
     * const { count } = await prisma.courseQuiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseQuizDeleteManyArgs>(
      args?: SelectSubset<T, CourseQuizDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseQuizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseQuizs
     * const courseQuiz = await prisma.courseQuiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseQuizUpdateManyArgs>(
      args: SelectSubset<T, CourseQuizUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseQuiz.
     * @param {CourseQuizUpsertArgs} args - Arguments to update or create a CourseQuiz.
     * @example
     * // Update or create a CourseQuiz
     * const courseQuiz = await prisma.courseQuiz.upsert({
     *   create: {
     *     // ... data to create a CourseQuiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseQuiz we want to update
     *   }
     * })
    **/
    upsert<T extends CourseQuizUpsertArgs>(
      args: SelectSubset<T, CourseQuizUpsertArgs>
    ): CheckSelect<T, Prisma__CourseQuizClient<CourseQuiz>, Prisma__CourseQuizClient<CourseQuizGetPayload<T>>>

    /**
     * Find zero or more CourseQuizs that matches the filter.
     * @param {CourseQuizFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const courseQuiz = await prisma.courseQuiz.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CourseQuizFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CourseQuiz.
     * @param {CourseQuizAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const courseQuiz = await prisma.courseQuiz.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CourseQuizAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of CourseQuizs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizCountArgs} args - Arguments to filter CourseQuizs to count.
     * @example
     * // Count the number of CourseQuizs
     * const count = await prisma.courseQuiz.count({
     *   where: {
     *     // ... the filter for the CourseQuizs we want to count
     *   }
     * })
    **/
    count<T extends CourseQuizCountArgs>(
      args?: Subset<T, CourseQuizCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseQuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseQuiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseQuizAggregateArgs>(args: Subset<T, CourseQuizAggregateArgs>): PrismaPromise<GetCourseQuizAggregateType<T>>

    /**
     * Group by CourseQuiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseQuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseQuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseQuizGroupByArgs['orderBy'] }
        : { orderBy?: CourseQuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseQuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseQuizGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseQuiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseQuizClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    courseBatches<T extends CourseBatchesArgs = {}>(args?: Subset<T, CourseBatchesArgs>): CheckSelect<T, Prisma__CourseBatchesClient<CourseBatches | null >, Prisma__CourseBatchesClient<CourseBatchesGetPayload<T> | null >>;

    courses<T extends CoursesArgs = {}>(args?: Subset<T, CoursesArgs>): CheckSelect<T, Prisma__CoursesClient<Courses | null >, Prisma__CoursesClient<CoursesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CourseQuiz findUnique
   */
  export type CourseQuizFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * Throw an Error if a CourseQuiz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseQuiz to fetch.
     * 
    **/
    where: CourseQuizWhereUniqueInput
  }


  /**
   * CourseQuiz findFirst
   */
  export type CourseQuizFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * Throw an Error if a CourseQuiz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CourseQuiz to fetch.
     * 
    **/
    where?: CourseQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseQuizs to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseQuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseQuizs.
     * 
    **/
    cursor?: CourseQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseQuizs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseQuizs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseQuizs.
     * 
    **/
    distinct?: Enumerable<CourseQuizScalarFieldEnum>
  }


  /**
   * CourseQuiz findMany
   */
  export type CourseQuizFindManyArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * Filter, which CourseQuizs to fetch.
     * 
    **/
    where?: CourseQuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseQuizs to fetch.
     * 
    **/
    orderBy?: Enumerable<CourseQuizOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseQuizs.
     * 
    **/
    cursor?: CourseQuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseQuizs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseQuizs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CourseQuizScalarFieldEnum>
  }


  /**
   * CourseQuiz create
   */
  export type CourseQuizCreateArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * The data needed to create a CourseQuiz.
     * 
    **/
    data: XOR<CourseQuizCreateInput, CourseQuizUncheckedCreateInput>
  }


  /**
   * CourseQuiz createMany
   */
  export type CourseQuizCreateManyArgs = {
    /**
     * The data used to create many CourseQuizs.
     * 
    **/
    data: Enumerable<CourseQuizCreateManyInput>
  }


  /**
   * CourseQuiz update
   */
  export type CourseQuizUpdateArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * The data needed to update a CourseQuiz.
     * 
    **/
    data: XOR<CourseQuizUpdateInput, CourseQuizUncheckedUpdateInput>
    /**
     * Choose, which CourseQuiz to update.
     * 
    **/
    where: CourseQuizWhereUniqueInput
  }


  /**
   * CourseQuiz updateMany
   */
  export type CourseQuizUpdateManyArgs = {
    /**
     * The data used to update CourseQuizs.
     * 
    **/
    data: XOR<CourseQuizUpdateManyMutationInput, CourseQuizUncheckedUpdateManyInput>
    /**
     * Filter which CourseQuizs to update
     * 
    **/
    where?: CourseQuizWhereInput
  }


  /**
   * CourseQuiz upsert
   */
  export type CourseQuizUpsertArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * The filter to search for the CourseQuiz to update in case it exists.
     * 
    **/
    where: CourseQuizWhereUniqueInput
    /**
     * In case the CourseQuiz found by the `where` argument doesn't exist, create a new CourseQuiz with this data.
     * 
    **/
    create: XOR<CourseQuizCreateInput, CourseQuizUncheckedCreateInput>
    /**
     * In case the CourseQuiz was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CourseQuizUpdateInput, CourseQuizUncheckedUpdateInput>
  }


  /**
   * CourseQuiz delete
   */
  export type CourseQuizDeleteArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
    /**
     * Filter which CourseQuiz to delete.
     * 
    **/
    where: CourseQuizWhereUniqueInput
  }


  /**
   * CourseQuiz deleteMany
   */
  export type CourseQuizDeleteManyArgs = {
    /**
     * Filter which CourseQuizs to delete
     * 
    **/
    where?: CourseQuizWhereInput
  }


  /**
   * CourseQuiz findRaw
   */
  export type CourseQuizFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseQuiz aggregateRaw
   */
  export type CourseQuizAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * CourseQuiz without action
   */
  export type CourseQuizArgs = {
    /**
     * Select specific fields to fetch from the CourseQuiz
     * 
    **/
    select?: CourseQuizSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CourseQuizInclude | null
  }



  /**
   * Model Speaker
   */


  export type AggregateSpeaker = {
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  export type SpeakerMinAggregateOutputType = {
    id: string | null
    speakerName: string | null
    spkearDesc: string | null
    spekaerImage: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type SpeakerMaxAggregateOutputType = {
    id: string | null
    speakerName: string | null
    spkearDesc: string | null
    spekaerImage: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type SpeakerCountAggregateOutputType = {
    id: number
    speakerName: number
    spkearDesc: number
    spekaerImage: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type SpeakerMinAggregateInputType = {
    id?: true
    speakerName?: true
    spkearDesc?: true
    spekaerImage?: true
    createdAt?: true
    updateAt?: true
  }

  export type SpeakerMaxAggregateInputType = {
    id?: true
    speakerName?: true
    spkearDesc?: true
    spekaerImage?: true
    createdAt?: true
    updateAt?: true
  }

  export type SpeakerCountAggregateInputType = {
    id?: true
    speakerName?: true
    spkearDesc?: true
    spekaerImage?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type SpeakerAggregateArgs = {
    /**
     * Filter which Speaker to aggregate.
     * 
    **/
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeakerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speakers
    **/
    _count?: true | SpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerMaxAggregateInputType
  }

  export type GetSpeakerAggregateType<T extends SpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeaker[P]>
      : GetScalarType<T[P], AggregateSpeaker[P]>
  }




  export type SpeakerGroupByArgs = {
    where?: SpeakerWhereInput
    orderBy?: Enumerable<SpeakerOrderByWithAggregationInput>
    by: Array<SpeakerScalarFieldEnum>
    having?: SpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerCountAggregateInputType | true
    _min?: SpeakerMinAggregateInputType
    _max?: SpeakerMaxAggregateInputType
  }


  export type SpeakerGroupByOutputType = {
    id: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    createdAt: Date
    updateAt: Date
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  type GetSpeakerGroupByPayload<T extends SpeakerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerSelect = {
    id?: boolean
    speakerName?: boolean
    spkearDesc?: boolean
    spekaerImage?: boolean
    events?: boolean | EventsFindManyArgs
    createdAt?: boolean
    updateAt?: boolean
    _count?: boolean | SpeakerCountOutputTypeArgs
  }

  export type SpeakerInclude = {
    events?: boolean | EventsFindManyArgs
    _count?: boolean | SpeakerCountOutputTypeArgs
  }

  export type SpeakerGetPayload<
    S extends boolean | null | undefined | SpeakerArgs,
    U = keyof S
      > = S extends true
        ? Speaker
    : S extends undefined
    ? never
    : S extends SpeakerArgs | SpeakerFindManyArgs
    ?'include' extends U
    ? Speaker  & {
    [P in TrueKeys<S['include']>]:
        P extends 'events' ? Array < EventsGetPayload<S['include'][P]>>  :
        P extends '_count' ? SpeakerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'events' ? Array < EventsGetPayload<S['select'][P]>>  :
        P extends '_count' ? SpeakerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Speaker ? Speaker[P] : never
  } 
    : Speaker
  : Speaker


  type SpeakerCountArgs = Merge<
    Omit<SpeakerFindManyArgs, 'select' | 'include'> & {
      select?: SpeakerCountAggregateInputType | true
    }
  >

  export interface SpeakerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Speaker that matches the filter.
     * @param {SpeakerFindUniqueArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpeakerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpeakerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Speaker'> extends True ? CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>> : CheckSelect<T, Prisma__SpeakerClient<Speaker | null >, Prisma__SpeakerClient<SpeakerGetPayload<T> | null >>

    /**
     * Find the first Speaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpeakerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpeakerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Speaker'> extends True ? CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>> : CheckSelect<T, Prisma__SpeakerClient<Speaker | null >, Prisma__SpeakerClient<SpeakerGetPayload<T> | null >>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speaker.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakerWithIdOnly = await prisma.speaker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpeakerFindManyArgs>(
      args?: SelectSubset<T, SpeakerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Speaker>>, PrismaPromise<Array<SpeakerGetPayload<T>>>>

    /**
     * Create a Speaker.
     * @param {SpeakerCreateArgs} args - Arguments to create a Speaker.
     * @example
     * // Create one Speaker
     * const Speaker = await prisma.speaker.create({
     *   data: {
     *     // ... data to create a Speaker
     *   }
     * })
     * 
    **/
    create<T extends SpeakerCreateArgs>(
      args: SelectSubset<T, SpeakerCreateArgs>
    ): CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>>

    /**
     * Create many Speakers.
     *     @param {SpeakerCreateManyArgs} args - Arguments to create many Speakers.
     *     @example
     *     // Create many Speakers
     *     const speaker = await prisma.speaker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpeakerCreateManyArgs>(
      args?: SelectSubset<T, SpeakerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Speaker.
     * @param {SpeakerDeleteArgs} args - Arguments to delete one Speaker.
     * @example
     * // Delete one Speaker
     * const Speaker = await prisma.speaker.delete({
     *   where: {
     *     // ... filter to delete one Speaker
     *   }
     * })
     * 
    **/
    delete<T extends SpeakerDeleteArgs>(
      args: SelectSubset<T, SpeakerDeleteArgs>
    ): CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>>

    /**
     * Update one Speaker.
     * @param {SpeakerUpdateArgs} args - Arguments to update one Speaker.
     * @example
     * // Update one Speaker
     * const speaker = await prisma.speaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpeakerUpdateArgs>(
      args: SelectSubset<T, SpeakerUpdateArgs>
    ): CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>>

    /**
     * Delete zero or more Speakers.
     * @param {SpeakerDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpeakerDeleteManyArgs>(
      args?: SelectSubset<T, SpeakerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpeakerUpdateManyArgs>(
      args: SelectSubset<T, SpeakerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Speaker.
     * @param {SpeakerUpsertArgs} args - Arguments to update or create a Speaker.
     * @example
     * // Update or create a Speaker
     * const speaker = await prisma.speaker.upsert({
     *   create: {
     *     // ... data to create a Speaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speaker we want to update
     *   }
     * })
    **/
    upsert<T extends SpeakerUpsertArgs>(
      args: SelectSubset<T, SpeakerUpsertArgs>
    ): CheckSelect<T, Prisma__SpeakerClient<Speaker>, Prisma__SpeakerClient<SpeakerGetPayload<T>>>

    /**
     * Find zero or more Speakers that matches the filter.
     * @param {SpeakerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speaker = await prisma.speaker.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SpeakerFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Speaker.
     * @param {SpeakerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speaker = await prisma.speaker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SpeakerAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speaker.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends SpeakerCountArgs>(
      args?: Subset<T, SpeakerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerAggregateArgs>(args: Subset<T, SpeakerAggregateArgs>): PrismaPromise<GetSpeakerAggregateType<T>>

    /**
     * Group by Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpeakerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    events<T extends EventsFindManyArgs = {}>(args?: Subset<T, EventsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Events>>, PrismaPromise<Array<EventsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Speaker findUnique
   */
  export type SpeakerFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * Throw an Error if a Speaker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Speaker to fetch.
     * 
    **/
    where: SpeakerWhereUniqueInput
  }


  /**
   * Speaker findFirst
   */
  export type SpeakerFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * Throw an Error if a Speaker can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Speaker to fetch.
     * 
    **/
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeakerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     * 
    **/
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     * 
    **/
    distinct?: Enumerable<SpeakerScalarFieldEnum>
  }


  /**
   * Speaker findMany
   */
  export type SpeakerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * Filter, which Speakers to fetch.
     * 
    **/
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeakerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speakers.
     * 
    **/
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SpeakerScalarFieldEnum>
  }


  /**
   * Speaker create
   */
  export type SpeakerCreateArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * The data needed to create a Speaker.
     * 
    **/
    data: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
  }


  /**
   * Speaker createMany
   */
  export type SpeakerCreateManyArgs = {
    /**
     * The data used to create many Speakers.
     * 
    **/
    data: Enumerable<SpeakerCreateManyInput>
  }


  /**
   * Speaker update
   */
  export type SpeakerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * The data needed to update a Speaker.
     * 
    **/
    data: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
    /**
     * Choose, which Speaker to update.
     * 
    **/
    where: SpeakerWhereUniqueInput
  }


  /**
   * Speaker updateMany
   */
  export type SpeakerUpdateManyArgs = {
    /**
     * The data used to update Speakers.
     * 
    **/
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     * 
    **/
    where?: SpeakerWhereInput
  }


  /**
   * Speaker upsert
   */
  export type SpeakerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * The filter to search for the Speaker to update in case it exists.
     * 
    **/
    where: SpeakerWhereUniqueInput
    /**
     * In case the Speaker found by the `where` argument doesn't exist, create a new Speaker with this data.
     * 
    **/
    create: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
    /**
     * In case the Speaker was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
  }


  /**
   * Speaker delete
   */
  export type SpeakerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
    /**
     * Filter which Speaker to delete.
     * 
    **/
    where: SpeakerWhereUniqueInput
  }


  /**
   * Speaker deleteMany
   */
  export type SpeakerDeleteManyArgs = {
    /**
     * Filter which Speakers to delete
     * 
    **/
    where?: SpeakerWhereInput
  }


  /**
   * Speaker findRaw
   */
  export type SpeakerFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Speaker aggregateRaw
   */
  export type SpeakerAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Speaker without action
   */
  export type SpeakerArgs = {
    /**
     * Select specific fields to fetch from the Speaker
     * 
    **/
    select?: SpeakerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeakerInclude | null
  }



  /**
   * Model Events
   */


  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsMinAggregateOutputType = {
    id: string | null
    eventName: string | null
    eventDesc: string | null
    eventImage: string | null
    eventDate: Date | null
    speakerId: string | null
  }

  export type EventsMaxAggregateOutputType = {
    id: string | null
    eventName: string | null
    eventDesc: string | null
    eventImage: string | null
    eventDate: Date | null
    speakerId: string | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    eventName: number
    eventDesc: number
    eventImage: number
    eventDate: number
    speakerId: number
    _all: number
  }


  export type EventsMinAggregateInputType = {
    id?: true
    eventName?: true
    eventDesc?: true
    eventImage?: true
    eventDate?: true
    speakerId?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    eventName?: true
    eventDesc?: true
    eventImage?: true
    eventDate?: true
    speakerId?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    eventName?: true
    eventDesc?: true
    eventImage?: true
    eventDate?: true
    speakerId?: true
    _all?: true
  }

  export type EventsAggregateArgs = {
    /**
     * Filter which Events to aggregate.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type EventsGroupByArgs = {
    where?: EventsWhereInput
    orderBy?: Enumerable<EventsOrderByWithAggregationInput>
    by: Array<EventsScalarFieldEnum>
    having?: EventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }


  export type EventsGroupByOutputType = {
    id: string
    eventName: string
    eventDesc: string
    eventImage: string | null
    eventDate: Date
    speakerId: string
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends EventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type EventsSelect = {
    id?: boolean
    eventName?: boolean
    eventDesc?: boolean
    eventImage?: boolean
    eventDate?: boolean
    Speaker?: boolean | SpeakerArgs
    speakerId?: boolean
  }

  export type EventsInclude = {
    Speaker?: boolean | SpeakerArgs
  }

  export type EventsGetPayload<
    S extends boolean | null | undefined | EventsArgs,
    U = keyof S
      > = S extends true
        ? Events
    : S extends undefined
    ? never
    : S extends EventsArgs | EventsFindManyArgs
    ?'include' extends U
    ? Events  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Speaker' ? SpeakerGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Speaker' ? SpeakerGetPayload<S['select'][P]> :  P extends keyof Events ? Events[P] : never
  } 
    : Events
  : Events


  type EventsCountArgs = Merge<
    Omit<EventsFindManyArgs, 'select' | 'include'> & {
      select?: EventsCountAggregateInputType | true
    }
  >

  export interface EventsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Events that matches the filter.
     * @param {EventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Events'> extends True ? CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>> : CheckSelect<T, Prisma__EventsClient<Events | null >, Prisma__EventsClient<EventsGetPayload<T> | null >>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Events'> extends True ? CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>> : CheckSelect<T, Prisma__EventsClient<Events | null >, Prisma__EventsClient<EventsGetPayload<T> | null >>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventsFindManyArgs>(
      args?: SelectSubset<T, EventsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Events>>, PrismaPromise<Array<EventsGetPayload<T>>>>

    /**
     * Create a Events.
     * @param {EventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
    **/
    create<T extends EventsCreateArgs>(
      args: SelectSubset<T, EventsCreateArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventsCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const events = await prisma.events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventsCreateManyArgs>(
      args?: SelectSubset<T, EventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {EventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
    **/
    delete<T extends EventsDeleteArgs>(
      args: SelectSubset<T, EventsDeleteArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Update one Events.
     * @param {EventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventsUpdateArgs>(
      args: SelectSubset<T, EventsUpdateArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventsDeleteManyArgs>(
      args?: SelectSubset<T, EventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventsUpdateManyArgs>(
      args: SelectSubset<T, EventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {EventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
    **/
    upsert<T extends EventsUpsertArgs>(
      args: SelectSubset<T, EventsUpsertArgs>
    ): CheckSelect<T, Prisma__EventsClient<Events>, Prisma__EventsClient<EventsGetPayload<T>>>

    /**
     * Find zero or more Events that matches the filter.
     * @param {EventsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const events = await prisma.events.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EventsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Events.
     * @param {EventsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const events = await prisma.events.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EventsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventsCountArgs>(
      args?: Subset<T, EventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventsGroupByArgs['orderBy'] }
        : { orderBy?: EventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Speaker<T extends SpeakerArgs = {}>(args?: Subset<T, SpeakerArgs>): CheckSelect<T, Prisma__SpeakerClient<Speaker | null >, Prisma__SpeakerClient<SpeakerGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Events findUnique
   */
  export type EventsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * Throw an Error if a Events can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where: EventsWhereUniqueInput
  }


  /**
   * Events findFirst
   */
  export type EventsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * Throw an Error if a Events can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     * 
    **/
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * Events findMany
   */
  export type EventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     * 
    **/
    cursor?: EventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventsScalarFieldEnum>
  }


  /**
   * Events create
   */
  export type EventsCreateArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * The data needed to create a Events.
     * 
    **/
    data: XOR<EventsCreateInput, EventsUncheckedCreateInput>
  }


  /**
   * Events createMany
   */
  export type EventsCreateManyArgs = {
    /**
     * The data used to create many Events.
     * 
    **/
    data: Enumerable<EventsCreateManyInput>
  }


  /**
   * Events update
   */
  export type EventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * The data needed to update a Events.
     * 
    **/
    data: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
    /**
     * Choose, which Events to update.
     * 
    **/
    where: EventsWhereUniqueInput
  }


  /**
   * Events updateMany
   */
  export type EventsUpdateManyArgs = {
    /**
     * The data used to update Events.
     * 
    **/
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     * 
    **/
    where?: EventsWhereInput
  }


  /**
   * Events upsert
   */
  export type EventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * The filter to search for the Events to update in case it exists.
     * 
    **/
    where: EventsWhereUniqueInput
    /**
     * In case the Events found by the `where` argument doesn't exist, create a new Events with this data.
     * 
    **/
    create: XOR<EventsCreateInput, EventsUncheckedCreateInput>
    /**
     * In case the Events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EventsUpdateInput, EventsUncheckedUpdateInput>
  }


  /**
   * Events delete
   */
  export type EventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
    /**
     * Filter which Events to delete.
     * 
    **/
    where: EventsWhereUniqueInput
  }


  /**
   * Events deleteMany
   */
  export type EventsDeleteManyArgs = {
    /**
     * Filter which Events to delete
     * 
    **/
    where?: EventsWhereInput
  }


  /**
   * Events findRaw
   */
  export type EventsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Events aggregateRaw
   */
  export type EventsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Events without action
   */
  export type EventsArgs = {
    /**
     * Select specific fields to fetch from the Events
     * 
    **/
    select?: EventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventsInclude | null
  }



  /**
   * Model Faq
   */


  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqMinAggregateOutputType = {
    id: string | null
    faqQuestion: string | null
    faqAnswer: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FaqMaxAggregateOutputType = {
    id: string | null
    faqQuestion: string | null
    faqAnswer: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    faqQuestion: number
    faqAnswer: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type FaqMinAggregateInputType = {
    id?: true
    faqQuestion?: true
    faqAnswer?: true
    createdAt?: true
    updateAt?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    faqQuestion?: true
    faqAnswer?: true
    createdAt?: true
    updateAt?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    faqQuestion?: true
    faqAnswer?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type FaqAggregateArgs = {
    /**
     * Filter which Faq to aggregate.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type FaqGroupByArgs = {
    where?: FaqWhereInput
    orderBy?: Enumerable<FaqOrderByWithAggregationInput>
    by: Array<FaqScalarFieldEnum>
    having?: FaqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }


  export type FaqGroupByOutputType = {
    id: string
    faqQuestion: string
    faqAnswer: string
    createdAt: Date
    updateAt: Date
    _count: FaqCountAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type FaqSelect = {
    id?: boolean
    faqQuestion?: boolean
    faqAnswer?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type FaqGetPayload<
    S extends boolean | null | undefined | FaqArgs,
    U = keyof S
      > = S extends true
        ? Faq
    : S extends undefined
    ? never
    : S extends FaqArgs | FaqFindManyArgs
    ?'include' extends U
    ? Faq 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Faq ? Faq[P] : never
  } 
    : Faq
  : Faq


  type FaqCountArgs = Merge<
    Omit<FaqFindManyArgs, 'select' | 'include'> & {
      select?: FaqCountAggregateInputType | true
    }
  >

  export interface FaqDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Faq that matches the filter.
     * @param {FaqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FaqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FaqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null >, Prisma__FaqClient<FaqGetPayload<T> | null >>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FaqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FaqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Faq'> extends True ? CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>> : CheckSelect<T, Prisma__FaqClient<Faq | null >, Prisma__FaqClient<FaqGetPayload<T> | null >>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FaqFindManyArgs>(
      args?: SelectSubset<T, FaqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Faq>>, PrismaPromise<Array<FaqGetPayload<T>>>>

    /**
     * Create a Faq.
     * @param {FaqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
    **/
    create<T extends FaqCreateArgs>(
      args: SelectSubset<T, FaqCreateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Create many Faqs.
     *     @param {FaqCreateManyArgs} args - Arguments to create many Faqs.
     *     @example
     *     // Create many Faqs
     *     const faq = await prisma.faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FaqCreateManyArgs>(
      args?: SelectSubset<T, FaqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {FaqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
    **/
    delete<T extends FaqDeleteArgs>(
      args: SelectSubset<T, FaqDeleteArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Update one Faq.
     * @param {FaqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FaqUpdateArgs>(
      args: SelectSubset<T, FaqUpdateArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Delete zero or more Faqs.
     * @param {FaqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FaqDeleteManyArgs>(
      args?: SelectSubset<T, FaqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FaqUpdateManyArgs>(
      args: SelectSubset<T, FaqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {FaqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
    **/
    upsert<T extends FaqUpsertArgs>(
      args: SelectSubset<T, FaqUpsertArgs>
    ): CheckSelect<T, Prisma__FaqClient<Faq>, Prisma__FaqClient<FaqGetPayload<T>>>

    /**
     * Find zero or more Faqs that matches the filter.
     * @param {FaqFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const faq = await prisma.faq.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FaqFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Faq.
     * @param {FaqAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const faq = await prisma.faq.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FaqAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqCountArgs>(
      args?: Subset<T, FaqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FaqClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Faq findUnique
   */
  export type FaqFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Throw an Error if a Faq can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq findFirst
   */
  export type FaqFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Throw an Error if a Faq can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Faq to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     * 
    **/
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * Faq findMany
   */
  export type FaqFindManyArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter, which Faqs to fetch.
     * 
    **/
    where?: FaqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<FaqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     * 
    **/
    cursor?: FaqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * Faq create
   */
  export type FaqCreateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to create a Faq.
     * 
    **/
    data: XOR<FaqCreateInput, FaqUncheckedCreateInput>
  }


  /**
   * Faq createMany
   */
  export type FaqCreateManyArgs = {
    /**
     * The data used to create many Faqs.
     * 
    **/
    data: Enumerable<FaqCreateManyInput>
  }


  /**
   * Faq update
   */
  export type FaqUpdateArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The data needed to update a Faq.
     * 
    **/
    data: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
    /**
     * Choose, which Faq to update.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq updateMany
   */
  export type FaqUpdateManyArgs = {
    /**
     * The data used to update Faqs.
     * 
    **/
    data: XOR<FaqUpdateManyMutationInput, FaqUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     * 
    **/
    where?: FaqWhereInput
  }


  /**
   * Faq upsert
   */
  export type FaqUpsertArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * The filter to search for the Faq to update in case it exists.
     * 
    **/
    where: FaqWhereUniqueInput
    /**
     * In case the Faq found by the `where` argument doesn't exist, create a new Faq with this data.
     * 
    **/
    create: XOR<FaqCreateInput, FaqUncheckedCreateInput>
    /**
     * In case the Faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FaqUpdateInput, FaqUncheckedUpdateInput>
  }


  /**
   * Faq delete
   */
  export type FaqDeleteArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
    /**
     * Filter which Faq to delete.
     * 
    **/
    where: FaqWhereUniqueInput
  }


  /**
   * Faq deleteMany
   */
  export type FaqDeleteManyArgs = {
    /**
     * Filter which Faqs to delete
     * 
    **/
    where?: FaqWhereInput
  }


  /**
   * Faq findRaw
   */
  export type FaqFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Faq aggregateRaw
   */
  export type FaqAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Faq without action
   */
  export type FaqArgs = {
    /**
     * Select specific fields to fetch from the Faq
     * 
    **/
    select?: FaqSelect | null
  }



  /**
   * Model SuccessStories
   */


  export type AggregateSuccessStories = {
    _count: SuccessStoriesCountAggregateOutputType | null
    _min: SuccessStoriesMinAggregateOutputType | null
    _max: SuccessStoriesMaxAggregateOutputType | null
  }

  export type SuccessStoriesMinAggregateOutputType = {
    id: string | null
    freelancingProfileUrl: string | null
    paymentProof: string | null
    description: string | null
    status: Status | null
    totalEarnedAmount: string | null
    city: string | null
    whyReject: string | null
  }

  export type SuccessStoriesMaxAggregateOutputType = {
    id: string | null
    freelancingProfileUrl: string | null
    paymentProof: string | null
    description: string | null
    status: Status | null
    totalEarnedAmount: string | null
    city: string | null
    whyReject: string | null
  }

  export type SuccessStoriesCountAggregateOutputType = {
    id: number
    freelancingProfileUrl: number
    paymentProof: number
    description: number
    status: number
    totalEarnedAmount: number
    city: number
    whyReject: number
    _all: number
  }


  export type SuccessStoriesMinAggregateInputType = {
    id?: true
    freelancingProfileUrl?: true
    paymentProof?: true
    description?: true
    status?: true
    totalEarnedAmount?: true
    city?: true
    whyReject?: true
  }

  export type SuccessStoriesMaxAggregateInputType = {
    id?: true
    freelancingProfileUrl?: true
    paymentProof?: true
    description?: true
    status?: true
    totalEarnedAmount?: true
    city?: true
    whyReject?: true
  }

  export type SuccessStoriesCountAggregateInputType = {
    id?: true
    freelancingProfileUrl?: true
    paymentProof?: true
    description?: true
    status?: true
    totalEarnedAmount?: true
    city?: true
    whyReject?: true
    _all?: true
  }

  export type SuccessStoriesAggregateArgs = {
    /**
     * Filter which SuccessStories to aggregate.
     * 
    **/
    where?: SuccessStoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     * 
    **/
    orderBy?: Enumerable<SuccessStoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SuccessStoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuccessStories
    **/
    _count?: true | SuccessStoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuccessStoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuccessStoriesMaxAggregateInputType
  }

  export type GetSuccessStoriesAggregateType<T extends SuccessStoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSuccessStories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuccessStories[P]>
      : GetScalarType<T[P], AggregateSuccessStories[P]>
  }




  export type SuccessStoriesGroupByArgs = {
    where?: SuccessStoriesWhereInput
    orderBy?: Enumerable<SuccessStoriesOrderByWithAggregationInput>
    by: Array<SuccessStoriesScalarFieldEnum>
    having?: SuccessStoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuccessStoriesCountAggregateInputType | true
    _min?: SuccessStoriesMinAggregateInputType
    _max?: SuccessStoriesMaxAggregateInputType
  }


  export type SuccessStoriesGroupByOutputType = {
    id: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status: Status
    totalEarnedAmount: string
    city: string
    whyReject: string
    _count: SuccessStoriesCountAggregateOutputType | null
    _min: SuccessStoriesMinAggregateOutputType | null
    _max: SuccessStoriesMaxAggregateOutputType | null
  }

  type GetSuccessStoriesGroupByPayload<T extends SuccessStoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SuccessStoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuccessStoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuccessStoriesGroupByOutputType[P]>
            : GetScalarType<T[P], SuccessStoriesGroupByOutputType[P]>
        }
      >
    >


  export type SuccessStoriesSelect = {
    id?: boolean
    freelancingProfileUrl?: boolean
    paymentProof?: boolean
    description?: boolean
    status?: boolean
    totalEarnedAmount?: boolean
    city?: boolean
    whyReject?: boolean
    user?: boolean | UserFindManyArgs
    _count?: boolean | SuccessStoriesCountOutputTypeArgs
  }

  export type SuccessStoriesInclude = {
    user?: boolean | UserFindManyArgs
    _count?: boolean | SuccessStoriesCountOutputTypeArgs
  }

  export type SuccessStoriesGetPayload<
    S extends boolean | null | undefined | SuccessStoriesArgs,
    U = keyof S
      > = S extends true
        ? SuccessStories
    : S extends undefined
    ? never
    : S extends SuccessStoriesArgs | SuccessStoriesFindManyArgs
    ?'include' extends U
    ? SuccessStories  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? SuccessStoriesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? SuccessStoriesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SuccessStories ? SuccessStories[P] : never
  } 
    : SuccessStories
  : SuccessStories


  type SuccessStoriesCountArgs = Merge<
    Omit<SuccessStoriesFindManyArgs, 'select' | 'include'> & {
      select?: SuccessStoriesCountAggregateInputType | true
    }
  >

  export interface SuccessStoriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SuccessStories that matches the filter.
     * @param {SuccessStoriesFindUniqueArgs} args - Arguments to find a SuccessStories
     * @example
     * // Get one SuccessStories
     * const successStories = await prisma.successStories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SuccessStoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SuccessStoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SuccessStories'> extends True ? CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>> : CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories | null >, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T> | null >>

    /**
     * Find the first SuccessStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesFindFirstArgs} args - Arguments to find a SuccessStories
     * @example
     * // Get one SuccessStories
     * const successStories = await prisma.successStories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SuccessStoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SuccessStoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SuccessStories'> extends True ? CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>> : CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories | null >, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T> | null >>

    /**
     * Find zero or more SuccessStories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuccessStories
     * const successStories = await prisma.successStories.findMany()
     * 
     * // Get first 10 SuccessStories
     * const successStories = await prisma.successStories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const successStoriesWithIdOnly = await prisma.successStories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SuccessStoriesFindManyArgs>(
      args?: SelectSubset<T, SuccessStoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SuccessStories>>, PrismaPromise<Array<SuccessStoriesGetPayload<T>>>>

    /**
     * Create a SuccessStories.
     * @param {SuccessStoriesCreateArgs} args - Arguments to create a SuccessStories.
     * @example
     * // Create one SuccessStories
     * const SuccessStories = await prisma.successStories.create({
     *   data: {
     *     // ... data to create a SuccessStories
     *   }
     * })
     * 
    **/
    create<T extends SuccessStoriesCreateArgs>(
      args: SelectSubset<T, SuccessStoriesCreateArgs>
    ): CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>>

    /**
     * Create many SuccessStories.
     *     @param {SuccessStoriesCreateManyArgs} args - Arguments to create many SuccessStories.
     *     @example
     *     // Create many SuccessStories
     *     const successStories = await prisma.successStories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SuccessStoriesCreateManyArgs>(
      args?: SelectSubset<T, SuccessStoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SuccessStories.
     * @param {SuccessStoriesDeleteArgs} args - Arguments to delete one SuccessStories.
     * @example
     * // Delete one SuccessStories
     * const SuccessStories = await prisma.successStories.delete({
     *   where: {
     *     // ... filter to delete one SuccessStories
     *   }
     * })
     * 
    **/
    delete<T extends SuccessStoriesDeleteArgs>(
      args: SelectSubset<T, SuccessStoriesDeleteArgs>
    ): CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>>

    /**
     * Update one SuccessStories.
     * @param {SuccessStoriesUpdateArgs} args - Arguments to update one SuccessStories.
     * @example
     * // Update one SuccessStories
     * const successStories = await prisma.successStories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SuccessStoriesUpdateArgs>(
      args: SelectSubset<T, SuccessStoriesUpdateArgs>
    ): CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>>

    /**
     * Delete zero or more SuccessStories.
     * @param {SuccessStoriesDeleteManyArgs} args - Arguments to filter SuccessStories to delete.
     * @example
     * // Delete a few SuccessStories
     * const { count } = await prisma.successStories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SuccessStoriesDeleteManyArgs>(
      args?: SelectSubset<T, SuccessStoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuccessStories
     * const successStories = await prisma.successStories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SuccessStoriesUpdateManyArgs>(
      args: SelectSubset<T, SuccessStoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SuccessStories.
     * @param {SuccessStoriesUpsertArgs} args - Arguments to update or create a SuccessStories.
     * @example
     * // Update or create a SuccessStories
     * const successStories = await prisma.successStories.upsert({
     *   create: {
     *     // ... data to create a SuccessStories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuccessStories we want to update
     *   }
     * })
    **/
    upsert<T extends SuccessStoriesUpsertArgs>(
      args: SelectSubset<T, SuccessStoriesUpsertArgs>
    ): CheckSelect<T, Prisma__SuccessStoriesClient<SuccessStories>, Prisma__SuccessStoriesClient<SuccessStoriesGetPayload<T>>>

    /**
     * Find zero or more SuccessStories that matches the filter.
     * @param {SuccessStoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const successStories = await prisma.successStories.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SuccessStoriesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SuccessStories.
     * @param {SuccessStoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const successStories = await prisma.successStories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SuccessStoriesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesCountArgs} args - Arguments to filter SuccessStories to count.
     * @example
     * // Count the number of SuccessStories
     * const count = await prisma.successStories.count({
     *   where: {
     *     // ... the filter for the SuccessStories we want to count
     *   }
     * })
    **/
    count<T extends SuccessStoriesCountArgs>(
      args?: Subset<T, SuccessStoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuccessStoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuccessStoriesAggregateArgs>(args: Subset<T, SuccessStoriesAggregateArgs>): PrismaPromise<GetSuccessStoriesAggregateType<T>>

    /**
     * Group by SuccessStories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuccessStoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuccessStoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuccessStoriesGroupByArgs['orderBy'] }
        : { orderBy?: SuccessStoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuccessStoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuccessStoriesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuccessStories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SuccessStoriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SuccessStories findUnique
   */
  export type SuccessStoriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * Throw an Error if a SuccessStories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SuccessStories to fetch.
     * 
    **/
    where: SuccessStoriesWhereUniqueInput
  }


  /**
   * SuccessStories findFirst
   */
  export type SuccessStoriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * Throw an Error if a SuccessStories can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SuccessStories to fetch.
     * 
    **/
    where?: SuccessStoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     * 
    **/
    orderBy?: Enumerable<SuccessStoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuccessStories.
     * 
    **/
    cursor?: SuccessStoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuccessStories.
     * 
    **/
    distinct?: Enumerable<SuccessStoriesScalarFieldEnum>
  }


  /**
   * SuccessStories findMany
   */
  export type SuccessStoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * Filter, which SuccessStories to fetch.
     * 
    **/
    where?: SuccessStoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuccessStories to fetch.
     * 
    **/
    orderBy?: Enumerable<SuccessStoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuccessStories.
     * 
    **/
    cursor?: SuccessStoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuccessStories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuccessStories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SuccessStoriesScalarFieldEnum>
  }


  /**
   * SuccessStories create
   */
  export type SuccessStoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * The data needed to create a SuccessStories.
     * 
    **/
    data: XOR<SuccessStoriesCreateInput, SuccessStoriesUncheckedCreateInput>
  }


  /**
   * SuccessStories createMany
   */
  export type SuccessStoriesCreateManyArgs = {
    /**
     * The data used to create many SuccessStories.
     * 
    **/
    data: Enumerable<SuccessStoriesCreateManyInput>
  }


  /**
   * SuccessStories update
   */
  export type SuccessStoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * The data needed to update a SuccessStories.
     * 
    **/
    data: XOR<SuccessStoriesUpdateInput, SuccessStoriesUncheckedUpdateInput>
    /**
     * Choose, which SuccessStories to update.
     * 
    **/
    where: SuccessStoriesWhereUniqueInput
  }


  /**
   * SuccessStories updateMany
   */
  export type SuccessStoriesUpdateManyArgs = {
    /**
     * The data used to update SuccessStories.
     * 
    **/
    data: XOR<SuccessStoriesUpdateManyMutationInput, SuccessStoriesUncheckedUpdateManyInput>
    /**
     * Filter which SuccessStories to update
     * 
    **/
    where?: SuccessStoriesWhereInput
  }


  /**
   * SuccessStories upsert
   */
  export type SuccessStoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * The filter to search for the SuccessStories to update in case it exists.
     * 
    **/
    where: SuccessStoriesWhereUniqueInput
    /**
     * In case the SuccessStories found by the `where` argument doesn't exist, create a new SuccessStories with this data.
     * 
    **/
    create: XOR<SuccessStoriesCreateInput, SuccessStoriesUncheckedCreateInput>
    /**
     * In case the SuccessStories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SuccessStoriesUpdateInput, SuccessStoriesUncheckedUpdateInput>
  }


  /**
   * SuccessStories delete
   */
  export type SuccessStoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
    /**
     * Filter which SuccessStories to delete.
     * 
    **/
    where: SuccessStoriesWhereUniqueInput
  }


  /**
   * SuccessStories deleteMany
   */
  export type SuccessStoriesDeleteManyArgs = {
    /**
     * Filter which SuccessStories to delete
     * 
    **/
    where?: SuccessStoriesWhereInput
  }


  /**
   * SuccessStories findRaw
   */
  export type SuccessStoriesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * SuccessStories aggregateRaw
   */
  export type SuccessStoriesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * SuccessStories without action
   */
  export type SuccessStoriesArgs = {
    /**
     * Select specific fields to fetch from the SuccessStories
     * 
    **/
    select?: SuccessStoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SuccessStoriesInclude | null
  }



  /**
   * Model blogs
   */


  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsMinAggregateOutputType = {
    id: string | null
    blogTitle: string | null
    blogDescription: string | null
    createdAt: Date | null
    updateAt: Date | null
    featuredImage: string | null
    commentType: boolean | null
  }

  export type BlogsMaxAggregateOutputType = {
    id: string | null
    blogTitle: string | null
    blogDescription: string | null
    createdAt: Date | null
    updateAt: Date | null
    featuredImage: string | null
    commentType: boolean | null
  }

  export type BlogsCountAggregateOutputType = {
    id: number
    blogTitle: number
    blogDescription: number
    createdAt: number
    updateAt: number
    featuredImage: number
    commentType: number
    _all: number
  }


  export type BlogsMinAggregateInputType = {
    id?: true
    blogTitle?: true
    blogDescription?: true
    createdAt?: true
    updateAt?: true
    featuredImage?: true
    commentType?: true
  }

  export type BlogsMaxAggregateInputType = {
    id?: true
    blogTitle?: true
    blogDescription?: true
    createdAt?: true
    updateAt?: true
    featuredImage?: true
    commentType?: true
  }

  export type BlogsCountAggregateInputType = {
    id?: true
    blogTitle?: true
    blogDescription?: true
    createdAt?: true
    updateAt?: true
    featuredImage?: true
    commentType?: true
    _all?: true
  }

  export type BlogsAggregateArgs = {
    /**
     * Filter which blogs to aggregate.
     * 
    **/
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type BlogsGroupByArgs = {
    where?: blogsWhereInput
    orderBy?: Enumerable<blogsOrderByWithAggregationInput>
    by: Array<BlogsScalarFieldEnum>
    having?: blogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }


  export type BlogsGroupByOutputType = {
    id: string
    blogTitle: string
    blogDescription: string
    createdAt: Date
    updateAt: Date
    featuredImage: string
    commentType: boolean
    _count: BlogsCountAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends BlogsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type blogsSelect = {
    id?: boolean
    blogTitle?: boolean
    blogDescription?: boolean
    createdAt?: boolean
    updateAt?: boolean
    featuredImage?: boolean
    commentType?: boolean
    comments?: boolean | CommentsFindManyArgs
    _count?: boolean | BlogsCountOutputTypeArgs
  }

  export type blogsInclude = {
    comments?: boolean | CommentsFindManyArgs
    _count?: boolean | BlogsCountOutputTypeArgs
  }

  export type blogsGetPayload<
    S extends boolean | null | undefined | blogsArgs,
    U = keyof S
      > = S extends true
        ? blogs
    : S extends undefined
    ? never
    : S extends blogsArgs | blogsFindManyArgs
    ?'include' extends U
    ? blogs  & {
    [P in TrueKeys<S['include']>]:
        P extends 'comments' ? Array < CommentsGetPayload<S['include'][P]>>  :
        P extends '_count' ? BlogsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'comments' ? Array < CommentsGetPayload<S['select'][P]>>  :
        P extends '_count' ? BlogsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof blogs ? blogs[P] : never
  } 
    : blogs
  : blogs


  type blogsCountArgs = Merge<
    Omit<blogsFindManyArgs, 'select' | 'include'> & {
      select?: BlogsCountAggregateInputType | true
    }
  >

  export interface blogsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Blogs that matches the filter.
     * @param {blogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blogs'> extends True ? CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>> : CheckSelect<T, Prisma__blogsClient<blogs | null >, Prisma__blogsClient<blogsGetPayload<T> | null >>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blogs'> extends True ? CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>> : CheckSelect<T, Prisma__blogsClient<blogs | null >, Prisma__blogsClient<blogsGetPayload<T> | null >>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogsWithIdOnly = await prisma.blogs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends blogsFindManyArgs>(
      args?: SelectSubset<T, blogsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<blogs>>, PrismaPromise<Array<blogsGetPayload<T>>>>

    /**
     * Create a Blogs.
     * @param {blogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
    **/
    create<T extends blogsCreateArgs>(
      args: SelectSubset<T, blogsCreateArgs>
    ): CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>>

    /**
     * Create many Blogs.
     *     @param {blogsCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blogs = await prisma.blogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blogsCreateManyArgs>(
      args?: SelectSubset<T, blogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Blogs.
     * @param {blogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
    **/
    delete<T extends blogsDeleteArgs>(
      args: SelectSubset<T, blogsDeleteArgs>
    ): CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>>

    /**
     * Update one Blogs.
     * @param {blogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blogsUpdateArgs>(
      args: SelectSubset<T, blogsUpdateArgs>
    ): CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>>

    /**
     * Delete zero or more Blogs.
     * @param {blogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blogsDeleteManyArgs>(
      args?: SelectSubset<T, blogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blogsUpdateManyArgs>(
      args: SelectSubset<T, blogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Blogs.
     * @param {blogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
    **/
    upsert<T extends blogsUpsertArgs>(
      args: SelectSubset<T, blogsUpsertArgs>
    ): CheckSelect<T, Prisma__blogsClient<blogs>, Prisma__blogsClient<blogsGetPayload<T>>>

    /**
     * Find zero or more Blogs that matches the filter.
     * @param {blogsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const blogs = await prisma.blogs.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: blogsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Blogs.
     * @param {blogsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const blogs = await prisma.blogs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: blogsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogsCountArgs>(
      args?: Subset<T, blogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogsGroupByArgs['orderBy'] }
        : { orderBy?: BlogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blogsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    comments<T extends CommentsFindManyArgs = {}>(args?: Subset<T, CommentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * blogs findUnique
   */
  export type blogsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * Throw an Error if a blogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which blogs to fetch.
     * 
    **/
    where: blogsWhereUniqueInput
  }


  /**
   * blogs findFirst
   */
  export type blogsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * Throw an Error if a blogs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which blogs to fetch.
     * 
    **/
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     * 
    **/
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     * 
    **/
    distinct?: Enumerable<BlogsScalarFieldEnum>
  }


  /**
   * blogs findMany
   */
  export type blogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * Filter, which blogs to fetch.
     * 
    **/
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<blogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     * 
    **/
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlogsScalarFieldEnum>
  }


  /**
   * blogs create
   */
  export type blogsCreateArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * The data needed to create a blogs.
     * 
    **/
    data: XOR<blogsCreateInput, blogsUncheckedCreateInput>
  }


  /**
   * blogs createMany
   */
  export type blogsCreateManyArgs = {
    /**
     * The data used to create many blogs.
     * 
    **/
    data: Enumerable<blogsCreateManyInput>
  }


  /**
   * blogs update
   */
  export type blogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * The data needed to update a blogs.
     * 
    **/
    data: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
    /**
     * Choose, which blogs to update.
     * 
    **/
    where: blogsWhereUniqueInput
  }


  /**
   * blogs updateMany
   */
  export type blogsUpdateManyArgs = {
    /**
     * The data used to update blogs.
     * 
    **/
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     * 
    **/
    where?: blogsWhereInput
  }


  /**
   * blogs upsert
   */
  export type blogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * The filter to search for the blogs to update in case it exists.
     * 
    **/
    where: blogsWhereUniqueInput
    /**
     * In case the blogs found by the `where` argument doesn't exist, create a new blogs with this data.
     * 
    **/
    create: XOR<blogsCreateInput, blogsUncheckedCreateInput>
    /**
     * In case the blogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
  }


  /**
   * blogs delete
   */
  export type blogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
    /**
     * Filter which blogs to delete.
     * 
    **/
    where: blogsWhereUniqueInput
  }


  /**
   * blogs deleteMany
   */
  export type blogsDeleteManyArgs = {
    /**
     * Filter which blogs to delete
     * 
    **/
    where?: blogsWhereInput
  }


  /**
   * blogs findRaw
   */
  export type blogsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * blogs aggregateRaw
   */
  export type blogsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * blogs without action
   */
  export type blogsArgs = {
    /**
     * Select specific fields to fetch from the blogs
     * 
    **/
    select?: blogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: blogsInclude | null
  }



  /**
   * Model Comments
   */


  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsMinAggregateOutputType = {
    id: string | null
    blogsId: string | null
    createdAt: Date | null
    comment: string | null
    userId: string | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: string | null
    blogsId: string | null
    createdAt: Date | null
    comment: string | null
    userId: string | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    blogsId: number
    createdAt: number
    comment: number
    userId: number
    _all: number
  }


  export type CommentsMinAggregateInputType = {
    id?: true
    blogsId?: true
    createdAt?: true
    comment?: true
    userId?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    blogsId?: true
    createdAt?: true
    comment?: true
    userId?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    blogsId?: true
    createdAt?: true
    comment?: true
    userId?: true
    _all?: true
  }

  export type CommentsAggregateArgs = {
    /**
     * Filter which Comments to aggregate.
     * 
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs = {
    where?: CommentsWhereInput
    orderBy?: Enumerable<CommentsOrderByWithAggregationInput>
    by: Array<CommentsScalarFieldEnum>
    having?: CommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }


  export type CommentsGroupByOutputType = {
    id: string
    blogsId: string
    createdAt: Date
    comment: string
    userId: string | null
    _count: CommentsCountAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type CommentsSelect = {
    id?: boolean
    blogs?: boolean | blogsArgs
    blogsId?: boolean
    createdAt?: boolean
    comment?: boolean
    User?: boolean | UserArgs
    userId?: boolean
  }

  export type CommentsInclude = {
    blogs?: boolean | blogsArgs
    User?: boolean | UserArgs
  }

  export type CommentsGetPayload<
    S extends boolean | null | undefined | CommentsArgs,
    U = keyof S
      > = S extends true
        ? Comments
    : S extends undefined
    ? never
    : S extends CommentsArgs | CommentsFindManyArgs
    ?'include' extends U
    ? Comments  & {
    [P in TrueKeys<S['include']>]:
        P extends 'blogs' ? blogsGetPayload<S['include'][P]> :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'blogs' ? blogsGetPayload<S['select'][P]> :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Comments ? Comments[P] : never
  } 
    : Comments
  : Comments


  type CommentsCountArgs = Merge<
    Omit<CommentsFindManyArgs, 'select' | 'include'> & {
      select?: CommentsCountAggregateInputType | true
    }
  >

  export interface CommentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comments'> extends True ? CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>> : CheckSelect<T, Prisma__CommentsClient<Comments | null >, Prisma__CommentsClient<CommentsGetPayload<T> | null >>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comments'> extends True ? CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>> : CheckSelect<T, Prisma__CommentsClient<Comments | null >, Prisma__CommentsClient<CommentsGetPayload<T> | null >>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentsFindManyArgs>(
      args?: SelectSubset<T, CommentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Comments>>, PrismaPromise<Array<CommentsGetPayload<T>>>>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
    **/
    create<T extends CommentsCreateArgs>(
      args: SelectSubset<T, CommentsCreateArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Create many Comments.
     *     @param {CommentsCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comments = await prisma.comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentsCreateManyArgs>(
      args?: SelectSubset<T, CommentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
    **/
    delete<T extends CommentsDeleteArgs>(
      args: SelectSubset<T, CommentsDeleteArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentsUpdateArgs>(
      args: SelectSubset<T, CommentsUpdateArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentsDeleteManyArgs>(
      args?: SelectSubset<T, CommentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentsUpdateManyArgs>(
      args: SelectSubset<T, CommentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
    **/
    upsert<T extends CommentsUpsertArgs>(
      args: SelectSubset<T, CommentsUpsertArgs>
    ): CheckSelect<T, Prisma__CommentsClient<Comments>, Prisma__CommentsClient<CommentsGetPayload<T>>>

    /**
     * Find zero or more Comments that matches the filter.
     * @param {CommentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comments = await prisma.comments.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CommentsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comments.
     * @param {CommentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comments = await prisma.comments.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CommentsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    blogs<T extends blogsArgs = {}>(args?: Subset<T, blogsArgs>): CheckSelect<T, Prisma__blogsClient<blogs | null >, Prisma__blogsClient<blogsGetPayload<T> | null >>;

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * Throw an Error if a Comments can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comments to fetch.
     * 
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * Throw an Error if a Comments can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comments to fetch.
     * 
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     * 
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     * 
    **/
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * Filter, which Comments to fetch.
     * 
    **/
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     * 
    **/
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommentsScalarFieldEnum>
  }


  /**
   * Comments create
   */
  export type CommentsCreateArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * The data needed to create a Comments.
     * 
    **/
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }


  /**
   * Comments createMany
   */
  export type CommentsCreateManyArgs = {
    /**
     * The data used to create many Comments.
     * 
    **/
    data: Enumerable<CommentsCreateManyInput>
  }


  /**
   * Comments update
   */
  export type CommentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * The data needed to update a Comments.
     * 
    **/
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
     * 
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs = {
    /**
     * The data used to update Comments.
     * 
    **/
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     * 
    **/
    where?: CommentsWhereInput
  }


  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * The filter to search for the Comments to update in case it exists.
     * 
    **/
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
     * 
    **/
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }


  /**
   * Comments delete
   */
  export type CommentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
    /**
     * Filter which Comments to delete.
     * 
    **/
    where: CommentsWhereUniqueInput
  }


  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     * 
    **/
    where?: CommentsWhereInput
  }


  /**
   * Comments findRaw
   */
  export type CommentsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Comments aggregateRaw
   */
  export type CommentsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Comments without action
   */
  export type CommentsArgs = {
    /**
     * Select specific fields to fetch from the Comments
     * 
    **/
    select?: CommentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentsInclude | null
  }



  /**
   * Model ContactUs
   */


  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    message: string | null
    status: ContactUsStatus | null
    reply: string | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    message: string | null
    status: ContactUsStatus | null
    reply: string | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    message: number
    status: number
    reply: number
    _all: number
  }


  export type ContactUsMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    message?: true
    status?: true
    reply?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    message?: true
    status?: true
    reply?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    message?: true
    status?: true
    reply?: true
    _all?: true
  }

  export type ContactUsAggregateArgs = {
    /**
     * Filter which ContactUs to aggregate.
     * 
    **/
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     * 
    **/
    orderBy?: Enumerable<ContactUsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs = {
    where?: ContactUsWhereInput
    orderBy?: Enumerable<ContactUsOrderByWithAggregationInput>
    by: Array<ContactUsScalarFieldEnum>
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }


  export type ContactUsGroupByOutputType = {
    id: string
    name: string
    subject: string
    message: string
    status: ContactUsStatus
    reply: string
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect = {
    id?: boolean
    name?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    reply?: boolean
  }

  export type ContactUsGetPayload<
    S extends boolean | null | undefined | ContactUsArgs,
    U = keyof S
      > = S extends true
        ? ContactUs
    : S extends undefined
    ? never
    : S extends ContactUsArgs | ContactUsFindManyArgs
    ?'include' extends U
    ? ContactUs 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ContactUs ? ContactUs[P] : never
  } 
    : ContactUs
  : ContactUs


  type ContactUsCountArgs = Merge<
    Omit<ContactUsFindManyArgs, 'select' | 'include'> & {
      select?: ContactUsCountAggregateInputType | true
    }
  >

  export interface ContactUsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactUsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContactUsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ContactUs'> extends True ? CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>> : CheckSelect<T, Prisma__ContactUsClient<ContactUs | null >, Prisma__ContactUsClient<ContactUsGetPayload<T> | null >>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactUsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContactUsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ContactUs'> extends True ? CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>> : CheckSelect<T, Prisma__ContactUsClient<ContactUs | null >, Prisma__ContactUsClient<ContactUsGetPayload<T> | null >>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactUsFindManyArgs>(
      args?: SelectSubset<T, ContactUsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ContactUs>>, PrismaPromise<Array<ContactUsGetPayload<T>>>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
    **/
    create<T extends ContactUsCreateArgs>(
      args: SelectSubset<T, ContactUsCreateArgs>
    ): CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>>

    /**
     * Create many Contactuses.
     *     @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     *     @example
     *     // Create many Contactuses
     *     const contactUs = await prisma.contactUs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactUsCreateManyArgs>(
      args?: SelectSubset<T, ContactUsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
    **/
    delete<T extends ContactUsDeleteArgs>(
      args: SelectSubset<T, ContactUsDeleteArgs>
    ): CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUsUpdateArgs>(
      args: SelectSubset<T, ContactUsUpdateArgs>
    ): CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactUsDeleteManyArgs>(
      args?: SelectSubset<T, ContactUsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUsUpdateManyArgs>(
      args: SelectSubset<T, ContactUsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUsUpsertArgs>(
      args: SelectSubset<T, ContactUsUpsertArgs>
    ): CheckSelect<T, Prisma__ContactUsClient<ContactUs>, Prisma__ContactUsClient<ContactUsGetPayload<T>>>

    /**
     * Find zero or more Contactuses that matches the filter.
     * @param {ContactUsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactUs = await prisma.contactUs.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ContactUsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactUs.
     * @param {ContactUsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactUs = await prisma.contactUs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ContactUsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContactUsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * Throw an Error if a ContactUs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ContactUs to fetch.
     * 
    **/
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * Throw an Error if a ContactUs can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ContactUs to fetch.
     * 
    **/
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     * 
    **/
    orderBy?: Enumerable<ContactUsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     * 
    **/
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     * 
    **/
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }


  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * Filter, which Contactuses to fetch.
     * 
    **/
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     * 
    **/
    orderBy?: Enumerable<ContactUsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     * 
    **/
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContactUsScalarFieldEnum>
  }


  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * The data needed to create a ContactUs.
     * 
    **/
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }


  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs = {
    /**
     * The data used to create many Contactuses.
     * 
    **/
    data: Enumerable<ContactUsCreateManyInput>
  }


  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * The data needed to update a ContactUs.
     * 
    **/
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     * 
    **/
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs = {
    /**
     * The data used to update Contactuses.
     * 
    **/
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     * 
    **/
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     * 
    **/
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     * 
    **/
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }


  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
    /**
     * Filter which ContactUs to delete.
     * 
    **/
    where: ContactUsWhereUniqueInput
  }


  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs = {
    /**
     * Filter which Contactuses to delete
     * 
    **/
    where?: ContactUsWhereInput
  }


  /**
   * ContactUs findRaw
   */
  export type ContactUsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * ContactUs aggregateRaw
   */
  export type ContactUsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * ContactUs without action
   */
  export type ContactUsArgs = {
    /**
     * Select specific fields to fetch from the ContactUs
     * 
    **/
    select?: ContactUsSelect | null
  }



  /**
   * Model Attendence
   */


  export type AggregateAttendence = {
    _count: AttendenceCountAggregateOutputType | null
    _min: AttendenceMinAggregateOutputType | null
    _max: AttendenceMaxAggregateOutputType | null
  }

  export type AttendenceMinAggregateOutputType = {
    id: string | null
    attendence: boolean | null
    date: Date | null
    userId: string | null
  }

  export type AttendenceMaxAggregateOutputType = {
    id: string | null
    attendence: boolean | null
    date: Date | null
    userId: string | null
  }

  export type AttendenceCountAggregateOutputType = {
    id: number
    attendence: number
    date: number
    userId: number
    _all: number
  }


  export type AttendenceMinAggregateInputType = {
    id?: true
    attendence?: true
    date?: true
    userId?: true
  }

  export type AttendenceMaxAggregateInputType = {
    id?: true
    attendence?: true
    date?: true
    userId?: true
  }

  export type AttendenceCountAggregateInputType = {
    id?: true
    attendence?: true
    date?: true
    userId?: true
    _all?: true
  }

  export type AttendenceAggregateArgs = {
    /**
     * Filter which Attendence to aggregate.
     * 
    **/
    where?: AttendenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendences to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AttendenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendences
    **/
    _count?: true | AttendenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendenceMaxAggregateInputType
  }

  export type GetAttendenceAggregateType<T extends AttendenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendence[P]>
      : GetScalarType<T[P], AggregateAttendence[P]>
  }




  export type AttendenceGroupByArgs = {
    where?: AttendenceWhereInput
    orderBy?: Enumerable<AttendenceOrderByWithAggregationInput>
    by: Array<AttendenceScalarFieldEnum>
    having?: AttendenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendenceCountAggregateInputType | true
    _min?: AttendenceMinAggregateInputType
    _max?: AttendenceMaxAggregateInputType
  }


  export type AttendenceGroupByOutputType = {
    id: string
    attendence: boolean
    date: Date
    userId: string
    _count: AttendenceCountAggregateOutputType | null
    _min: AttendenceMinAggregateOutputType | null
    _max: AttendenceMaxAggregateOutputType | null
  }

  type GetAttendenceGroupByPayload<T extends AttendenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AttendenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendenceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendenceGroupByOutputType[P]>
        }
      >
    >


  export type AttendenceSelect = {
    id?: boolean
    attendence?: boolean
    date?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type AttendenceInclude = {
    user?: boolean | UserArgs
  }

  export type AttendenceGetPayload<
    S extends boolean | null | undefined | AttendenceArgs,
    U = keyof S
      > = S extends true
        ? Attendence
    : S extends undefined
    ? never
    : S extends AttendenceArgs | AttendenceFindManyArgs
    ?'include' extends U
    ? Attendence  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Attendence ? Attendence[P] : never
  } 
    : Attendence
  : Attendence


  type AttendenceCountArgs = Merge<
    Omit<AttendenceFindManyArgs, 'select' | 'include'> & {
      select?: AttendenceCountAggregateInputType | true
    }
  >

  export interface AttendenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Attendence that matches the filter.
     * @param {AttendenceFindUniqueArgs} args - Arguments to find a Attendence
     * @example
     * // Get one Attendence
     * const attendence = await prisma.attendence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttendenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttendenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Attendence'> extends True ? CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>> : CheckSelect<T, Prisma__AttendenceClient<Attendence | null >, Prisma__AttendenceClient<AttendenceGetPayload<T> | null >>

    /**
     * Find the first Attendence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceFindFirstArgs} args - Arguments to find a Attendence
     * @example
     * // Get one Attendence
     * const attendence = await prisma.attendence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttendenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttendenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Attendence'> extends True ? CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>> : CheckSelect<T, Prisma__AttendenceClient<Attendence | null >, Prisma__AttendenceClient<AttendenceGetPayload<T> | null >>

    /**
     * Find zero or more Attendences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendences
     * const attendences = await prisma.attendence.findMany()
     * 
     * // Get first 10 Attendences
     * const attendences = await prisma.attendence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendenceWithIdOnly = await prisma.attendence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttendenceFindManyArgs>(
      args?: SelectSubset<T, AttendenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Attendence>>, PrismaPromise<Array<AttendenceGetPayload<T>>>>

    /**
     * Create a Attendence.
     * @param {AttendenceCreateArgs} args - Arguments to create a Attendence.
     * @example
     * // Create one Attendence
     * const Attendence = await prisma.attendence.create({
     *   data: {
     *     // ... data to create a Attendence
     *   }
     * })
     * 
    **/
    create<T extends AttendenceCreateArgs>(
      args: SelectSubset<T, AttendenceCreateArgs>
    ): CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>>

    /**
     * Create many Attendences.
     *     @param {AttendenceCreateManyArgs} args - Arguments to create many Attendences.
     *     @example
     *     // Create many Attendences
     *     const attendence = await prisma.attendence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttendenceCreateManyArgs>(
      args?: SelectSubset<T, AttendenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Attendence.
     * @param {AttendenceDeleteArgs} args - Arguments to delete one Attendence.
     * @example
     * // Delete one Attendence
     * const Attendence = await prisma.attendence.delete({
     *   where: {
     *     // ... filter to delete one Attendence
     *   }
     * })
     * 
    **/
    delete<T extends AttendenceDeleteArgs>(
      args: SelectSubset<T, AttendenceDeleteArgs>
    ): CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>>

    /**
     * Update one Attendence.
     * @param {AttendenceUpdateArgs} args - Arguments to update one Attendence.
     * @example
     * // Update one Attendence
     * const attendence = await prisma.attendence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttendenceUpdateArgs>(
      args: SelectSubset<T, AttendenceUpdateArgs>
    ): CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>>

    /**
     * Delete zero or more Attendences.
     * @param {AttendenceDeleteManyArgs} args - Arguments to filter Attendences to delete.
     * @example
     * // Delete a few Attendences
     * const { count } = await prisma.attendence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttendenceDeleteManyArgs>(
      args?: SelectSubset<T, AttendenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendences
     * const attendence = await prisma.attendence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttendenceUpdateManyArgs>(
      args: SelectSubset<T, AttendenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendence.
     * @param {AttendenceUpsertArgs} args - Arguments to update or create a Attendence.
     * @example
     * // Update or create a Attendence
     * const attendence = await prisma.attendence.upsert({
     *   create: {
     *     // ... data to create a Attendence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendence we want to update
     *   }
     * })
    **/
    upsert<T extends AttendenceUpsertArgs>(
      args: SelectSubset<T, AttendenceUpsertArgs>
    ): CheckSelect<T, Prisma__AttendenceClient<Attendence>, Prisma__AttendenceClient<AttendenceGetPayload<T>>>

    /**
     * Find zero or more Attendences that matches the filter.
     * @param {AttendenceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendence = await prisma.attendence.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AttendenceFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendence.
     * @param {AttendenceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendence = await prisma.attendence.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AttendenceAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Attendences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceCountArgs} args - Arguments to filter Attendences to count.
     * @example
     * // Count the number of Attendences
     * const count = await prisma.attendence.count({
     *   where: {
     *     // ... the filter for the Attendences we want to count
     *   }
     * })
    **/
    count<T extends AttendenceCountArgs>(
      args?: Subset<T, AttendenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendenceAggregateArgs>(args: Subset<T, AttendenceAggregateArgs>): PrismaPromise<GetAttendenceAggregateType<T>>

    /**
     * Group by Attendence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendenceGroupByArgs['orderBy'] }
        : { orderBy?: AttendenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendenceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttendenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Attendence findUnique
   */
  export type AttendenceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * Throw an Error if a Attendence can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attendence to fetch.
     * 
    **/
    where: AttendenceWhereUniqueInput
  }


  /**
   * Attendence findFirst
   */
  export type AttendenceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * Throw an Error if a Attendence can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Attendence to fetch.
     * 
    **/
    where?: AttendenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendences to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendences.
     * 
    **/
    cursor?: AttendenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendences.
     * 
    **/
    distinct?: Enumerable<AttendenceScalarFieldEnum>
  }


  /**
   * Attendence findMany
   */
  export type AttendenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * Filter, which Attendences to fetch.
     * 
    **/
    where?: AttendenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendences to fetch.
     * 
    **/
    orderBy?: Enumerable<AttendenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendences.
     * 
    **/
    cursor?: AttendenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AttendenceScalarFieldEnum>
  }


  /**
   * Attendence create
   */
  export type AttendenceCreateArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * The data needed to create a Attendence.
     * 
    **/
    data: XOR<AttendenceCreateInput, AttendenceUncheckedCreateInput>
  }


  /**
   * Attendence createMany
   */
  export type AttendenceCreateManyArgs = {
    /**
     * The data used to create many Attendences.
     * 
    **/
    data: Enumerable<AttendenceCreateManyInput>
  }


  /**
   * Attendence update
   */
  export type AttendenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * The data needed to update a Attendence.
     * 
    **/
    data: XOR<AttendenceUpdateInput, AttendenceUncheckedUpdateInput>
    /**
     * Choose, which Attendence to update.
     * 
    **/
    where: AttendenceWhereUniqueInput
  }


  /**
   * Attendence updateMany
   */
  export type AttendenceUpdateManyArgs = {
    /**
     * The data used to update Attendences.
     * 
    **/
    data: XOR<AttendenceUpdateManyMutationInput, AttendenceUncheckedUpdateManyInput>
    /**
     * Filter which Attendences to update
     * 
    **/
    where?: AttendenceWhereInput
  }


  /**
   * Attendence upsert
   */
  export type AttendenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * The filter to search for the Attendence to update in case it exists.
     * 
    **/
    where: AttendenceWhereUniqueInput
    /**
     * In case the Attendence found by the `where` argument doesn't exist, create a new Attendence with this data.
     * 
    **/
    create: XOR<AttendenceCreateInput, AttendenceUncheckedCreateInput>
    /**
     * In case the Attendence was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AttendenceUpdateInput, AttendenceUncheckedUpdateInput>
  }


  /**
   * Attendence delete
   */
  export type AttendenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
    /**
     * Filter which Attendence to delete.
     * 
    **/
    where: AttendenceWhereUniqueInput
  }


  /**
   * Attendence deleteMany
   */
  export type AttendenceDeleteManyArgs = {
    /**
     * Filter which Attendences to delete
     * 
    **/
    where?: AttendenceWhereInput
  }


  /**
   * Attendence findRaw
   */
  export type AttendenceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Attendence aggregateRaw
   */
  export type AttendenceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Attendence without action
   */
  export type AttendenceArgs = {
    /**
     * Select specific fields to fetch from the Attendence
     * 
    **/
    select?: AttendenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AttendenceInclude | null
  }



  /**
   * Model Fees
   */


  export type AggregateFees = {
    _count: FeesCountAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  export type FeesMinAggregateOutputType = {
    id: string | null
    amountPaid: string | null
    remainingAmount: string | null
    studentId: string | null
    studentName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FeesMaxAggregateOutputType = {
    id: string | null
    amountPaid: string | null
    remainingAmount: string | null
    studentId: string | null
    studentName: string | null
    createdAt: Date | null
    updateAt: Date | null
  }

  export type FeesCountAggregateOutputType = {
    id: number
    amountPaid: number
    remainingAmount: number
    studentId: number
    studentName: number
    createdAt: number
    updateAt: number
    _all: number
  }


  export type FeesMinAggregateInputType = {
    id?: true
    amountPaid?: true
    remainingAmount?: true
    studentId?: true
    studentName?: true
    createdAt?: true
    updateAt?: true
  }

  export type FeesMaxAggregateInputType = {
    id?: true
    amountPaid?: true
    remainingAmount?: true
    studentId?: true
    studentName?: true
    createdAt?: true
    updateAt?: true
  }

  export type FeesCountAggregateInputType = {
    id?: true
    amountPaid?: true
    remainingAmount?: true
    studentId?: true
    studentName?: true
    createdAt?: true
    updateAt?: true
    _all?: true
  }

  export type FeesAggregateArgs = {
    /**
     * Filter which Fees to aggregate.
     * 
    **/
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     * 
    **/
    orderBy?: Enumerable<FeesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeesMaxAggregateInputType
  }

  export type GetFeesAggregateType<T extends FeesAggregateArgs> = {
        [P in keyof T & keyof AggregateFees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFees[P]>
      : GetScalarType<T[P], AggregateFees[P]>
  }




  export type FeesGroupByArgs = {
    where?: FeesWhereInput
    orderBy?: Enumerable<FeesOrderByWithAggregationInput>
    by: Array<FeesScalarFieldEnum>
    having?: FeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeesCountAggregateInputType | true
    _min?: FeesMinAggregateInputType
    _max?: FeesMaxAggregateInputType
  }


  export type FeesGroupByOutputType = {
    id: string
    amountPaid: string
    remainingAmount: string
    studentId: string
    studentName: string
    createdAt: Date
    updateAt: Date
    _count: FeesCountAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  type GetFeesGroupByPayload<T extends FeesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeesGroupByOutputType[P]>
            : GetScalarType<T[P], FeesGroupByOutputType[P]>
        }
      >
    >


  export type FeesSelect = {
    id?: boolean
    amountPaid?: boolean
    remainingAmount?: boolean
    student?: boolean | UserArgs
    studentId?: boolean
    studentName?: boolean
    createdAt?: boolean
    updateAt?: boolean
  }

  export type FeesInclude = {
    student?: boolean | UserArgs
  }

  export type FeesGetPayload<
    S extends boolean | null | undefined | FeesArgs,
    U = keyof S
      > = S extends true
        ? Fees
    : S extends undefined
    ? never
    : S extends FeesArgs | FeesFindManyArgs
    ?'include' extends U
    ? Fees  & {
    [P in TrueKeys<S['include']>]:
        P extends 'student' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'student' ? UserGetPayload<S['select'][P]> :  P extends keyof Fees ? Fees[P] : never
  } 
    : Fees
  : Fees


  type FeesCountArgs = Merge<
    Omit<FeesFindManyArgs, 'select' | 'include'> & {
      select?: FeesCountAggregateInputType | true
    }
  >

  export interface FeesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Fees that matches the filter.
     * @param {FeesFindUniqueArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fees'> extends True ? CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>> : CheckSelect<T, Prisma__FeesClient<Fees | null >, Prisma__FeesClient<FeesGetPayload<T> | null >>

    /**
     * Find the first Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fees'> extends True ? CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>> : CheckSelect<T, Prisma__FeesClient<Fees | null >, Prisma__FeesClient<FeesGetPayload<T> | null >>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fees.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feesWithIdOnly = await prisma.fees.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeesFindManyArgs>(
      args?: SelectSubset<T, FeesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Fees>>, PrismaPromise<Array<FeesGetPayload<T>>>>

    /**
     * Create a Fees.
     * @param {FeesCreateArgs} args - Arguments to create a Fees.
     * @example
     * // Create one Fees
     * const Fees = await prisma.fees.create({
     *   data: {
     *     // ... data to create a Fees
     *   }
     * })
     * 
    **/
    create<T extends FeesCreateArgs>(
      args: SelectSubset<T, FeesCreateArgs>
    ): CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>>

    /**
     * Create many Fees.
     *     @param {FeesCreateManyArgs} args - Arguments to create many Fees.
     *     @example
     *     // Create many Fees
     *     const fees = await prisma.fees.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeesCreateManyArgs>(
      args?: SelectSubset<T, FeesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fees.
     * @param {FeesDeleteArgs} args - Arguments to delete one Fees.
     * @example
     * // Delete one Fees
     * const Fees = await prisma.fees.delete({
     *   where: {
     *     // ... filter to delete one Fees
     *   }
     * })
     * 
    **/
    delete<T extends FeesDeleteArgs>(
      args: SelectSubset<T, FeesDeleteArgs>
    ): CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>>

    /**
     * Update one Fees.
     * @param {FeesUpdateArgs} args - Arguments to update one Fees.
     * @example
     * // Update one Fees
     * const fees = await prisma.fees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeesUpdateArgs>(
      args: SelectSubset<T, FeesUpdateArgs>
    ): CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>>

    /**
     * Delete zero or more Fees.
     * @param {FeesDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeesDeleteManyArgs>(
      args?: SelectSubset<T, FeesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeesUpdateManyArgs>(
      args: SelectSubset<T, FeesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fees.
     * @param {FeesUpsertArgs} args - Arguments to update or create a Fees.
     * @example
     * // Update or create a Fees
     * const fees = await prisma.fees.upsert({
     *   create: {
     *     // ... data to create a Fees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fees we want to update
     *   }
     * })
    **/
    upsert<T extends FeesUpsertArgs>(
      args: SelectSubset<T, FeesUpsertArgs>
    ): CheckSelect<T, Prisma__FeesClient<Fees>, Prisma__FeesClient<FeesGetPayload<T>>>

    /**
     * Find zero or more Fees that matches the filter.
     * @param {FeesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fees = await prisma.fees.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FeesFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Fees.
     * @param {FeesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fees = await prisma.fees.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FeesAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fees.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeesCountArgs>(
      args?: Subset<T, FeesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeesAggregateArgs>(args: Subset<T, FeesAggregateArgs>): PrismaPromise<GetFeesAggregateType<T>>

    /**
     * Group by Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeesGroupByArgs['orderBy'] }
        : { orderBy?: FeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    student<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Fees findUnique
   */
  export type FeesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * Throw an Error if a Fees can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fees to fetch.
     * 
    **/
    where: FeesWhereUniqueInput
  }


  /**
   * Fees findFirst
   */
  export type FeesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * Throw an Error if a Fees can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fees to fetch.
     * 
    **/
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     * 
    **/
    orderBy?: Enumerable<FeesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     * 
    **/
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     * 
    **/
    distinct?: Enumerable<FeesScalarFieldEnum>
  }


  /**
   * Fees findMany
   */
  export type FeesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * Filter, which Fees to fetch.
     * 
    **/
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     * 
    **/
    orderBy?: Enumerable<FeesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     * 
    **/
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeesScalarFieldEnum>
  }


  /**
   * Fees create
   */
  export type FeesCreateArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * The data needed to create a Fees.
     * 
    **/
    data: XOR<FeesCreateInput, FeesUncheckedCreateInput>
  }


  /**
   * Fees createMany
   */
  export type FeesCreateManyArgs = {
    /**
     * The data used to create many Fees.
     * 
    **/
    data: Enumerable<FeesCreateManyInput>
  }


  /**
   * Fees update
   */
  export type FeesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * The data needed to update a Fees.
     * 
    **/
    data: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
    /**
     * Choose, which Fees to update.
     * 
    **/
    where: FeesWhereUniqueInput
  }


  /**
   * Fees updateMany
   */
  export type FeesUpdateManyArgs = {
    /**
     * The data used to update Fees.
     * 
    **/
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     * 
    **/
    where?: FeesWhereInput
  }


  /**
   * Fees upsert
   */
  export type FeesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * The filter to search for the Fees to update in case it exists.
     * 
    **/
    where: FeesWhereUniqueInput
    /**
     * In case the Fees found by the `where` argument doesn't exist, create a new Fees with this data.
     * 
    **/
    create: XOR<FeesCreateInput, FeesUncheckedCreateInput>
    /**
     * In case the Fees was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
  }


  /**
   * Fees delete
   */
  export type FeesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
    /**
     * Filter which Fees to delete.
     * 
    **/
    where: FeesWhereUniqueInput
  }


  /**
   * Fees deleteMany
   */
  export type FeesDeleteManyArgs = {
    /**
     * Filter which Fees to delete
     * 
    **/
    where?: FeesWhereInput
  }


  /**
   * Fees findRaw
   */
  export type FeesFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Fees aggregateRaw
   */
  export type FeesAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Fees without action
   */
  export type FeesArgs = {
    /**
     * Select specific fields to fetch from the Fees
     * 
    **/
    select?: FeesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeesInclude | null
  }



  /**
   * Model EnrollmentApproval
   */


  export type AggregateEnrollmentApproval = {
    _count: EnrollmentApprovalCountAggregateOutputType | null
    _min: EnrollmentApprovalMinAggregateOutputType | null
    _max: EnrollmentApprovalMaxAggregateOutputType | null
  }

  export type EnrollmentApprovalMinAggregateOutputType = {
    id: string | null
    studentName: string | null
    email: string | null
    course: string | null
    paymentMethod: string | null
    amount: string | null
    transactionId: string | null
    status: EnrollStatus | null
  }

  export type EnrollmentApprovalMaxAggregateOutputType = {
    id: string | null
    studentName: string | null
    email: string | null
    course: string | null
    paymentMethod: string | null
    amount: string | null
    transactionId: string | null
    status: EnrollStatus | null
  }

  export type EnrollmentApprovalCountAggregateOutputType = {
    id: number
    studentName: number
    email: number
    course: number
    paymentMethod: number
    amount: number
    transactionId: number
    status: number
    _all: number
  }


  export type EnrollmentApprovalMinAggregateInputType = {
    id?: true
    studentName?: true
    email?: true
    course?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    status?: true
  }

  export type EnrollmentApprovalMaxAggregateInputType = {
    id?: true
    studentName?: true
    email?: true
    course?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    status?: true
  }

  export type EnrollmentApprovalCountAggregateInputType = {
    id?: true
    studentName?: true
    email?: true
    course?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    status?: true
    _all?: true
  }

  export type EnrollmentApprovalAggregateArgs = {
    /**
     * Filter which EnrollmentApproval to aggregate.
     * 
    **/
    where?: EnrollmentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<EnrollmentApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EnrollmentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnrollmentApprovals
    **/
    _count?: true | EnrollmentApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentApprovalMaxAggregateInputType
  }

  export type GetEnrollmentApprovalAggregateType<T extends EnrollmentApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollmentApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollmentApproval[P]>
      : GetScalarType<T[P], AggregateEnrollmentApproval[P]>
  }




  export type EnrollmentApprovalGroupByArgs = {
    where?: EnrollmentApprovalWhereInput
    orderBy?: Enumerable<EnrollmentApprovalOrderByWithAggregationInput>
    by: Array<EnrollmentApprovalScalarFieldEnum>
    having?: EnrollmentApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentApprovalCountAggregateInputType | true
    _min?: EnrollmentApprovalMinAggregateInputType
    _max?: EnrollmentApprovalMaxAggregateInputType
  }


  export type EnrollmentApprovalGroupByOutputType = {
    id: string
    studentName: string
    email: string
    course: string
    paymentMethod: string
    amount: string
    transactionId: string
    status: EnrollStatus
    _count: EnrollmentApprovalCountAggregateOutputType | null
    _min: EnrollmentApprovalMinAggregateOutputType | null
    _max: EnrollmentApprovalMaxAggregateOutputType | null
  }

  type GetEnrollmentApprovalGroupByPayload<T extends EnrollmentApprovalGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EnrollmentApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentApprovalGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentApprovalSelect = {
    id?: boolean
    studentName?: boolean
    email?: boolean
    course?: boolean
    paymentMethod?: boolean
    amount?: boolean
    transactionId?: boolean
    status?: boolean
  }

  export type EnrollmentApprovalGetPayload<
    S extends boolean | null | undefined | EnrollmentApprovalArgs,
    U = keyof S
      > = S extends true
        ? EnrollmentApproval
    : S extends undefined
    ? never
    : S extends EnrollmentApprovalArgs | EnrollmentApprovalFindManyArgs
    ?'include' extends U
    ? EnrollmentApproval 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EnrollmentApproval ? EnrollmentApproval[P] : never
  } 
    : EnrollmentApproval
  : EnrollmentApproval


  type EnrollmentApprovalCountArgs = Merge<
    Omit<EnrollmentApprovalFindManyArgs, 'select' | 'include'> & {
      select?: EnrollmentApprovalCountAggregateInputType | true
    }
  >

  export interface EnrollmentApprovalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one EnrollmentApproval that matches the filter.
     * @param {EnrollmentApprovalFindUniqueArgs} args - Arguments to find a EnrollmentApproval
     * @example
     * // Get one EnrollmentApproval
     * const enrollmentApproval = await prisma.enrollmentApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnrollmentApprovalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnrollmentApprovalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EnrollmentApproval'> extends True ? CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>> : CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval | null >, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T> | null >>

    /**
     * Find the first EnrollmentApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalFindFirstArgs} args - Arguments to find a EnrollmentApproval
     * @example
     * // Get one EnrollmentApproval
     * const enrollmentApproval = await prisma.enrollmentApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnrollmentApprovalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnrollmentApprovalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EnrollmentApproval'> extends True ? CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>> : CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval | null >, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T> | null >>

    /**
     * Find zero or more EnrollmentApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnrollmentApprovals
     * const enrollmentApprovals = await prisma.enrollmentApproval.findMany()
     * 
     * // Get first 10 EnrollmentApprovals
     * const enrollmentApprovals = await prisma.enrollmentApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentApprovalWithIdOnly = await prisma.enrollmentApproval.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnrollmentApprovalFindManyArgs>(
      args?: SelectSubset<T, EnrollmentApprovalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<EnrollmentApproval>>, PrismaPromise<Array<EnrollmentApprovalGetPayload<T>>>>

    /**
     * Create a EnrollmentApproval.
     * @param {EnrollmentApprovalCreateArgs} args - Arguments to create a EnrollmentApproval.
     * @example
     * // Create one EnrollmentApproval
     * const EnrollmentApproval = await prisma.enrollmentApproval.create({
     *   data: {
     *     // ... data to create a EnrollmentApproval
     *   }
     * })
     * 
    **/
    create<T extends EnrollmentApprovalCreateArgs>(
      args: SelectSubset<T, EnrollmentApprovalCreateArgs>
    ): CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>>

    /**
     * Create many EnrollmentApprovals.
     *     @param {EnrollmentApprovalCreateManyArgs} args - Arguments to create many EnrollmentApprovals.
     *     @example
     *     // Create many EnrollmentApprovals
     *     const enrollmentApproval = await prisma.enrollmentApproval.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnrollmentApprovalCreateManyArgs>(
      args?: SelectSubset<T, EnrollmentApprovalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a EnrollmentApproval.
     * @param {EnrollmentApprovalDeleteArgs} args - Arguments to delete one EnrollmentApproval.
     * @example
     * // Delete one EnrollmentApproval
     * const EnrollmentApproval = await prisma.enrollmentApproval.delete({
     *   where: {
     *     // ... filter to delete one EnrollmentApproval
     *   }
     * })
     * 
    **/
    delete<T extends EnrollmentApprovalDeleteArgs>(
      args: SelectSubset<T, EnrollmentApprovalDeleteArgs>
    ): CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>>

    /**
     * Update one EnrollmentApproval.
     * @param {EnrollmentApprovalUpdateArgs} args - Arguments to update one EnrollmentApproval.
     * @example
     * // Update one EnrollmentApproval
     * const enrollmentApproval = await prisma.enrollmentApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnrollmentApprovalUpdateArgs>(
      args: SelectSubset<T, EnrollmentApprovalUpdateArgs>
    ): CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>>

    /**
     * Delete zero or more EnrollmentApprovals.
     * @param {EnrollmentApprovalDeleteManyArgs} args - Arguments to filter EnrollmentApprovals to delete.
     * @example
     * // Delete a few EnrollmentApprovals
     * const { count } = await prisma.enrollmentApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnrollmentApprovalDeleteManyArgs>(
      args?: SelectSubset<T, EnrollmentApprovalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnrollmentApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnrollmentApprovals
     * const enrollmentApproval = await prisma.enrollmentApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnrollmentApprovalUpdateManyArgs>(
      args: SelectSubset<T, EnrollmentApprovalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one EnrollmentApproval.
     * @param {EnrollmentApprovalUpsertArgs} args - Arguments to update or create a EnrollmentApproval.
     * @example
     * // Update or create a EnrollmentApproval
     * const enrollmentApproval = await prisma.enrollmentApproval.upsert({
     *   create: {
     *     // ... data to create a EnrollmentApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnrollmentApproval we want to update
     *   }
     * })
    **/
    upsert<T extends EnrollmentApprovalUpsertArgs>(
      args: SelectSubset<T, EnrollmentApprovalUpsertArgs>
    ): CheckSelect<T, Prisma__EnrollmentApprovalClient<EnrollmentApproval>, Prisma__EnrollmentApprovalClient<EnrollmentApprovalGetPayload<T>>>

    /**
     * Find zero or more EnrollmentApprovals that matches the filter.
     * @param {EnrollmentApprovalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const enrollmentApproval = await prisma.enrollmentApproval.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EnrollmentApprovalFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EnrollmentApproval.
     * @param {EnrollmentApprovalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const enrollmentApproval = await prisma.enrollmentApproval.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EnrollmentApprovalAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of EnrollmentApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalCountArgs} args - Arguments to filter EnrollmentApprovals to count.
     * @example
     * // Count the number of EnrollmentApprovals
     * const count = await prisma.enrollmentApproval.count({
     *   where: {
     *     // ... the filter for the EnrollmentApprovals we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentApprovalCountArgs>(
      args?: Subset<T, EnrollmentApprovalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnrollmentApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentApprovalAggregateArgs>(args: Subset<T, EnrollmentApprovalAggregateArgs>): PrismaPromise<GetEnrollmentApprovalAggregateType<T>>

    /**
     * Group by EnrollmentApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentApprovalGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentApprovalGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnrollmentApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnrollmentApprovalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * EnrollmentApproval findUnique
   */
  export type EnrollmentApprovalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * Throw an Error if a EnrollmentApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EnrollmentApproval to fetch.
     * 
    **/
    where: EnrollmentApprovalWhereUniqueInput
  }


  /**
   * EnrollmentApproval findFirst
   */
  export type EnrollmentApprovalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * Throw an Error if a EnrollmentApproval can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which EnrollmentApproval to fetch.
     * 
    **/
    where?: EnrollmentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<EnrollmentApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnrollmentApprovals.
     * 
    **/
    cursor?: EnrollmentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentApprovals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnrollmentApprovals.
     * 
    **/
    distinct?: Enumerable<EnrollmentApprovalScalarFieldEnum>
  }


  /**
   * EnrollmentApproval findMany
   */
  export type EnrollmentApprovalFindManyArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * Filter, which EnrollmentApprovals to fetch.
     * 
    **/
    where?: EnrollmentApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnrollmentApprovals to fetch.
     * 
    **/
    orderBy?: Enumerable<EnrollmentApprovalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnrollmentApprovals.
     * 
    **/
    cursor?: EnrollmentApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnrollmentApprovals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnrollmentApprovals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EnrollmentApprovalScalarFieldEnum>
  }


  /**
   * EnrollmentApproval create
   */
  export type EnrollmentApprovalCreateArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * The data needed to create a EnrollmentApproval.
     * 
    **/
    data: XOR<EnrollmentApprovalCreateInput, EnrollmentApprovalUncheckedCreateInput>
  }


  /**
   * EnrollmentApproval createMany
   */
  export type EnrollmentApprovalCreateManyArgs = {
    /**
     * The data used to create many EnrollmentApprovals.
     * 
    **/
    data: Enumerable<EnrollmentApprovalCreateManyInput>
  }


  /**
   * EnrollmentApproval update
   */
  export type EnrollmentApprovalUpdateArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * The data needed to update a EnrollmentApproval.
     * 
    **/
    data: XOR<EnrollmentApprovalUpdateInput, EnrollmentApprovalUncheckedUpdateInput>
    /**
     * Choose, which EnrollmentApproval to update.
     * 
    **/
    where: EnrollmentApprovalWhereUniqueInput
  }


  /**
   * EnrollmentApproval updateMany
   */
  export type EnrollmentApprovalUpdateManyArgs = {
    /**
     * The data used to update EnrollmentApprovals.
     * 
    **/
    data: XOR<EnrollmentApprovalUpdateManyMutationInput, EnrollmentApprovalUncheckedUpdateManyInput>
    /**
     * Filter which EnrollmentApprovals to update
     * 
    **/
    where?: EnrollmentApprovalWhereInput
  }


  /**
   * EnrollmentApproval upsert
   */
  export type EnrollmentApprovalUpsertArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * The filter to search for the EnrollmentApproval to update in case it exists.
     * 
    **/
    where: EnrollmentApprovalWhereUniqueInput
    /**
     * In case the EnrollmentApproval found by the `where` argument doesn't exist, create a new EnrollmentApproval with this data.
     * 
    **/
    create: XOR<EnrollmentApprovalCreateInput, EnrollmentApprovalUncheckedCreateInput>
    /**
     * In case the EnrollmentApproval was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EnrollmentApprovalUpdateInput, EnrollmentApprovalUncheckedUpdateInput>
  }


  /**
   * EnrollmentApproval delete
   */
  export type EnrollmentApprovalDeleteArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
    /**
     * Filter which EnrollmentApproval to delete.
     * 
    **/
    where: EnrollmentApprovalWhereUniqueInput
  }


  /**
   * EnrollmentApproval deleteMany
   */
  export type EnrollmentApprovalDeleteManyArgs = {
    /**
     * Filter which EnrollmentApprovals to delete
     * 
    **/
    where?: EnrollmentApprovalWhereInput
  }


  /**
   * EnrollmentApproval findRaw
   */
  export type EnrollmentApprovalFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * EnrollmentApproval aggregateRaw
   */
  export type EnrollmentApprovalAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * EnrollmentApproval without action
   */
  export type EnrollmentApprovalArgs = {
    /**
     * Select specific fields to fetch from the EnrollmentApproval
     * 
    **/
    select?: EnrollmentApprovalSelect | null
  }



  /**
   * Model Students
   */


  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    status: StudentStatus | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    status: StudentStatus | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    status: number
    _all: number
  }


  export type StudentsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    status?: true
    _all?: true
  }

  export type StudentsAggregateArgs = {
    /**
     * Filter which Students to aggregate.
     * 
    **/
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type StudentsGroupByArgs = {
    where?: StudentsWhereInput
    orderBy?: Enumerable<StudentsOrderByWithAggregationInput>
    by: Array<StudentsScalarFieldEnum>
    having?: StudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }


  export type StudentsGroupByOutputType = {
    id: string
    name: string
    email: string
    status: StudentStatus
    _count: StudentsCountAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends StudentsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentsSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    status?: boolean
  }

  export type StudentsGetPayload<
    S extends boolean | null | undefined | StudentsArgs,
    U = keyof S
      > = S extends true
        ? Students
    : S extends undefined
    ? never
    : S extends StudentsArgs | StudentsFindManyArgs
    ?'include' extends U
    ? Students 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Students ? Students[P] : never
  } 
    : Students
  : Students


  type StudentsCountArgs = Merge<
    Omit<StudentsFindManyArgs, 'select' | 'include'> & {
      select?: StudentsCountAggregateInputType | true
    }
  >

  export interface StudentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Students that matches the filter.
     * @param {StudentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StudentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Students'> extends True ? CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>> : CheckSelect<T, Prisma__StudentsClient<Students | null >, Prisma__StudentsClient<StudentsGetPayload<T> | null >>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StudentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Students'> extends True ? CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>> : CheckSelect<T, Prisma__StudentsClient<Students | null >, Prisma__StudentsClient<StudentsGetPayload<T> | null >>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentsFindManyArgs>(
      args?: SelectSubset<T, StudentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Students>>, PrismaPromise<Array<StudentsGetPayload<T>>>>

    /**
     * Create a Students.
     * @param {StudentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
    **/
    create<T extends StudentsCreateArgs>(
      args: SelectSubset<T, StudentsCreateArgs>
    ): CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>>

    /**
     * Create many Students.
     *     @param {StudentsCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const students = await prisma.students.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentsCreateManyArgs>(
      args?: SelectSubset<T, StudentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Students.
     * @param {StudentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
    **/
    delete<T extends StudentsDeleteArgs>(
      args: SelectSubset<T, StudentsDeleteArgs>
    ): CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>>

    /**
     * Update one Students.
     * @param {StudentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentsUpdateArgs>(
      args: SelectSubset<T, StudentsUpdateArgs>
    ): CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>>

    /**
     * Delete zero or more Students.
     * @param {StudentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentsDeleteManyArgs>(
      args?: SelectSubset<T, StudentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentsUpdateManyArgs>(
      args: SelectSubset<T, StudentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Students.
     * @param {StudentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
    **/
    upsert<T extends StudentsUpsertArgs>(
      args: SelectSubset<T, StudentsUpsertArgs>
    ): CheckSelect<T, Prisma__StudentsClient<Students>, Prisma__StudentsClient<StudentsGetPayload<T>>>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const students = await prisma.students.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: StudentsFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Students.
     * @param {StudentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const students = await prisma.students.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: StudentsAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentsCountArgs>(
      args?: Subset<T, StudentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StudentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Students findUnique
   */
  export type StudentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * Throw an Error if a Students can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Students to fetch.
     * 
    **/
    where: StudentsWhereUniqueInput
  }


  /**
   * Students findFirst
   */
  export type StudentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * Throw an Error if a Students can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Students to fetch.
     * 
    **/
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     * 
    **/
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     * 
    **/
    distinct?: Enumerable<StudentsScalarFieldEnum>
  }


  /**
   * Students findMany
   */
  export type StudentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * Filter, which Students to fetch.
     * 
    **/
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     * 
    **/
    orderBy?: Enumerable<StudentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     * 
    **/
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StudentsScalarFieldEnum>
  }


  /**
   * Students create
   */
  export type StudentsCreateArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * The data needed to create a Students.
     * 
    **/
    data: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
  }


  /**
   * Students createMany
   */
  export type StudentsCreateManyArgs = {
    /**
     * The data used to create many Students.
     * 
    **/
    data: Enumerable<StudentsCreateManyInput>
  }


  /**
   * Students update
   */
  export type StudentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * The data needed to update a Students.
     * 
    **/
    data: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
    /**
     * Choose, which Students to update.
     * 
    **/
    where: StudentsWhereUniqueInput
  }


  /**
   * Students updateMany
   */
  export type StudentsUpdateManyArgs = {
    /**
     * The data used to update Students.
     * 
    **/
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     * 
    **/
    where?: StudentsWhereInput
  }


  /**
   * Students upsert
   */
  export type StudentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * The filter to search for the Students to update in case it exists.
     * 
    **/
    where: StudentsWhereUniqueInput
    /**
     * In case the Students found by the `where` argument doesn't exist, create a new Students with this data.
     * 
    **/
    create: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
    /**
     * In case the Students was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
  }


  /**
   * Students delete
   */
  export type StudentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
    /**
     * Filter which Students to delete.
     * 
    **/
    where: StudentsWhereUniqueInput
  }


  /**
   * Students deleteMany
   */
  export type StudentsDeleteManyArgs = {
    /**
     * Filter which Students to delete
     * 
    **/
    where?: StudentsWhereInput
  }


  /**
   * Students findRaw
   */
  export type StudentsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Students aggregateRaw
   */
  export type StudentsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Students without action
   */
  export type StudentsArgs = {
    /**
     * Select specific fields to fetch from the Students
     * 
    **/
    select?: StudentsSelect | null
  }



  /**
   * Model Staff
   */


  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: StaffRole | null
    phone: string | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: StaffRole | null
    phone: string | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    name: number
    email: number
    role: number
    phone: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    phone?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    phone?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    phone?: true
    _all?: true
  }

  export type StaffAggregateArgs = {
    /**
     * Filter which Staff to aggregate.
     * 
    **/
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     * 
    **/
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs = {
    where?: StaffWhereInput
    orderBy?: Enumerable<StaffOrderByWithAggregationInput>
    by: Array<StaffScalarFieldEnum>
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }


  export type StaffGroupByOutputType = {
    id: string
    name: string
    email: string
    role: StaffRole
    phone: string
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = PrismaPromise<
    Array<
      PickArray<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
  }

  export type StaffGetPayload<
    S extends boolean | null | undefined | StaffArgs,
    U = keyof S
      > = S extends true
        ? Staff
    : S extends undefined
    ? never
    : S extends StaffArgs | StaffFindManyArgs
    ?'include' extends U
    ? Staff 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Staff ? Staff[P] : never
  } 
    : Staff
  : Staff


  type StaffCountArgs = Merge<
    Omit<StaffFindManyArgs, 'select' | 'include'> & {
      select?: StaffCountAggregateInputType | true
    }
  >

  export interface StaffDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StaffFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StaffFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Staff'> extends True ? CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>> : CheckSelect<T, Prisma__StaffClient<Staff | null >, Prisma__StaffClient<StaffGetPayload<T> | null >>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StaffFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StaffFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Staff'> extends True ? CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>> : CheckSelect<T, Prisma__StaffClient<Staff | null >, Prisma__StaffClient<StaffGetPayload<T> | null >>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StaffFindManyArgs>(
      args?: SelectSubset<T, StaffFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Staff>>, PrismaPromise<Array<StaffGetPayload<T>>>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
    **/
    create<T extends StaffCreateArgs>(
      args: SelectSubset<T, StaffCreateArgs>
    ): CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>>

    /**
     * Create many Staff.
     *     @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     *     @example
     *     // Create many Staff
     *     const staff = await prisma.staff.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StaffCreateManyArgs>(
      args?: SelectSubset<T, StaffCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
    **/
    delete<T extends StaffDeleteArgs>(
      args: SelectSubset<T, StaffDeleteArgs>
    ): CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StaffUpdateArgs>(
      args: SelectSubset<T, StaffUpdateArgs>
    ): CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StaffDeleteManyArgs>(
      args?: SelectSubset<T, StaffDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StaffUpdateManyArgs>(
      args: SelectSubset<T, StaffUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
    **/
    upsert<T extends StaffUpsertArgs>(
      args: SelectSubset<T, StaffUpsertArgs>
    ): CheckSelect<T, Prisma__StaffClient<Staff>, Prisma__StaffClient<StaffGetPayload<T>>>

    /**
     * Find zero or more Staff that matches the filter.
     * @param {StaffFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const staff = await prisma.staff.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: StaffFindRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Staff.
     * @param {StaffAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const staff = await prisma.staff.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: StaffAggregateRawArgs
    ): PrismaPromise<JsonObject>

    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StaffClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * Throw an Error if a Staff can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Staff to fetch.
     * 
    **/
    where: StaffWhereUniqueInput
  }


  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * Throw an Error if a Staff can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Staff to fetch.
     * 
    **/
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     * 
    **/
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     * 
    **/
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     * 
    **/
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff findMany
   */
  export type StaffFindManyArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * Filter, which Staff to fetch.
     * 
    **/
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     * 
    **/
    orderBy?: Enumerable<StaffOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     * 
    **/
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     * 
    **/
    skip?: number
    distinct?: Enumerable<StaffScalarFieldEnum>
  }


  /**
   * Staff create
   */
  export type StaffCreateArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * The data needed to create a Staff.
     * 
    **/
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }


  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs = {
    /**
     * The data used to create many Staff.
     * 
    **/
    data: Enumerable<StaffCreateManyInput>
  }


  /**
   * Staff update
   */
  export type StaffUpdateArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * The data needed to update a Staff.
     * 
    **/
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     * 
    **/
    where: StaffWhereUniqueInput
  }


  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs = {
    /**
     * The data used to update Staff.
     * 
    **/
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     * 
    **/
    where?: StaffWhereInput
  }


  /**
   * Staff upsert
   */
  export type StaffUpsertArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * The filter to search for the Staff to update in case it exists.
     * 
    **/
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     * 
    **/
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }


  /**
   * Staff delete
   */
  export type StaffDeleteArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
    /**
     * Filter which Staff to delete.
     * 
    **/
    where: StaffWhereUniqueInput
  }


  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs = {
    /**
     * Filter which Staff to delete
     * 
    **/
    where?: StaffWhereInput
  }


  /**
   * Staff findRaw
   */
  export type StaffFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     * 
    **/
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Staff aggregateRaw
   */
  export type StaffAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     * 
    **/
    pipeline?: Array<InputJsonValue>
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     * 
    **/
    options?: InputJsonValue
  }


  /**
   * Staff without action
   */
  export type StaffArgs = {
    /**
     * Select specific fields to fetch from the Staff
     * 
    **/
    select?: StaffSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    cnic: 'cnic',
    address: 'address',
    phone: 'phone',
    role: 'role',
    permission: 'permission',
    emailApproval: 'emailApproval',
    successStoriesId: 'successStoriesId',
    token: 'token',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MyCourseScalarFieldEnum: {
    id: 'id',
    coursesId: 'coursesId',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    courseApproval: 'courseApproval',
    whyReject: 'whyReject',
    feeStatus: 'feeStatus',
    courseBatchesId: 'courseBatchesId'
  };

  export type MyCourseScalarFieldEnum = (typeof MyCourseScalarFieldEnum)[keyof typeof MyCourseScalarFieldEnum]


  export const MyCartScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    coursesId: 'coursesId',
    userId: 'userId'
  };

  export type MyCartScalarFieldEnum = (typeof MyCartScalarFieldEnum)[keyof typeof MyCartScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    categoryName: 'categoryName',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    courseName: 'courseName',
    courseDesc: 'courseDesc',
    courseIntro: 'courseIntro',
    instructorId: 'instructorId',
    courseCategoryId: 'courseCategoryId',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    courseStatus: 'courseStatus',
    whatYouLearn: 'whatYouLearn',
    coursePrice: 'coursePrice'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const LecturesScalarFieldEnum: {
    id: 'id',
    lectureTitle: 'lectureTitle',
    lectureVideo: 'lectureVideo',
    coursesId: 'coursesId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type LecturesScalarFieldEnum = (typeof LecturesScalarFieldEnum)[keyof typeof LecturesScalarFieldEnum]


  export const CourseBatchesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    coursesId: 'coursesId',
    courseName: 'courseName',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type CourseBatchesScalarFieldEnum = (typeof CourseBatchesScalarFieldEnum)[keyof typeof CourseBatchesScalarFieldEnum]


  export const CourseAssignmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    courseBatchesId: 'courseBatchesId',
    coursesId: 'coursesId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type CourseAssignmentScalarFieldEnum = (typeof CourseAssignmentScalarFieldEnum)[keyof typeof CourseAssignmentScalarFieldEnum]


  export const CourseQuizScalarFieldEnum: {
    id: 'id',
    courseBatchesId: 'courseBatchesId',
    coursesId: 'coursesId',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type CourseQuizScalarFieldEnum = (typeof CourseQuizScalarFieldEnum)[keyof typeof CourseQuizScalarFieldEnum]


  export const SpeakerScalarFieldEnum: {
    id: 'id',
    speakerName: 'speakerName',
    spkearDesc: 'spkearDesc',
    spekaerImage: 'spekaerImage',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type SpeakerScalarFieldEnum = (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    eventName: 'eventName',
    eventDesc: 'eventDesc',
    eventImage: 'eventImage',
    eventDate: 'eventDate',
    speakerId: 'speakerId'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    faqQuestion: 'faqQuestion',
    faqAnswer: 'faqAnswer',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const SuccessStoriesScalarFieldEnum: {
    id: 'id',
    freelancingProfileUrl: 'freelancingProfileUrl',
    paymentProof: 'paymentProof',
    description: 'description',
    status: 'status',
    totalEarnedAmount: 'totalEarnedAmount',
    city: 'city',
    whyReject: 'whyReject'
  };

  export type SuccessStoriesScalarFieldEnum = (typeof SuccessStoriesScalarFieldEnum)[keyof typeof SuccessStoriesScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    id: 'id',
    blogTitle: 'blogTitle',
    blogDescription: 'blogDescription',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    featuredImage: 'featuredImage',
    commentType: 'commentType'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    blogsId: 'blogsId',
    createdAt: 'createdAt',
    comment: 'comment',
    userId: 'userId'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    message: 'message',
    status: 'status',
    reply: 'reply'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const AttendenceScalarFieldEnum: {
    id: 'id',
    attendence: 'attendence',
    date: 'date',
    userId: 'userId'
  };

  export type AttendenceScalarFieldEnum = (typeof AttendenceScalarFieldEnum)[keyof typeof AttendenceScalarFieldEnum]


  export const FeesScalarFieldEnum: {
    id: 'id',
    amountPaid: 'amountPaid',
    remainingAmount: 'remainingAmount',
    studentId: 'studentId',
    studentName: 'studentName',
    createdAt: 'createdAt',
    updateAt: 'updateAt'
  };

  export type FeesScalarFieldEnum = (typeof FeesScalarFieldEnum)[keyof typeof FeesScalarFieldEnum]


  export const EnrollmentApprovalScalarFieldEnum: {
    id: 'id',
    studentName: 'studentName',
    email: 'email',
    course: 'course',
    paymentMethod: 'paymentMethod',
    amount: 'amount',
    transactionId: 'transactionId',
    status: 'status'
  };

  export type EnrollmentApprovalScalarFieldEnum = (typeof EnrollmentApprovalScalarFieldEnum)[keyof typeof EnrollmentApprovalScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    status: 'status'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    role: 'role',
    phone: 'phone'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    cnic?: StringFilter | string
    address?: StringFilter | string
    phone?: StringFilter | string
    role?: EnumRoleFilter | Role
    permission?: EnumPermissionFilter | Permission
    courses?: CoursesListRelationFilter
    myCart?: MyCartListRelationFilter
    successStory?: XOR<SuccessStoriesRelationFilter, SuccessStoriesWhereInput> | null
    emailApproval?: BoolFilter | boolean
    myComments?: CommentsListRelationFilter
    attendence?: AttendenceListRelationFilter
    fees?: FeesListRelationFilter
    successStoriesId?: StringNullableFilter | string | null
    myCourse?: MyCourseListRelationFilter
    token?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cnic?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    courses?: CoursesOrderByRelationAggregateInput
    myCart?: MyCartOrderByRelationAggregateInput
    successStory?: SuccessStoriesOrderByWithRelationInput
    emailApproval?: SortOrder
    myComments?: CommentsOrderByRelationAggregateInput
    attendence?: AttendenceOrderByRelationAggregateInput
    fees?: FeesOrderByRelationAggregateInput
    successStoriesId?: SortOrder
    myCourse?: MyCourseOrderByRelationAggregateInput
    token?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cnic?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    emailApproval?: SortOrder
    successStoriesId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    cnic?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    permission?: EnumPermissionWithAggregatesFilter | Permission
    emailApproval?: BoolWithAggregatesFilter | boolean
    successStoriesId?: StringNullableWithAggregatesFilter | string | null
    token?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MyCourseWhereInput = {
    AND?: Enumerable<MyCourseWhereInput>
    OR?: Enumerable<MyCourseWhereInput>
    NOT?: Enumerable<MyCourseWhereInput>
    id?: StringFilter | string
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    student?: XOR<UserRelationFilter, UserWhereInput>
    studentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    courseApproval?: BoolFilter | boolean
    whyReject?: StringFilter | string
    feeStatus?: EnumFeeStatusFilter | FeeStatus
    courseBatches?: XOR<CourseBatchesRelationFilter, CourseBatchesWhereInput>
    courseBatchesId?: StringFilter | string
  }

  export type MyCourseOrderByWithRelationInput = {
    id?: SortOrder
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    student?: UserOrderByWithRelationInput
    studentId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseApproval?: SortOrder
    whyReject?: SortOrder
    feeStatus?: SortOrder
    courseBatches?: CourseBatchesOrderByWithRelationInput
    courseBatchesId?: SortOrder
  }

  export type MyCourseWhereUniqueInput = {
    id?: string
    coursesId_studentId?: MyCourseCoursesIdStudentIdCompoundUniqueInput
  }

  export type MyCourseOrderByWithAggregationInput = {
    id?: SortOrder
    coursesId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseApproval?: SortOrder
    whyReject?: SortOrder
    feeStatus?: SortOrder
    courseBatchesId?: SortOrder
    _count?: MyCourseCountOrderByAggregateInput
    _max?: MyCourseMaxOrderByAggregateInput
    _min?: MyCourseMinOrderByAggregateInput
  }

  export type MyCourseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MyCourseScalarWhereWithAggregatesInput>
    OR?: Enumerable<MyCourseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MyCourseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    coursesId?: StringWithAggregatesFilter | string
    studentId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    courseApproval?: BoolWithAggregatesFilter | boolean
    whyReject?: StringWithAggregatesFilter | string
    feeStatus?: EnumFeeStatusWithAggregatesFilter | FeeStatus
    courseBatchesId?: StringWithAggregatesFilter | string
  }

  export type MyCartWhereInput = {
    AND?: Enumerable<MyCartWhereInput>
    OR?: Enumerable<MyCartWhereInput>
    NOT?: Enumerable<MyCartWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
  }

  export type MyCartOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type MyCartWhereUniqueInput = {
    id?: string
  }

  export type MyCartOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    coursesId?: SortOrder
    userId?: SortOrder
    _count?: MyCartCountOrderByAggregateInput
    _max?: MyCartMaxOrderByAggregateInput
    _min?: MyCartMinOrderByAggregateInput
  }

  export type MyCartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MyCartScalarWhereWithAggregatesInput>
    OR?: Enumerable<MyCartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MyCartScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    coursesId?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    categoryName?: StringFilter | string
    allCourses?: CoursesListRelationFilter
    imageUrl?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    categoryName?: SortOrder
    allCourses?: CoursesOrderByRelationAggregateInput
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: string
    categoryName?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    categoryName?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    categoryName?: StringWithAggregatesFilter | string
    imageUrl?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CoursesWhereInput = {
    AND?: Enumerable<CoursesWhereInput>
    OR?: Enumerable<CoursesWhereInput>
    NOT?: Enumerable<CoursesWhereInput>
    id?: StringFilter | string
    courseName?: StringFilter | string
    courseDesc?: StringFilter | string
    courseIntro?: StringFilter | string
    instructor?: XOR<UserRelationFilter, UserWhereInput>
    instructorId?: StringFilter | string
    courseCategory?: XOR<CategoryRelationFilter, CategoryWhereInput>
    courseCategoryId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    lectures?: LecturesListRelationFilter
    totalBatches?: CourseBatchesListRelationFilter
    courseStatus?: EnumStatusFilter | Status
    whatYouLearn?: JsonNullableListFilter
    assignment?: CourseAssignmentListRelationFilter
    courseQuiz?: CourseQuizListRelationFilter
    enrollList?: MyCourseListRelationFilter
    cartList?: MyCartListRelationFilter
    coursePrice?: StringFilter | string
  }

  export type CoursesOrderByWithRelationInput = {
    id?: SortOrder
    courseName?: SortOrder
    courseDesc?: SortOrder
    courseIntro?: SortOrder
    instructor?: UserOrderByWithRelationInput
    instructorId?: SortOrder
    courseCategory?: CategoryOrderByWithRelationInput
    courseCategoryId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    lectures?: LecturesOrderByRelationAggregateInput
    totalBatches?: CourseBatchesOrderByRelationAggregateInput
    courseStatus?: SortOrder
    whatYouLearn?: SortOrder
    assignment?: CourseAssignmentOrderByRelationAggregateInput
    courseQuiz?: CourseQuizOrderByRelationAggregateInput
    enrollList?: MyCourseOrderByRelationAggregateInput
    cartList?: MyCartOrderByRelationAggregateInput
    coursePrice?: SortOrder
  }

  export type CoursesWhereUniqueInput = {
    id?: string
  }

  export type CoursesOrderByWithAggregationInput = {
    id?: SortOrder
    courseName?: SortOrder
    courseDesc?: SortOrder
    courseIntro?: SortOrder
    instructorId?: SortOrder
    courseCategoryId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseStatus?: SortOrder
    whatYouLearn?: SortOrder
    coursePrice?: SortOrder
    _count?: CoursesCountOrderByAggregateInput
    _max?: CoursesMaxOrderByAggregateInput
    _min?: CoursesMinOrderByAggregateInput
  }

  export type CoursesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CoursesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CoursesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CoursesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    courseName?: StringWithAggregatesFilter | string
    courseDesc?: StringWithAggregatesFilter | string
    courseIntro?: StringWithAggregatesFilter | string
    instructorId?: StringWithAggregatesFilter | string
    courseCategoryId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    courseStatus?: EnumStatusWithAggregatesFilter | Status
    whatYouLearn?: JsonNullableListFilter
    coursePrice?: StringWithAggregatesFilter | string
  }

  export type LecturesWhereInput = {
    AND?: Enumerable<LecturesWhereInput>
    OR?: Enumerable<LecturesWhereInput>
    NOT?: Enumerable<LecturesWhereInput>
    id?: StringFilter | string
    lectureTitle?: StringFilter | string
    lectureVideo?: StringFilter | string
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type LecturesOrderByWithRelationInput = {
    id?: SortOrder
    lectureTitle?: SortOrder
    lectureVideo?: SortOrder
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type LecturesWhereUniqueInput = {
    id?: string
  }

  export type LecturesOrderByWithAggregationInput = {
    id?: SortOrder
    lectureTitle?: SortOrder
    lectureVideo?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: LecturesCountOrderByAggregateInput
    _max?: LecturesMaxOrderByAggregateInput
    _min?: LecturesMinOrderByAggregateInput
  }

  export type LecturesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LecturesScalarWhereWithAggregatesInput>
    OR?: Enumerable<LecturesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LecturesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    lectureTitle?: StringWithAggregatesFilter | string
    lectureVideo?: StringWithAggregatesFilter | string
    coursesId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CourseBatchesWhereInput = {
    AND?: Enumerable<CourseBatchesWhereInput>
    OR?: Enumerable<CourseBatchesWhereInput>
    NOT?: Enumerable<CourseBatchesWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    assignment?: CourseAssignmentListRelationFilter
    quiz?: CourseQuizListRelationFilter
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    courseName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    enrolledStudent?: MyCourseListRelationFilter
  }

  export type CourseBatchesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    assignment?: CourseAssignmentOrderByRelationAggregateInput
    quiz?: CourseQuizOrderByRelationAggregateInput
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    courseName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    enrolledStudent?: MyCourseOrderByRelationAggregateInput
  }

  export type CourseBatchesWhereUniqueInput = {
    id?: string
  }

  export type CourseBatchesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    coursesId?: SortOrder
    courseName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: CourseBatchesCountOrderByAggregateInput
    _max?: CourseBatchesMaxOrderByAggregateInput
    _min?: CourseBatchesMinOrderByAggregateInput
  }

  export type CourseBatchesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CourseBatchesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CourseBatchesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CourseBatchesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    coursesId?: StringWithAggregatesFilter | string
    courseName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CourseAssignmentWhereInput = {
    AND?: Enumerable<CourseAssignmentWhereInput>
    OR?: Enumerable<CourseAssignmentWhereInput>
    NOT?: Enumerable<CourseAssignmentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    CourseBatches?: XOR<CourseBatchesRelationFilter, CourseBatchesWhereInput>
    courseBatchesId?: StringFilter | string
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CourseAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    CourseBatches?: CourseBatchesOrderByWithRelationInput
    courseBatchesId?: SortOrder
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseAssignmentWhereUniqueInput = {
    id?: string
  }

  export type CourseAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: CourseAssignmentCountOrderByAggregateInput
    _max?: CourseAssignmentMaxOrderByAggregateInput
    _min?: CourseAssignmentMinOrderByAggregateInput
  }

  export type CourseAssignmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CourseAssignmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CourseAssignmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CourseAssignmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    courseBatchesId?: StringWithAggregatesFilter | string
    coursesId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CourseQuizWhereInput = {
    AND?: Enumerable<CourseQuizWhereInput>
    OR?: Enumerable<CourseQuizWhereInput>
    NOT?: Enumerable<CourseQuizWhereInput>
    id?: StringFilter | string
    courseBatches?: XOR<CourseBatchesRelationFilter, CourseBatchesWhereInput>
    courseBatchesId?: StringFilter | string
    courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CourseQuizOrderByWithRelationInput = {
    id?: SortOrder
    courseBatches?: CourseBatchesOrderByWithRelationInput
    courseBatchesId?: SortOrder
    courses?: CoursesOrderByWithRelationInput
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseQuizWhereUniqueInput = {
    id?: string
  }

  export type CourseQuizOrderByWithAggregationInput = {
    id?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: CourseQuizCountOrderByAggregateInput
    _max?: CourseQuizMaxOrderByAggregateInput
    _min?: CourseQuizMinOrderByAggregateInput
  }

  export type CourseQuizScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CourseQuizScalarWhereWithAggregatesInput>
    OR?: Enumerable<CourseQuizScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CourseQuizScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    courseBatchesId?: StringWithAggregatesFilter | string
    coursesId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SpeakerWhereInput = {
    AND?: Enumerable<SpeakerWhereInput>
    OR?: Enumerable<SpeakerWhereInput>
    NOT?: Enumerable<SpeakerWhereInput>
    id?: StringFilter | string
    speakerName?: StringFilter | string
    spkearDesc?: StringFilter | string
    spekaerImage?: StringFilter | string
    events?: EventsListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type SpeakerOrderByWithRelationInput = {
    id?: SortOrder
    speakerName?: SortOrder
    spkearDesc?: SortOrder
    spekaerImage?: SortOrder
    events?: EventsOrderByRelationAggregateInput
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type SpeakerWhereUniqueInput = {
    id?: string
  }

  export type SpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    speakerName?: SortOrder
    spkearDesc?: SortOrder
    spekaerImage?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: SpeakerCountOrderByAggregateInput
    _max?: SpeakerMaxOrderByAggregateInput
    _min?: SpeakerMinOrderByAggregateInput
  }

  export type SpeakerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpeakerScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpeakerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpeakerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    speakerName?: StringWithAggregatesFilter | string
    spkearDesc?: StringWithAggregatesFilter | string
    spekaerImage?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EventsWhereInput = {
    AND?: Enumerable<EventsWhereInput>
    OR?: Enumerable<EventsWhereInput>
    NOT?: Enumerable<EventsWhereInput>
    id?: StringFilter | string
    eventName?: StringFilter | string
    eventDesc?: StringFilter | string
    eventImage?: StringNullableFilter | string | null
    eventDate?: DateTimeFilter | Date | string
    Speaker?: XOR<SpeakerRelationFilter, SpeakerWhereInput>
    speakerId?: StringFilter | string
  }

  export type EventsOrderByWithRelationInput = {
    id?: SortOrder
    eventName?: SortOrder
    eventDesc?: SortOrder
    eventImage?: SortOrder
    eventDate?: SortOrder
    Speaker?: SpeakerOrderByWithRelationInput
    speakerId?: SortOrder
  }

  export type EventsWhereUniqueInput = {
    id?: string
  }

  export type EventsOrderByWithAggregationInput = {
    id?: SortOrder
    eventName?: SortOrder
    eventDesc?: SortOrder
    eventImage?: SortOrder
    eventDate?: SortOrder
    speakerId?: SortOrder
    _count?: EventsCountOrderByAggregateInput
    _max?: EventsMaxOrderByAggregateInput
    _min?: EventsMinOrderByAggregateInput
  }

  export type EventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    eventName?: StringWithAggregatesFilter | string
    eventDesc?: StringWithAggregatesFilter | string
    eventImage?: StringNullableWithAggregatesFilter | string | null
    eventDate?: DateTimeWithAggregatesFilter | Date | string
    speakerId?: StringWithAggregatesFilter | string
  }

  export type FaqWhereInput = {
    AND?: Enumerable<FaqWhereInput>
    OR?: Enumerable<FaqWhereInput>
    NOT?: Enumerable<FaqWhereInput>
    id?: StringFilter | string
    faqQuestion?: StringFilter | string
    faqAnswer?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type FaqOrderByWithRelationInput = {
    id?: SortOrder
    faqQuestion?: SortOrder
    faqAnswer?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FaqWhereUniqueInput = {
    id?: string
  }

  export type FaqOrderByWithAggregationInput = {
    id?: SortOrder
    faqQuestion?: SortOrder
    faqAnswer?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: FaqCountOrderByAggregateInput
    _max?: FaqMaxOrderByAggregateInput
    _min?: FaqMinOrderByAggregateInput
  }

  export type FaqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FaqScalarWhereWithAggregatesInput>
    OR?: Enumerable<FaqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FaqScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    faqQuestion?: StringWithAggregatesFilter | string
    faqAnswer?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SuccessStoriesWhereInput = {
    AND?: Enumerable<SuccessStoriesWhereInput>
    OR?: Enumerable<SuccessStoriesWhereInput>
    NOT?: Enumerable<SuccessStoriesWhereInput>
    id?: StringFilter | string
    freelancingProfileUrl?: StringFilter | string
    paymentProof?: StringFilter | string
    description?: StringFilter | string
    status?: EnumStatusFilter | Status
    totalEarnedAmount?: StringFilter | string
    city?: StringFilter | string
    whyReject?: StringFilter | string
    user?: UserListRelationFilter
  }

  export type SuccessStoriesOrderByWithRelationInput = {
    id?: SortOrder
    freelancingProfileUrl?: SortOrder
    paymentProof?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalEarnedAmount?: SortOrder
    city?: SortOrder
    whyReject?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type SuccessStoriesWhereUniqueInput = {
    id?: string
  }

  export type SuccessStoriesOrderByWithAggregationInput = {
    id?: SortOrder
    freelancingProfileUrl?: SortOrder
    paymentProof?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalEarnedAmount?: SortOrder
    city?: SortOrder
    whyReject?: SortOrder
    _count?: SuccessStoriesCountOrderByAggregateInput
    _max?: SuccessStoriesMaxOrderByAggregateInput
    _min?: SuccessStoriesMinOrderByAggregateInput
  }

  export type SuccessStoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SuccessStoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SuccessStoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SuccessStoriesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    freelancingProfileUrl?: StringWithAggregatesFilter | string
    paymentProof?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    status?: EnumStatusWithAggregatesFilter | Status
    totalEarnedAmount?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    whyReject?: StringWithAggregatesFilter | string
  }

  export type blogsWhereInput = {
    AND?: Enumerable<blogsWhereInput>
    OR?: Enumerable<blogsWhereInput>
    NOT?: Enumerable<blogsWhereInput>
    id?: StringFilter | string
    blogTitle?: StringFilter | string
    blogDescription?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    featuredImage?: StringFilter | string
    commentType?: BoolFilter | boolean
    comments?: CommentsListRelationFilter
  }

  export type blogsOrderByWithRelationInput = {
    id?: SortOrder
    blogTitle?: SortOrder
    blogDescription?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    featuredImage?: SortOrder
    commentType?: SortOrder
    comments?: CommentsOrderByRelationAggregateInput
  }

  export type blogsWhereUniqueInput = {
    id?: string
  }

  export type blogsOrderByWithAggregationInput = {
    id?: SortOrder
    blogTitle?: SortOrder
    blogDescription?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    featuredImage?: SortOrder
    commentType?: SortOrder
    _count?: blogsCountOrderByAggregateInput
    _max?: blogsMaxOrderByAggregateInput
    _min?: blogsMinOrderByAggregateInput
  }

  export type blogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<blogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blogsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    blogTitle?: StringWithAggregatesFilter | string
    blogDescription?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
    featuredImage?: StringWithAggregatesFilter | string
    commentType?: BoolWithAggregatesFilter | boolean
  }

  export type CommentsWhereInput = {
    AND?: Enumerable<CommentsWhereInput>
    OR?: Enumerable<CommentsWhereInput>
    NOT?: Enumerable<CommentsWhereInput>
    id?: StringFilter | string
    blogs?: XOR<BlogsRelationFilter, blogsWhereInput>
    blogsId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    comment?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    userId?: StringNullableFilter | string | null
  }

  export type CommentsOrderByWithRelationInput = {
    id?: SortOrder
    blogs?: blogsOrderByWithRelationInput
    blogsId?: SortOrder
    createdAt?: SortOrder
    comment?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type CommentsWhereUniqueInput = {
    id?: string
  }

  export type CommentsOrderByWithAggregationInput = {
    id?: SortOrder
    blogsId?: SortOrder
    createdAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
    _count?: CommentsCountOrderByAggregateInput
    _max?: CommentsMaxOrderByAggregateInput
    _min?: CommentsMinOrderByAggregateInput
  }

  export type CommentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    blogsId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    comment?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ContactUsWhereInput = {
    AND?: Enumerable<ContactUsWhereInput>
    OR?: Enumerable<ContactUsWhereInput>
    NOT?: Enumerable<ContactUsWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    subject?: StringFilter | string
    message?: StringFilter | string
    status?: EnumContactUsStatusFilter | ContactUsStatus
    reply?: StringFilter | string
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    reply?: SortOrder
  }

  export type ContactUsWhereUniqueInput = {
    id?: string
  }

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    reply?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContactUsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    status?: EnumContactUsStatusWithAggregatesFilter | ContactUsStatus
    reply?: StringWithAggregatesFilter | string
  }

  export type AttendenceWhereInput = {
    AND?: Enumerable<AttendenceWhereInput>
    OR?: Enumerable<AttendenceWhereInput>
    NOT?: Enumerable<AttendenceWhereInput>
    id?: StringFilter | string
    attendence?: BoolFilter | boolean
    date?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
  }

  export type AttendenceOrderByWithRelationInput = {
    id?: SortOrder
    attendence?: SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type AttendenceWhereUniqueInput = {
    id?: string
    userId_date?: AttendenceUserIdDateCompoundUniqueInput
  }

  export type AttendenceOrderByWithAggregationInput = {
    id?: SortOrder
    attendence?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    _count?: AttendenceCountOrderByAggregateInput
    _max?: AttendenceMaxOrderByAggregateInput
    _min?: AttendenceMinOrderByAggregateInput
  }

  export type AttendenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttendenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttendenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttendenceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    attendence?: BoolWithAggregatesFilter | boolean
    date?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
  }

  export type FeesWhereInput = {
    AND?: Enumerable<FeesWhereInput>
    OR?: Enumerable<FeesWhereInput>
    NOT?: Enumerable<FeesWhereInput>
    id?: StringFilter | string
    amountPaid?: StringFilter | string
    remainingAmount?: StringFilter | string
    student?: XOR<UserRelationFilter, UserWhereInput>
    studentId?: StringFilter | string
    studentName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type FeesOrderByWithRelationInput = {
    id?: SortOrder
    amountPaid?: SortOrder
    remainingAmount?: SortOrder
    student?: UserOrderByWithRelationInput
    studentId?: SortOrder
    studentName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FeesWhereUniqueInput = {
    id?: string
  }

  export type FeesOrderByWithAggregationInput = {
    id?: SortOrder
    amountPaid?: SortOrder
    remainingAmount?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    _count?: FeesCountOrderByAggregateInput
    _max?: FeesMaxOrderByAggregateInput
    _min?: FeesMinOrderByAggregateInput
  }

  export type FeesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeesScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    amountPaid?: StringWithAggregatesFilter | string
    remainingAmount?: StringWithAggregatesFilter | string
    studentId?: StringWithAggregatesFilter | string
    studentName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EnrollmentApprovalWhereInput = {
    AND?: Enumerable<EnrollmentApprovalWhereInput>
    OR?: Enumerable<EnrollmentApprovalWhereInput>
    NOT?: Enumerable<EnrollmentApprovalWhereInput>
    id?: StringFilter | string
    studentName?: StringFilter | string
    email?: StringFilter | string
    course?: StringFilter | string
    paymentMethod?: StringFilter | string
    amount?: StringFilter | string
    transactionId?: StringFilter | string
    status?: EnumEnrollStatusFilter | EnrollStatus
  }

  export type EnrollmentApprovalOrderByWithRelationInput = {
    id?: SortOrder
    studentName?: SortOrder
    email?: SortOrder
    course?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentApprovalWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type EnrollmentApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    studentName?: SortOrder
    email?: SortOrder
    course?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    _count?: EnrollmentApprovalCountOrderByAggregateInput
    _max?: EnrollmentApprovalMaxOrderByAggregateInput
    _min?: EnrollmentApprovalMinOrderByAggregateInput
  }

  export type EnrollmentApprovalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnrollmentApprovalScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnrollmentApprovalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnrollmentApprovalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    studentName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    course?: StringWithAggregatesFilter | string
    paymentMethod?: StringWithAggregatesFilter | string
    amount?: StringWithAggregatesFilter | string
    transactionId?: StringWithAggregatesFilter | string
    status?: EnumEnrollStatusWithAggregatesFilter | EnrollStatus
  }

  export type StudentsWhereInput = {
    AND?: Enumerable<StudentsWhereInput>
    OR?: Enumerable<StudentsWhereInput>
    NOT?: Enumerable<StudentsWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    status?: EnumStudentStatusFilter | StudentStatus
  }

  export type StudentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type StudentsWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type StudentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
    _count?: StudentsCountOrderByAggregateInput
    _max?: StudentsMaxOrderByAggregateInput
    _min?: StudentsMinOrderByAggregateInput
  }

  export type StudentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StudentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<StudentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StudentsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    status?: EnumStudentStatusWithAggregatesFilter | StudentStatus
  }

  export type StaffWhereInput = {
    AND?: Enumerable<StaffWhereInput>
    OR?: Enumerable<StaffWhereInput>
    NOT?: Enumerable<StaffWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    role?: EnumStaffRoleFilter | StaffRole
    phone?: StringFilter | string
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
  }

  export type StaffWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StaffScalarWhereWithAggregatesInput>
    OR?: Enumerable<StaffScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StaffScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    role?: EnumStaffRoleWithAggregatesFilter | StaffRole
    phone?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    emailApproval?: boolean
    successStoriesId?: string | null
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyCourseCreateInput = {
    id?: string
    courses: CoursesCreateNestedOneWithoutEnrollListInput
    student: UserCreateNestedOneWithoutMyCourseInput
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatches: CourseBatchesCreateNestedOneWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedCreateInput = {
    id?: string
    coursesId: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type MyCourseUpdateInput = {
    courses?: CoursesUpdateOneRequiredWithoutEnrollListInput
    student?: UserUpdateOneRequiredWithoutMyCourseInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatches?: CourseBatchesUpdateOneRequiredWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedUpdateInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCourseCreateManyInput = {
    id?: string
    coursesId: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type MyCourseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
  }

  export type MyCourseUncheckedUpdateManyInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCartCreateInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    courses: CoursesCreateNestedOneWithoutCartListInput
    user?: UserCreateNestedOneWithoutMyCartInput
  }

  export type MyCartUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    coursesId: string
    userId?: string | null
  }

  export type MyCartUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursesUpdateOneRequiredWithoutCartListInput
    user?: UserUpdateOneWithoutMyCartInput
  }

  export type MyCartUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MyCartCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    coursesId: string
    userId?: string | null
  }

  export type MyCartUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyCartUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    categoryName: string
    allCourses?: CoursesCreateNestedManyWithoutCourseCategoryInput
    imageUrl?: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    categoryName: string
    allCourses?: CoursesUncheckedCreateNestedManyWithoutCourseCategoryInput
    imageUrl?: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUpdateInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    allCourses?: CoursesUpdateManyWithoutCourseCategoryInput
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    allCourses?: CoursesUncheckedUpdateManyWithoutCourseCategoryInput
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: string
    categoryName: string
    imageUrl?: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursesCreateInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUpdateInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesCreateManyInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice: string
  }

  export type CoursesUpdateManyMutationInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateManyInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type LecturesCreateInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    courses: CoursesCreateNestedOneWithoutLecturesInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type LecturesUncheckedCreateInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type LecturesUpdateInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    courses?: CoursesUpdateOneRequiredWithoutLecturesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesUncheckedUpdateInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesCreateManyInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type LecturesUpdateManyMutationInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesUncheckedUpdateManyInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseBatchesCreateInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizCreateNestedManyWithoutCourseBatchesInput
    courses: CoursesCreateNestedOneWithoutTotalBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedCreateInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedCreateNestedManyWithoutCourseBatchesInput
    coursesId: string
    courseName: string
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseUncheckedCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUpdateManyWithoutCourseBatchesInput
    courses?: CoursesUpdateOneRequiredWithoutTotalBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedUpdateManyWithoutCourseBatchesInput
    coursesId?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUncheckedUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesCreateManyInput = {
    id?: string
    name: string
    coursesId: string
    courseName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseBatchesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseBatchesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentCreateInput = {
    id?: string
    name: string
    CourseBatches: CourseBatchesCreateNestedOneWithoutAssignmentInput
    courses: CoursesCreateNestedOneWithoutAssignmentInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentUncheckedCreateInput = {
    id?: string
    name: string
    courseBatchesId: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    CourseBatches?: CourseBatchesUpdateOneRequiredWithoutAssignmentInput
    courses?: CoursesUpdateOneRequiredWithoutAssignmentInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentCreateManyInput = {
    id?: string
    name: string
    courseBatchesId: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizCreateInput = {
    id?: string
    courseBatches: CourseBatchesCreateNestedOneWithoutQuizInput
    courses: CoursesCreateNestedOneWithoutCourseQuizInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizUncheckedCreateInput = {
    id?: string
    courseBatchesId: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizUpdateInput = {
    courseBatches?: CourseBatchesUpdateOneRequiredWithoutQuizInput
    courses?: CoursesUpdateOneRequiredWithoutCourseQuizInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateInput = {
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizCreateManyInput = {
    id?: string
    courseBatchesId: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateManyInput = {
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerCreateInput = {
    id?: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    events?: EventsCreateNestedManyWithoutSpeakerInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type SpeakerUncheckedCreateInput = {
    id?: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    events?: EventsUncheckedCreateNestedManyWithoutSpeakerInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type SpeakerUpdateInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    events?: EventsUpdateManyWithoutSpeakerInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerUncheckedUpdateInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    events?: EventsUncheckedUpdateManyWithoutSpeakerInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerCreateManyInput = {
    id?: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type SpeakerUpdateManyMutationInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerUncheckedUpdateManyInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsCreateInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
    Speaker: SpeakerCreateNestedOneWithoutEventsInput
  }

  export type EventsUncheckedCreateInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
    speakerId: string
  }

  export type EventsUpdateInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Speaker?: SpeakerUpdateOneRequiredWithoutEventsInput
  }

  export type EventsUncheckedUpdateInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type EventsCreateManyInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
    speakerId: string
  }

  export type EventsUpdateManyMutationInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateManyInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    speakerId?: StringFieldUpdateOperationsInput | string
  }

  export type FaqCreateInput = {
    id?: string
    faqQuestion: string
    faqAnswer: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FaqUncheckedCreateInput = {
    id?: string
    faqQuestion: string
    faqAnswer: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FaqUpdateInput = {
    faqQuestion?: StringFieldUpdateOperationsInput | string
    faqAnswer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqUncheckedUpdateInput = {
    faqQuestion?: StringFieldUpdateOperationsInput | string
    faqAnswer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqCreateManyInput = {
    id?: string
    faqQuestion: string
    faqAnswer: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FaqUpdateManyMutationInput = {
    faqQuestion?: StringFieldUpdateOperationsInput | string
    faqAnswer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqUncheckedUpdateManyInput = {
    faqQuestion?: StringFieldUpdateOperationsInput | string
    faqAnswer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuccessStoriesCreateInput = {
    id?: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status?: Status
    totalEarnedAmount: string
    city: string
    whyReject?: string
    user?: UserCreateNestedManyWithoutSuccessStoryInput
  }

  export type SuccessStoriesUncheckedCreateInput = {
    id?: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status?: Status
    totalEarnedAmount: string
    city: string
    whyReject?: string
    user?: UserUncheckedCreateNestedManyWithoutSuccessStoryInput
  }

  export type SuccessStoriesUpdateInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutSuccessStoryInput
  }

  export type SuccessStoriesUncheckedUpdateInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutSuccessStoryInput
  }

  export type SuccessStoriesCreateManyInput = {
    id?: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status?: Status
    totalEarnedAmount: string
    city: string
    whyReject?: string
  }

  export type SuccessStoriesUpdateManyMutationInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
  }

  export type SuccessStoriesUncheckedUpdateManyInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
  }

  export type blogsCreateInput = {
    id?: string
    blogTitle: string
    blogDescription: string
    createdAt?: Date | string
    updateAt?: Date | string
    featuredImage: string
    commentType: boolean
    comments?: CommentsCreateNestedManyWithoutBlogsInput
  }

  export type blogsUncheckedCreateInput = {
    id?: string
    blogTitle: string
    blogDescription: string
    createdAt?: Date | string
    updateAt?: Date | string
    featuredImage: string
    commentType: boolean
    comments?: CommentsUncheckedCreateNestedManyWithoutBlogsInput
  }

  export type blogsUpdateInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentsUpdateManyWithoutBlogsInput
  }

  export type blogsUncheckedUpdateInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentsUncheckedUpdateManyWithoutBlogsInput
  }

  export type blogsCreateManyInput = {
    id?: string
    blogTitle: string
    blogDescription: string
    createdAt?: Date | string
    updateAt?: Date | string
    featuredImage: string
    commentType: boolean
  }

  export type blogsUpdateManyMutationInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type blogsUncheckedUpdateManyInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentsCreateInput = {
    id?: string
    blogs: blogsCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    comment: string
    User?: UserCreateNestedOneWithoutMyCommentsInput
  }

  export type CommentsUncheckedCreateInput = {
    id?: string
    blogsId: string
    createdAt?: Date | string
    comment: string
    userId?: string | null
  }

  export type CommentsUpdateInput = {
    blogs?: blogsUpdateOneRequiredWithoutCommentsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutMyCommentsInput
  }

  export type CommentsUncheckedUpdateInput = {
    blogsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentsCreateManyInput = {
    id?: string
    blogsId: string
    createdAt?: Date | string
    comment: string
    userId?: string | null
  }

  export type CommentsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUncheckedUpdateManyInput = {
    blogsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsCreateInput = {
    id?: string
    name: string
    subject: string
    message: string
    status?: ContactUsStatus
    reply: string
  }

  export type ContactUsUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    message: string
    status?: ContactUsStatus
    reply: string
  }

  export type ContactUsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumContactUsStatusFieldUpdateOperationsInput | ContactUsStatus
    reply?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumContactUsStatusFieldUpdateOperationsInput | ContactUsStatus
    reply?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsCreateManyInput = {
    id?: string
    name: string
    subject: string
    message: string
    status?: ContactUsStatus
    reply: string
  }

  export type ContactUsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumContactUsStatusFieldUpdateOperationsInput | ContactUsStatus
    reply?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumContactUsStatusFieldUpdateOperationsInput | ContactUsStatus
    reply?: StringFieldUpdateOperationsInput | string
  }

  export type AttendenceCreateInput = {
    id?: string
    attendence: boolean
    date: Date | string
    user: UserCreateNestedOneWithoutAttendenceInput
  }

  export type AttendenceUncheckedCreateInput = {
    id?: string
    attendence: boolean
    date: Date | string
    userId: string
  }

  export type AttendenceUpdateInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendenceInput
  }

  export type AttendenceUncheckedUpdateInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendenceCreateManyInput = {
    id?: string
    attendence: boolean
    date: Date | string
    userId: string
  }

  export type AttendenceUpdateManyMutationInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendenceUncheckedUpdateManyInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FeesCreateInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    student: UserCreateNestedOneWithoutFeesInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FeesUncheckedCreateInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    studentId: string
    studentName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FeesUpdateInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    student?: UserUpdateOneRequiredWithoutFeesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUncheckedUpdateInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesCreateManyInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    studentId: string
    studentName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FeesUpdateManyMutationInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUncheckedUpdateManyInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentApprovalCreateInput = {
    id?: string
    studentName: string
    email: string
    course: string
    paymentMethod: string
    amount: string
    transactionId: string
    status?: EnrollStatus
  }

  export type EnrollmentApprovalUncheckedCreateInput = {
    id?: string
    studentName: string
    email: string
    course: string
    paymentMethod: string
    amount: string
    transactionId: string
    status?: EnrollStatus
  }

  export type EnrollmentApprovalUpdateInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    course?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollStatusFieldUpdateOperationsInput | EnrollStatus
  }

  export type EnrollmentApprovalUncheckedUpdateInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    course?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollStatusFieldUpdateOperationsInput | EnrollStatus
  }

  export type EnrollmentApprovalCreateManyInput = {
    id?: string
    studentName: string
    email: string
    course: string
    paymentMethod: string
    amount: string
    transactionId: string
    status?: EnrollStatus
  }

  export type EnrollmentApprovalUpdateManyMutationInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    course?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollStatusFieldUpdateOperationsInput | EnrollStatus
  }

  export type EnrollmentApprovalUncheckedUpdateManyInput = {
    studentName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    course?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    status?: EnumEnrollStatusFieldUpdateOperationsInput | EnrollStatus
  }

  export type StudentsCreateInput = {
    id?: string
    name: string
    email: string
    status?: StudentStatus
  }

  export type StudentsUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    status?: StudentStatus
  }

  export type StudentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | StudentStatus
  }

  export type StudentsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | StudentStatus
  }

  export type StudentsCreateManyInput = {
    id?: string
    name: string
    email: string
    status?: StudentStatus
  }

  export type StudentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | StudentStatus
  }

  export type StudentsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | StudentStatus
  }

  export type StaffCreateInput = {
    id?: string
    name: string
    email: string
    role?: StaffRole
    phone: string
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    role?: StaffRole
    phone: string
  }

  export type StaffUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | StaffRole
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type StaffUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | StaffRole
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type StaffCreateManyInput = {
    id?: string
    name: string
    email: string
    role?: StaffRole
    phone: string
  }

  export type StaffUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | StaffRole
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type StaffUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumStaffRoleFieldUpdateOperationsInput | StaffRole
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type EnumPermissionFilter = {
    equals?: Permission
    in?: Enumerable<Permission>
    notIn?: Enumerable<Permission>
    not?: NestedEnumPermissionFilter | Permission
  }

  export type CoursesListRelationFilter = {
    every?: CoursesWhereInput
    some?: CoursesWhereInput
    none?: CoursesWhereInput
  }

  export type MyCartListRelationFilter = {
    every?: MyCartWhereInput
    some?: MyCartWhereInput
    none?: MyCartWhereInput
  }

  export type SuccessStoriesRelationFilter = {
    is?: SuccessStoriesWhereInput | null
    isNot?: SuccessStoriesWhereInput | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type AttendenceListRelationFilter = {
    every?: AttendenceWhereInput
    some?: AttendenceWhereInput
    none?: AttendenceWhereInput
  }

  export type FeesListRelationFilter = {
    every?: FeesWhereInput
    some?: FeesWhereInput
    none?: FeesWhereInput
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type MyCourseListRelationFilter = {
    every?: MyCourseWhereInput
    some?: MyCourseWhereInput
    none?: MyCourseWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CoursesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MyCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MyCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cnic?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    emailApproval?: SortOrder
    successStoriesId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cnic?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    emailApproval?: SortOrder
    successStoriesId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cnic?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    emailApproval?: SortOrder
    successStoriesId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type EnumPermissionWithAggregatesFilter = {
    equals?: Permission
    in?: Enumerable<Permission>
    notIn?: Enumerable<Permission>
    not?: NestedEnumPermissionWithAggregatesFilter | Permission
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionFilter
    _max?: NestedEnumPermissionFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type CoursesRelationFilter = {
    is?: CoursesWhereInput
    isNot?: CoursesWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EnumFeeStatusFilter = {
    equals?: FeeStatus
    in?: Enumerable<FeeStatus>
    notIn?: Enumerable<FeeStatus>
    not?: NestedEnumFeeStatusFilter | FeeStatus
  }

  export type CourseBatchesRelationFilter = {
    is?: CourseBatchesWhereInput
    isNot?: CourseBatchesWhereInput
  }

  export type MyCourseCoursesIdStudentIdCompoundUniqueInput = {
    coursesId: string
    studentId: string
  }

  export type MyCourseCountOrderByAggregateInput = {
    id?: SortOrder
    coursesId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseApproval?: SortOrder
    whyReject?: SortOrder
    feeStatus?: SortOrder
    courseBatchesId?: SortOrder
  }

  export type MyCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    coursesId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseApproval?: SortOrder
    whyReject?: SortOrder
    feeStatus?: SortOrder
    courseBatchesId?: SortOrder
  }

  export type MyCourseMinOrderByAggregateInput = {
    id?: SortOrder
    coursesId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseApproval?: SortOrder
    whyReject?: SortOrder
    feeStatus?: SortOrder
    courseBatchesId?: SortOrder
  }

  export type EnumFeeStatusWithAggregatesFilter = {
    equals?: FeeStatus
    in?: Enumerable<FeeStatus>
    notIn?: Enumerable<FeeStatus>
    not?: NestedEnumFeeStatusWithAggregatesFilter | FeeStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFeeStatusFilter
    _max?: NestedEnumFeeStatusFilter
  }

  export type MyCartCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    coursesId?: SortOrder
    userId?: SortOrder
  }

  export type MyCartMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    coursesId?: SortOrder
    userId?: SortOrder
  }

  export type MyCartMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    coursesId?: SortOrder
    userId?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    categoryName?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type LecturesListRelationFilter = {
    every?: LecturesWhereInput
    some?: LecturesWhereInput
    none?: LecturesWhereInput
  }

  export type CourseBatchesListRelationFilter = {
    every?: CourseBatchesWhereInput
    some?: CourseBatchesWhereInput
    none?: CourseBatchesWhereInput
  }

  export type EnumStatusFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusFilter | Status
  }
  export type JsonNullableListFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase>, Exclude<keyof Required<JsonNullableListFilterBase>, 'path'>>,
        Required<JsonNullableListFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase>, 'path'>>

  export type JsonNullableListFilterBase = {
    equals?: Enumerable<InputJsonValue> | null
    has?: InputJsonValue | null
    hasEvery?: Enumerable<InputJsonValue>
    hasSome?: Enumerable<InputJsonValue>
    isEmpty?: boolean
  }

  export type CourseAssignmentListRelationFilter = {
    every?: CourseAssignmentWhereInput
    some?: CourseAssignmentWhereInput
    none?: CourseAssignmentWhereInput
  }

  export type CourseQuizListRelationFilter = {
    every?: CourseQuizWhereInput
    some?: CourseQuizWhereInput
    none?: CourseQuizWhereInput
  }

  export type LecturesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseBatchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseQuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursesCountOrderByAggregateInput = {
    id?: SortOrder
    courseName?: SortOrder
    courseDesc?: SortOrder
    courseIntro?: SortOrder
    instructorId?: SortOrder
    courseCategoryId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseStatus?: SortOrder
    whatYouLearn?: SortOrder
    coursePrice?: SortOrder
  }

  export type CoursesMaxOrderByAggregateInput = {
    id?: SortOrder
    courseName?: SortOrder
    courseDesc?: SortOrder
    courseIntro?: SortOrder
    instructorId?: SortOrder
    courseCategoryId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseStatus?: SortOrder
    coursePrice?: SortOrder
  }

  export type CoursesMinOrderByAggregateInput = {
    id?: SortOrder
    courseName?: SortOrder
    courseDesc?: SortOrder
    courseIntro?: SortOrder
    instructorId?: SortOrder
    courseCategoryId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    courseStatus?: SortOrder
    coursePrice?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusWithAggregatesFilter | Status
    _count?: NestedIntFilter
    _min?: NestedEnumStatusFilter
    _max?: NestedEnumStatusFilter
  }

  export type LecturesCountOrderByAggregateInput = {
    id?: SortOrder
    lectureTitle?: SortOrder
    lectureVideo?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type LecturesMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureTitle?: SortOrder
    lectureVideo?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type LecturesMinOrderByAggregateInput = {
    id?: SortOrder
    lectureTitle?: SortOrder
    lectureVideo?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseBatchesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    coursesId?: SortOrder
    courseName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseBatchesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    coursesId?: SortOrder
    courseName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseBatchesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    coursesId?: SortOrder
    courseName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseQuizCountOrderByAggregateInput = {
    id?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseQuizMaxOrderByAggregateInput = {
    id?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type CourseQuizMinOrderByAggregateInput = {
    id?: SortOrder
    courseBatchesId?: SortOrder
    coursesId?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type EventsListRelationFilter = {
    every?: EventsWhereInput
    some?: EventsWhereInput
    none?: EventsWhereInput
  }

  export type EventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    speakerName?: SortOrder
    spkearDesc?: SortOrder
    spekaerImage?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type SpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
    speakerName?: SortOrder
    spkearDesc?: SortOrder
    spekaerImage?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type SpeakerMinOrderByAggregateInput = {
    id?: SortOrder
    speakerName?: SortOrder
    spkearDesc?: SortOrder
    spekaerImage?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type SpeakerRelationFilter = {
    is?: SpeakerWhereInput
    isNot?: SpeakerWhereInput
  }

  export type EventsCountOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    eventDesc?: SortOrder
    eventImage?: SortOrder
    eventDate?: SortOrder
    speakerId?: SortOrder
  }

  export type EventsMaxOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    eventDesc?: SortOrder
    eventImage?: SortOrder
    eventDate?: SortOrder
    speakerId?: SortOrder
  }

  export type EventsMinOrderByAggregateInput = {
    id?: SortOrder
    eventName?: SortOrder
    eventDesc?: SortOrder
    eventImage?: SortOrder
    eventDate?: SortOrder
    speakerId?: SortOrder
  }

  export type FaqCountOrderByAggregateInput = {
    id?: SortOrder
    faqQuestion?: SortOrder
    faqAnswer?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FaqMaxOrderByAggregateInput = {
    id?: SortOrder
    faqQuestion?: SortOrder
    faqAnswer?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FaqMinOrderByAggregateInput = {
    id?: SortOrder
    faqQuestion?: SortOrder
    faqAnswer?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuccessStoriesCountOrderByAggregateInput = {
    id?: SortOrder
    freelancingProfileUrl?: SortOrder
    paymentProof?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalEarnedAmount?: SortOrder
    city?: SortOrder
    whyReject?: SortOrder
  }

  export type SuccessStoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    freelancingProfileUrl?: SortOrder
    paymentProof?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalEarnedAmount?: SortOrder
    city?: SortOrder
    whyReject?: SortOrder
  }

  export type SuccessStoriesMinOrderByAggregateInput = {
    id?: SortOrder
    freelancingProfileUrl?: SortOrder
    paymentProof?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalEarnedAmount?: SortOrder
    city?: SortOrder
    whyReject?: SortOrder
  }

  export type blogsCountOrderByAggregateInput = {
    id?: SortOrder
    blogTitle?: SortOrder
    blogDescription?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    featuredImage?: SortOrder
    commentType?: SortOrder
  }

  export type blogsMaxOrderByAggregateInput = {
    id?: SortOrder
    blogTitle?: SortOrder
    blogDescription?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    featuredImage?: SortOrder
    commentType?: SortOrder
  }

  export type blogsMinOrderByAggregateInput = {
    id?: SortOrder
    blogTitle?: SortOrder
    blogDescription?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    featuredImage?: SortOrder
    commentType?: SortOrder
  }

  export type BlogsRelationFilter = {
    is?: blogsWhereInput
    isNot?: blogsWhereInput
  }

  export type CommentsCountOrderByAggregateInput = {
    id?: SortOrder
    blogsId?: SortOrder
    createdAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
  }

  export type CommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    blogsId?: SortOrder
    createdAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
  }

  export type CommentsMinOrderByAggregateInput = {
    id?: SortOrder
    blogsId?: SortOrder
    createdAt?: SortOrder
    comment?: SortOrder
    userId?: SortOrder
  }

  export type EnumContactUsStatusFilter = {
    equals?: ContactUsStatus
    in?: Enumerable<ContactUsStatus>
    notIn?: Enumerable<ContactUsStatus>
    not?: NestedEnumContactUsStatusFilter | ContactUsStatus
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    reply?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    reply?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    reply?: SortOrder
  }

  export type EnumContactUsStatusWithAggregatesFilter = {
    equals?: ContactUsStatus
    in?: Enumerable<ContactUsStatus>
    notIn?: Enumerable<ContactUsStatus>
    not?: NestedEnumContactUsStatusWithAggregatesFilter | ContactUsStatus
    _count?: NestedIntFilter
    _min?: NestedEnumContactUsStatusFilter
    _max?: NestedEnumContactUsStatusFilter
  }

  export type AttendenceUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type AttendenceCountOrderByAggregateInput = {
    id?: SortOrder
    attendence?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type AttendenceMaxOrderByAggregateInput = {
    id?: SortOrder
    attendence?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type AttendenceMinOrderByAggregateInput = {
    id?: SortOrder
    attendence?: SortOrder
    date?: SortOrder
    userId?: SortOrder
  }

  export type FeesCountOrderByAggregateInput = {
    id?: SortOrder
    amountPaid?: SortOrder
    remainingAmount?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FeesMaxOrderByAggregateInput = {
    id?: SortOrder
    amountPaid?: SortOrder
    remainingAmount?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type FeesMinOrderByAggregateInput = {
    id?: SortOrder
    amountPaid?: SortOrder
    remainingAmount?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
  }

  export type EnumEnrollStatusFilter = {
    equals?: EnrollStatus
    in?: Enumerable<EnrollStatus>
    notIn?: Enumerable<EnrollStatus>
    not?: NestedEnumEnrollStatusFilter | EnrollStatus
  }

  export type EnrollmentApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    email?: SortOrder
    course?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    email?: SortOrder
    course?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
  }

  export type EnrollmentApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    studentName?: SortOrder
    email?: SortOrder
    course?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
  }

  export type EnumEnrollStatusWithAggregatesFilter = {
    equals?: EnrollStatus
    in?: Enumerable<EnrollStatus>
    notIn?: Enumerable<EnrollStatus>
    not?: NestedEnumEnrollStatusWithAggregatesFilter | EnrollStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnrollStatusFilter
    _max?: NestedEnumEnrollStatusFilter
  }

  export type EnumStudentStatusFilter = {
    equals?: StudentStatus
    in?: Enumerable<StudentStatus>
    notIn?: Enumerable<StudentStatus>
    not?: NestedEnumStudentStatusFilter | StudentStatus
  }

  export type StudentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type StudentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type StudentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type EnumStudentStatusWithAggregatesFilter = {
    equals?: StudentStatus
    in?: Enumerable<StudentStatus>
    notIn?: Enumerable<StudentStatus>
    not?: NestedEnumStudentStatusWithAggregatesFilter | StudentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumStudentStatusFilter
    _max?: NestedEnumStudentStatusFilter
  }

  export type EnumStaffRoleFilter = {
    equals?: StaffRole
    in?: Enumerable<StaffRole>
    notIn?: Enumerable<StaffRole>
    not?: NestedEnumStaffRoleFilter | StaffRole
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
  }

  export type EnumStaffRoleWithAggregatesFilter = {
    equals?: StaffRole
    in?: Enumerable<StaffRole>
    notIn?: Enumerable<StaffRole>
    not?: NestedEnumStaffRoleWithAggregatesFilter | StaffRole
    _count?: NestedIntFilter
    _min?: NestedEnumStaffRoleFilter
    _max?: NestedEnumStaffRoleFilter
  }

  export type CoursesCreateNestedManyWithoutInstructorInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutInstructorInput>, Enumerable<CoursesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutInstructorInput>
    createMany?: CoursesCreateManyInstructorInputEnvelope
    connect?: Enumerable<CoursesWhereUniqueInput>
  }

  export type MyCartCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutUserInput>, Enumerable<MyCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutUserInput>
    createMany?: MyCartCreateManyUserInputEnvelope
    connect?: Enumerable<MyCartWhereUniqueInput>
  }

  export type SuccessStoriesCreateNestedOneWithoutUserInput = {
    create?: XOR<SuccessStoriesCreateWithoutUserInput, SuccessStoriesUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuccessStoriesCreateOrConnectWithoutUserInput
    connect?: SuccessStoriesWhereUniqueInput
  }

  export type CommentsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutUserInput>, Enumerable<CommentsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutUserInput>
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type AttendenceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AttendenceCreateWithoutUserInput>, Enumerable<AttendenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttendenceCreateOrConnectWithoutUserInput>
    createMany?: AttendenceCreateManyUserInputEnvelope
    connect?: Enumerable<AttendenceWhereUniqueInput>
  }

  export type FeesCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<FeesCreateWithoutStudentInput>, Enumerable<FeesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<FeesCreateOrConnectWithoutStudentInput>
    createMany?: FeesCreateManyStudentInputEnvelope
    connect?: Enumerable<FeesWhereUniqueInput>
  }

  export type MyCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutStudentInput>, Enumerable<MyCourseUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutStudentInput>
    createMany?: MyCourseCreateManyStudentInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type CoursesUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutInstructorInput>, Enumerable<CoursesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutInstructorInput>
    createMany?: CoursesCreateManyInstructorInputEnvelope
    connect?: Enumerable<CoursesWhereUniqueInput>
  }

  export type MyCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutUserInput>, Enumerable<MyCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutUserInput>
    createMany?: MyCartCreateManyUserInputEnvelope
    connect?: Enumerable<MyCartWhereUniqueInput>
  }

  export type CommentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutUserInput>, Enumerable<CommentsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutUserInput>
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type AttendenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AttendenceCreateWithoutUserInput>, Enumerable<AttendenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttendenceCreateOrConnectWithoutUserInput>
    createMany?: AttendenceCreateManyUserInputEnvelope
    connect?: Enumerable<AttendenceWhereUniqueInput>
  }

  export type FeesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<FeesCreateWithoutStudentInput>, Enumerable<FeesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<FeesCreateOrConnectWithoutStudentInput>
    createMany?: FeesCreateManyStudentInputEnvelope
    connect?: Enumerable<FeesWhereUniqueInput>
  }

  export type MyCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutStudentInput>, Enumerable<MyCourseUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutStudentInput>
    createMany?: MyCourseCreateManyStudentInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type EnumPermissionFieldUpdateOperationsInput = {
    set?: Permission
  }

  export type CoursesUpdateManyWithoutInstructorInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutInstructorInput>, Enumerable<CoursesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutInstructorInput>
    upsert?: Enumerable<CoursesUpsertWithWhereUniqueWithoutInstructorInput>
    createMany?: CoursesCreateManyInstructorInputEnvelope
    set?: Enumerable<CoursesWhereUniqueInput>
    disconnect?: Enumerable<CoursesWhereUniqueInput>
    delete?: Enumerable<CoursesWhereUniqueInput>
    connect?: Enumerable<CoursesWhereUniqueInput>
    update?: Enumerable<CoursesUpdateWithWhereUniqueWithoutInstructorInput>
    updateMany?: Enumerable<CoursesUpdateManyWithWhereWithoutInstructorInput>
    deleteMany?: Enumerable<CoursesScalarWhereInput>
  }

  export type MyCartUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutUserInput>, Enumerable<MyCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MyCartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MyCartCreateManyUserInputEnvelope
    set?: Enumerable<MyCartWhereUniqueInput>
    disconnect?: Enumerable<MyCartWhereUniqueInput>
    delete?: Enumerable<MyCartWhereUniqueInput>
    connect?: Enumerable<MyCartWhereUniqueInput>
    update?: Enumerable<MyCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MyCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MyCartScalarWhereInput>
  }

  export type SuccessStoriesUpdateOneWithoutUserInput = {
    create?: XOR<SuccessStoriesCreateWithoutUserInput, SuccessStoriesUncheckedCreateWithoutUserInput>
    connectOrCreate?: SuccessStoriesCreateOrConnectWithoutUserInput
    upsert?: SuccessStoriesUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: SuccessStoriesWhereUniqueInput
    update?: XOR<SuccessStoriesUpdateWithoutUserInput, SuccessStoriesUncheckedUpdateWithoutUserInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CommentsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutUserInput>, Enumerable<CommentsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type AttendenceUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AttendenceCreateWithoutUserInput>, Enumerable<AttendenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttendenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AttendenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AttendenceCreateManyUserInputEnvelope
    set?: Enumerable<AttendenceWhereUniqueInput>
    disconnect?: Enumerable<AttendenceWhereUniqueInput>
    delete?: Enumerable<AttendenceWhereUniqueInput>
    connect?: Enumerable<AttendenceWhereUniqueInput>
    update?: Enumerable<AttendenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AttendenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AttendenceScalarWhereInput>
  }

  export type FeesUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<FeesCreateWithoutStudentInput>, Enumerable<FeesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<FeesCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<FeesUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: FeesCreateManyStudentInputEnvelope
    set?: Enumerable<FeesWhereUniqueInput>
    disconnect?: Enumerable<FeesWhereUniqueInput>
    delete?: Enumerable<FeesWhereUniqueInput>
    connect?: Enumerable<FeesWhereUniqueInput>
    update?: Enumerable<FeesUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<FeesUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<FeesScalarWhereInput>
  }

  export type MyCourseUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutStudentInput>, Enumerable<MyCourseUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: MyCourseCreateManyStudentInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CoursesUncheckedUpdateManyWithoutInstructorInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutInstructorInput>, Enumerable<CoursesUncheckedCreateWithoutInstructorInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutInstructorInput>
    upsert?: Enumerable<CoursesUpsertWithWhereUniqueWithoutInstructorInput>
    createMany?: CoursesCreateManyInstructorInputEnvelope
    set?: Enumerable<CoursesWhereUniqueInput>
    disconnect?: Enumerable<CoursesWhereUniqueInput>
    delete?: Enumerable<CoursesWhereUniqueInput>
    connect?: Enumerable<CoursesWhereUniqueInput>
    update?: Enumerable<CoursesUpdateWithWhereUniqueWithoutInstructorInput>
    updateMany?: Enumerable<CoursesUpdateManyWithWhereWithoutInstructorInput>
    deleteMany?: Enumerable<CoursesScalarWhereInput>
  }

  export type MyCartUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutUserInput>, Enumerable<MyCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MyCartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MyCartCreateManyUserInputEnvelope
    set?: Enumerable<MyCartWhereUniqueInput>
    disconnect?: Enumerable<MyCartWhereUniqueInput>
    delete?: Enumerable<MyCartWhereUniqueInput>
    connect?: Enumerable<MyCartWhereUniqueInput>
    update?: Enumerable<MyCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MyCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MyCartScalarWhereInput>
  }

  export type CommentsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutUserInput>, Enumerable<CommentsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type AttendenceUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<AttendenceCreateWithoutUserInput>, Enumerable<AttendenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttendenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AttendenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AttendenceCreateManyUserInputEnvelope
    set?: Enumerable<AttendenceWhereUniqueInput>
    disconnect?: Enumerable<AttendenceWhereUniqueInput>
    delete?: Enumerable<AttendenceWhereUniqueInput>
    connect?: Enumerable<AttendenceWhereUniqueInput>
    update?: Enumerable<AttendenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AttendenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AttendenceScalarWhereInput>
  }

  export type FeesUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<FeesCreateWithoutStudentInput>, Enumerable<FeesUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<FeesCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<FeesUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: FeesCreateManyStudentInputEnvelope
    set?: Enumerable<FeesWhereUniqueInput>
    disconnect?: Enumerable<FeesWhereUniqueInput>
    delete?: Enumerable<FeesWhereUniqueInput>
    connect?: Enumerable<FeesWhereUniqueInput>
    update?: Enumerable<FeesUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<FeesUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<FeesScalarWhereInput>
  }

  export type MyCourseUncheckedUpdateManyWithoutStudentInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutStudentInput>, Enumerable<MyCourseUncheckedCreateWithoutStudentInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutStudentInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutStudentInput>
    createMany?: MyCourseCreateManyStudentInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutStudentInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutStudentInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type CoursesCreateNestedOneWithoutEnrollListInput = {
    create?: XOR<CoursesCreateWithoutEnrollListInput, CoursesUncheckedCreateWithoutEnrollListInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrollListInput
    connect?: CoursesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMyCourseInput = {
    create?: XOR<UserCreateWithoutMyCourseInput, UserUncheckedCreateWithoutMyCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCourseInput
    connect?: UserWhereUniqueInput
  }

  export type CourseBatchesCreateNestedOneWithoutEnrolledStudentInput = {
    create?: XOR<CourseBatchesCreateWithoutEnrolledStudentInput, CourseBatchesUncheckedCreateWithoutEnrolledStudentInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutEnrolledStudentInput
    connect?: CourseBatchesWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutEnrollListInput = {
    create?: XOR<CoursesCreateWithoutEnrollListInput, CoursesUncheckedCreateWithoutEnrollListInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutEnrollListInput
    upsert?: CoursesUpsertWithoutEnrollListInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutEnrollListInput, CoursesUncheckedUpdateWithoutEnrollListInput>
  }

  export type UserUpdateOneRequiredWithoutMyCourseInput = {
    create?: XOR<UserCreateWithoutMyCourseInput, UserUncheckedCreateWithoutMyCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCourseInput
    upsert?: UserUpsertWithoutMyCourseInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMyCourseInput, UserUncheckedUpdateWithoutMyCourseInput>
  }

  export type EnumFeeStatusFieldUpdateOperationsInput = {
    set?: FeeStatus
  }

  export type CourseBatchesUpdateOneRequiredWithoutEnrolledStudentInput = {
    create?: XOR<CourseBatchesCreateWithoutEnrolledStudentInput, CourseBatchesUncheckedCreateWithoutEnrolledStudentInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutEnrolledStudentInput
    upsert?: CourseBatchesUpsertWithoutEnrolledStudentInput
    connect?: CourseBatchesWhereUniqueInput
    update?: XOR<CourseBatchesUpdateWithoutEnrolledStudentInput, CourseBatchesUncheckedUpdateWithoutEnrolledStudentInput>
  }

  export type CoursesCreateNestedOneWithoutCartListInput = {
    create?: XOR<CoursesCreateWithoutCartListInput, CoursesUncheckedCreateWithoutCartListInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCartListInput
    connect?: CoursesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMyCartInput = {
    create?: XOR<UserCreateWithoutMyCartInput, UserUncheckedCreateWithoutMyCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCartInput
    connect?: UserWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutCartListInput = {
    create?: XOR<CoursesCreateWithoutCartListInput, CoursesUncheckedCreateWithoutCartListInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCartListInput
    upsert?: CoursesUpsertWithoutCartListInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutCartListInput, CoursesUncheckedUpdateWithoutCartListInput>
  }

  export type UserUpdateOneWithoutMyCartInput = {
    create?: XOR<UserCreateWithoutMyCartInput, UserUncheckedCreateWithoutMyCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCartInput
    upsert?: UserUpsertWithoutMyCartInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMyCartInput, UserUncheckedUpdateWithoutMyCartInput>
  }

  export type CoursesCreateNestedManyWithoutCourseCategoryInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutCourseCategoryInput>, Enumerable<CoursesUncheckedCreateWithoutCourseCategoryInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutCourseCategoryInput>
    createMany?: CoursesCreateManyCourseCategoryInputEnvelope
    connect?: Enumerable<CoursesWhereUniqueInput>
  }

  export type CoursesUncheckedCreateNestedManyWithoutCourseCategoryInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutCourseCategoryInput>, Enumerable<CoursesUncheckedCreateWithoutCourseCategoryInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutCourseCategoryInput>
    createMany?: CoursesCreateManyCourseCategoryInputEnvelope
    connect?: Enumerable<CoursesWhereUniqueInput>
  }

  export type CoursesUpdateManyWithoutCourseCategoryInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutCourseCategoryInput>, Enumerable<CoursesUncheckedCreateWithoutCourseCategoryInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutCourseCategoryInput>
    upsert?: Enumerable<CoursesUpsertWithWhereUniqueWithoutCourseCategoryInput>
    createMany?: CoursesCreateManyCourseCategoryInputEnvelope
    set?: Enumerable<CoursesWhereUniqueInput>
    disconnect?: Enumerable<CoursesWhereUniqueInput>
    delete?: Enumerable<CoursesWhereUniqueInput>
    connect?: Enumerable<CoursesWhereUniqueInput>
    update?: Enumerable<CoursesUpdateWithWhereUniqueWithoutCourseCategoryInput>
    updateMany?: Enumerable<CoursesUpdateManyWithWhereWithoutCourseCategoryInput>
    deleteMany?: Enumerable<CoursesScalarWhereInput>
  }

  export type CoursesUncheckedUpdateManyWithoutCourseCategoryInput = {
    create?: XOR<Enumerable<CoursesCreateWithoutCourseCategoryInput>, Enumerable<CoursesUncheckedCreateWithoutCourseCategoryInput>>
    connectOrCreate?: Enumerable<CoursesCreateOrConnectWithoutCourseCategoryInput>
    upsert?: Enumerable<CoursesUpsertWithWhereUniqueWithoutCourseCategoryInput>
    createMany?: CoursesCreateManyCourseCategoryInputEnvelope
    set?: Enumerable<CoursesWhereUniqueInput>
    disconnect?: Enumerable<CoursesWhereUniqueInput>
    delete?: Enumerable<CoursesWhereUniqueInput>
    connect?: Enumerable<CoursesWhereUniqueInput>
    update?: Enumerable<CoursesUpdateWithWhereUniqueWithoutCourseCategoryInput>
    updateMany?: Enumerable<CoursesUpdateManyWithWhereWithoutCourseCategoryInput>
    deleteMany?: Enumerable<CoursesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutAllCoursesInput = {
    create?: XOR<CategoryCreateWithoutAllCoursesInput, CategoryUncheckedCreateWithoutAllCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAllCoursesInput
    connect?: CategoryWhereUniqueInput
  }

  export type LecturesCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<LecturesCreateWithoutCoursesInput>, Enumerable<LecturesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<LecturesCreateOrConnectWithoutCoursesInput>
    createMany?: LecturesCreateManyCoursesInputEnvelope
    connect?: Enumerable<LecturesWhereUniqueInput>
  }

  export type CourseBatchesCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseBatchesCreateWithoutCoursesInput>, Enumerable<CourseBatchesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseBatchesCreateOrConnectWithoutCoursesInput>
    createMany?: CourseBatchesCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseBatchesWhereUniqueInput>
  }

  export type CoursesCreatewhatYouLearnInput = {
    set: Enumerable<InputJsonValue>
  }

  export type CourseAssignmentCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCoursesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCoursesInput>
    createMany?: CourseAssignmentCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
  }

  export type CourseQuizCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCoursesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCoursesInput>
    createMany?: CourseQuizCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseQuizWhereUniqueInput>
  }

  export type MyCourseCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCoursesInput>, Enumerable<MyCourseUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCoursesInput>
    createMany?: MyCourseCreateManyCoursesInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type MyCartCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutCoursesInput>, Enumerable<MyCartUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutCoursesInput>
    createMany?: MyCartCreateManyCoursesInputEnvelope
    connect?: Enumerable<MyCartWhereUniqueInput>
  }

  export type LecturesUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<LecturesCreateWithoutCoursesInput>, Enumerable<LecturesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<LecturesCreateOrConnectWithoutCoursesInput>
    createMany?: LecturesCreateManyCoursesInputEnvelope
    connect?: Enumerable<LecturesWhereUniqueInput>
  }

  export type CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseBatchesCreateWithoutCoursesInput>, Enumerable<CourseBatchesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseBatchesCreateOrConnectWithoutCoursesInput>
    createMany?: CourseBatchesCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseBatchesWhereUniqueInput>
  }

  export type CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCoursesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCoursesInput>
    createMany?: CourseAssignmentCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
  }

  export type CourseQuizUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCoursesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCoursesInput>
    createMany?: CourseQuizCreateManyCoursesInputEnvelope
    connect?: Enumerable<CourseQuizWhereUniqueInput>
  }

  export type MyCourseUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCoursesInput>, Enumerable<MyCourseUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCoursesInput>
    createMany?: MyCourseCreateManyCoursesInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type MyCartUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutCoursesInput>, Enumerable<MyCartUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutCoursesInput>
    createMany?: MyCartCreateManyCoursesInputEnvelope
    connect?: Enumerable<MyCartWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type CategoryUpdateOneRequiredWithoutAllCoursesInput = {
    create?: XOR<CategoryCreateWithoutAllCoursesInput, CategoryUncheckedCreateWithoutAllCoursesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAllCoursesInput
    upsert?: CategoryUpsertWithoutAllCoursesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutAllCoursesInput, CategoryUncheckedUpdateWithoutAllCoursesInput>
  }

  export type LecturesUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<LecturesCreateWithoutCoursesInput>, Enumerable<LecturesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<LecturesCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<LecturesUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: LecturesCreateManyCoursesInputEnvelope
    set?: Enumerable<LecturesWhereUniqueInput>
    disconnect?: Enumerable<LecturesWhereUniqueInput>
    delete?: Enumerable<LecturesWhereUniqueInput>
    connect?: Enumerable<LecturesWhereUniqueInput>
    update?: Enumerable<LecturesUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<LecturesUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<LecturesScalarWhereInput>
  }

  export type CourseBatchesUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseBatchesCreateWithoutCoursesInput>, Enumerable<CourseBatchesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseBatchesCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseBatchesUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseBatchesCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseBatchesWhereUniqueInput>
    disconnect?: Enumerable<CourseBatchesWhereUniqueInput>
    delete?: Enumerable<CourseBatchesWhereUniqueInput>
    connect?: Enumerable<CourseBatchesWhereUniqueInput>
    update?: Enumerable<CourseBatchesUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseBatchesUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseBatchesScalarWhereInput>
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: Status
  }

  export type CoursesUpdatewhatYouLearnInput = {
    set?: Enumerable<InputJsonValue>
    push?: InputJsonValue | Enumerable<InputJsonValue>
  }

  export type CourseAssignmentUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCoursesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseAssignmentUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseAssignmentCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseAssignmentWhereUniqueInput>
    disconnect?: Enumerable<CourseAssignmentWhereUniqueInput>
    delete?: Enumerable<CourseAssignmentWhereUniqueInput>
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
    update?: Enumerable<CourseAssignmentUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseAssignmentUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseAssignmentScalarWhereInput>
  }

  export type CourseQuizUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCoursesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseQuizUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseQuizCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseQuizWhereUniqueInput>
    disconnect?: Enumerable<CourseQuizWhereUniqueInput>
    delete?: Enumerable<CourseQuizWhereUniqueInput>
    connect?: Enumerable<CourseQuizWhereUniqueInput>
    update?: Enumerable<CourseQuizUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseQuizUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseQuizScalarWhereInput>
  }

  export type MyCourseUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCoursesInput>, Enumerable<MyCourseUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: MyCourseCreateManyCoursesInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type MyCartUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutCoursesInput>, Enumerable<MyCartUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<MyCartUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: MyCartCreateManyCoursesInputEnvelope
    set?: Enumerable<MyCartWhereUniqueInput>
    disconnect?: Enumerable<MyCartWhereUniqueInput>
    delete?: Enumerable<MyCartWhereUniqueInput>
    connect?: Enumerable<MyCartWhereUniqueInput>
    update?: Enumerable<MyCartUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<MyCartUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<MyCartScalarWhereInput>
  }

  export type LecturesUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<LecturesCreateWithoutCoursesInput>, Enumerable<LecturesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<LecturesCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<LecturesUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: LecturesCreateManyCoursesInputEnvelope
    set?: Enumerable<LecturesWhereUniqueInput>
    disconnect?: Enumerable<LecturesWhereUniqueInput>
    delete?: Enumerable<LecturesWhereUniqueInput>
    connect?: Enumerable<LecturesWhereUniqueInput>
    update?: Enumerable<LecturesUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<LecturesUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<LecturesScalarWhereInput>
  }

  export type CourseBatchesUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseBatchesCreateWithoutCoursesInput>, Enumerable<CourseBatchesUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseBatchesCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseBatchesUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseBatchesCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseBatchesWhereUniqueInput>
    disconnect?: Enumerable<CourseBatchesWhereUniqueInput>
    delete?: Enumerable<CourseBatchesWhereUniqueInput>
    connect?: Enumerable<CourseBatchesWhereUniqueInput>
    update?: Enumerable<CourseBatchesUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseBatchesUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseBatchesScalarWhereInput>
  }

  export type CourseAssignmentUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCoursesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseAssignmentUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseAssignmentCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseAssignmentWhereUniqueInput>
    disconnect?: Enumerable<CourseAssignmentWhereUniqueInput>
    delete?: Enumerable<CourseAssignmentWhereUniqueInput>
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
    update?: Enumerable<CourseAssignmentUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseAssignmentUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseAssignmentScalarWhereInput>
  }

  export type CourseQuizUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCoursesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<CourseQuizUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: CourseQuizCreateManyCoursesInputEnvelope
    set?: Enumerable<CourseQuizWhereUniqueInput>
    disconnect?: Enumerable<CourseQuizWhereUniqueInput>
    delete?: Enumerable<CourseQuizWhereUniqueInput>
    connect?: Enumerable<CourseQuizWhereUniqueInput>
    update?: Enumerable<CourseQuizUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<CourseQuizUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<CourseQuizScalarWhereInput>
  }

  export type MyCourseUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCoursesInput>, Enumerable<MyCourseUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: MyCourseCreateManyCoursesInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type MyCartUncheckedUpdateManyWithoutCoursesInput = {
    create?: XOR<Enumerable<MyCartCreateWithoutCoursesInput>, Enumerable<MyCartUncheckedCreateWithoutCoursesInput>>
    connectOrCreate?: Enumerable<MyCartCreateOrConnectWithoutCoursesInput>
    upsert?: Enumerable<MyCartUpsertWithWhereUniqueWithoutCoursesInput>
    createMany?: MyCartCreateManyCoursesInputEnvelope
    set?: Enumerable<MyCartWhereUniqueInput>
    disconnect?: Enumerable<MyCartWhereUniqueInput>
    delete?: Enumerable<MyCartWhereUniqueInput>
    connect?: Enumerable<MyCartWhereUniqueInput>
    update?: Enumerable<MyCartUpdateWithWhereUniqueWithoutCoursesInput>
    updateMany?: Enumerable<MyCartUpdateManyWithWhereWithoutCoursesInput>
    deleteMany?: Enumerable<MyCartScalarWhereInput>
  }

  export type CoursesCreateNestedOneWithoutLecturesInput = {
    create?: XOR<CoursesCreateWithoutLecturesInput, CoursesUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutLecturesInput
    connect?: CoursesWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutLecturesInput = {
    create?: XOR<CoursesCreateWithoutLecturesInput, CoursesUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutLecturesInput
    upsert?: CoursesUpsertWithoutLecturesInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutLecturesInput, CoursesUncheckedUpdateWithoutLecturesInput>
  }

  export type CourseAssignmentCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCourseBatchesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCourseBatchesInput>
    createMany?: CourseAssignmentCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
  }

  export type CourseQuizCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCourseBatchesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCourseBatchesInput>
    createMany?: CourseQuizCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<CourseQuizWhereUniqueInput>
  }

  export type CoursesCreateNestedOneWithoutTotalBatchesInput = {
    create?: XOR<CoursesCreateWithoutTotalBatchesInput, CoursesUncheckedCreateWithoutTotalBatchesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTotalBatchesInput
    connect?: CoursesWhereUniqueInput
  }

  export type MyCourseCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCourseBatchesInput>, Enumerable<MyCourseUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCourseBatchesInput>
    createMany?: MyCourseCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type CourseAssignmentUncheckedCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCourseBatchesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCourseBatchesInput>
    createMany?: CourseAssignmentCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
  }

  export type CourseQuizUncheckedCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCourseBatchesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCourseBatchesInput>
    createMany?: CourseQuizCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<CourseQuizWhereUniqueInput>
  }

  export type MyCourseUncheckedCreateNestedManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCourseBatchesInput>, Enumerable<MyCourseUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCourseBatchesInput>
    createMany?: MyCourseCreateManyCourseBatchesInputEnvelope
    connect?: Enumerable<MyCourseWhereUniqueInput>
  }

  export type CourseAssignmentUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCourseBatchesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<CourseAssignmentUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: CourseAssignmentCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<CourseAssignmentWhereUniqueInput>
    disconnect?: Enumerable<CourseAssignmentWhereUniqueInput>
    delete?: Enumerable<CourseAssignmentWhereUniqueInput>
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
    update?: Enumerable<CourseAssignmentUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<CourseAssignmentUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<CourseAssignmentScalarWhereInput>
  }

  export type CourseQuizUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCourseBatchesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<CourseQuizUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: CourseQuizCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<CourseQuizWhereUniqueInput>
    disconnect?: Enumerable<CourseQuizWhereUniqueInput>
    delete?: Enumerable<CourseQuizWhereUniqueInput>
    connect?: Enumerable<CourseQuizWhereUniqueInput>
    update?: Enumerable<CourseQuizUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<CourseQuizUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<CourseQuizScalarWhereInput>
  }

  export type CoursesUpdateOneRequiredWithoutTotalBatchesInput = {
    create?: XOR<CoursesCreateWithoutTotalBatchesInput, CoursesUncheckedCreateWithoutTotalBatchesInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTotalBatchesInput
    upsert?: CoursesUpsertWithoutTotalBatchesInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutTotalBatchesInput, CoursesUncheckedUpdateWithoutTotalBatchesInput>
  }

  export type MyCourseUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCourseBatchesInput>, Enumerable<MyCourseUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: MyCourseCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type CourseAssignmentUncheckedUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseAssignmentCreateWithoutCourseBatchesInput>, Enumerable<CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseAssignmentCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<CourseAssignmentUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: CourseAssignmentCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<CourseAssignmentWhereUniqueInput>
    disconnect?: Enumerable<CourseAssignmentWhereUniqueInput>
    delete?: Enumerable<CourseAssignmentWhereUniqueInput>
    connect?: Enumerable<CourseAssignmentWhereUniqueInput>
    update?: Enumerable<CourseAssignmentUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<CourseAssignmentUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<CourseAssignmentScalarWhereInput>
  }

  export type CourseQuizUncheckedUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<CourseQuizCreateWithoutCourseBatchesInput>, Enumerable<CourseQuizUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<CourseQuizCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<CourseQuizUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: CourseQuizCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<CourseQuizWhereUniqueInput>
    disconnect?: Enumerable<CourseQuizWhereUniqueInput>
    delete?: Enumerable<CourseQuizWhereUniqueInput>
    connect?: Enumerable<CourseQuizWhereUniqueInput>
    update?: Enumerable<CourseQuizUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<CourseQuizUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<CourseQuizScalarWhereInput>
  }

  export type MyCourseUncheckedUpdateManyWithoutCourseBatchesInput = {
    create?: XOR<Enumerable<MyCourseCreateWithoutCourseBatchesInput>, Enumerable<MyCourseUncheckedCreateWithoutCourseBatchesInput>>
    connectOrCreate?: Enumerable<MyCourseCreateOrConnectWithoutCourseBatchesInput>
    upsert?: Enumerable<MyCourseUpsertWithWhereUniqueWithoutCourseBatchesInput>
    createMany?: MyCourseCreateManyCourseBatchesInputEnvelope
    set?: Enumerable<MyCourseWhereUniqueInput>
    disconnect?: Enumerable<MyCourseWhereUniqueInput>
    delete?: Enumerable<MyCourseWhereUniqueInput>
    connect?: Enumerable<MyCourseWhereUniqueInput>
    update?: Enumerable<MyCourseUpdateWithWhereUniqueWithoutCourseBatchesInput>
    updateMany?: Enumerable<MyCourseUpdateManyWithWhereWithoutCourseBatchesInput>
    deleteMany?: Enumerable<MyCourseScalarWhereInput>
  }

  export type CourseBatchesCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<CourseBatchesCreateWithoutAssignmentInput, CourseBatchesUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutAssignmentInput
    connect?: CourseBatchesWhereUniqueInput
  }

  export type CoursesCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<CoursesCreateWithoutAssignmentInput, CoursesUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutAssignmentInput
    connect?: CoursesWhereUniqueInput
  }

  export type CourseBatchesUpdateOneRequiredWithoutAssignmentInput = {
    create?: XOR<CourseBatchesCreateWithoutAssignmentInput, CourseBatchesUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutAssignmentInput
    upsert?: CourseBatchesUpsertWithoutAssignmentInput
    connect?: CourseBatchesWhereUniqueInput
    update?: XOR<CourseBatchesUpdateWithoutAssignmentInput, CourseBatchesUncheckedUpdateWithoutAssignmentInput>
  }

  export type CoursesUpdateOneRequiredWithoutAssignmentInput = {
    create?: XOR<CoursesCreateWithoutAssignmentInput, CoursesUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutAssignmentInput
    upsert?: CoursesUpsertWithoutAssignmentInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutAssignmentInput, CoursesUncheckedUpdateWithoutAssignmentInput>
  }

  export type CourseBatchesCreateNestedOneWithoutQuizInput = {
    create?: XOR<CourseBatchesCreateWithoutQuizInput, CourseBatchesUncheckedCreateWithoutQuizInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutQuizInput
    connect?: CourseBatchesWhereUniqueInput
  }

  export type CoursesCreateNestedOneWithoutCourseQuizInput = {
    create?: XOR<CoursesCreateWithoutCourseQuizInput, CoursesUncheckedCreateWithoutCourseQuizInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseQuizInput
    connect?: CoursesWhereUniqueInput
  }

  export type CourseBatchesUpdateOneRequiredWithoutQuizInput = {
    create?: XOR<CourseBatchesCreateWithoutQuizInput, CourseBatchesUncheckedCreateWithoutQuizInput>
    connectOrCreate?: CourseBatchesCreateOrConnectWithoutQuizInput
    upsert?: CourseBatchesUpsertWithoutQuizInput
    connect?: CourseBatchesWhereUniqueInput
    update?: XOR<CourseBatchesUpdateWithoutQuizInput, CourseBatchesUncheckedUpdateWithoutQuizInput>
  }

  export type CoursesUpdateOneRequiredWithoutCourseQuizInput = {
    create?: XOR<CoursesCreateWithoutCourseQuizInput, CoursesUncheckedCreateWithoutCourseQuizInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutCourseQuizInput
    upsert?: CoursesUpsertWithoutCourseQuizInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<CoursesUpdateWithoutCourseQuizInput, CoursesUncheckedUpdateWithoutCourseQuizInput>
  }

  export type EventsCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<EventsCreateWithoutSpeakerInput>, Enumerable<EventsUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<EventsCreateOrConnectWithoutSpeakerInput>
    createMany?: EventsCreateManySpeakerInputEnvelope
    connect?: Enumerable<EventsWhereUniqueInput>
  }

  export type EventsUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<EventsCreateWithoutSpeakerInput>, Enumerable<EventsUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<EventsCreateOrConnectWithoutSpeakerInput>
    createMany?: EventsCreateManySpeakerInputEnvelope
    connect?: Enumerable<EventsWhereUniqueInput>
  }

  export type EventsUpdateManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<EventsCreateWithoutSpeakerInput>, Enumerable<EventsUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<EventsCreateOrConnectWithoutSpeakerInput>
    upsert?: Enumerable<EventsUpsertWithWhereUniqueWithoutSpeakerInput>
    createMany?: EventsCreateManySpeakerInputEnvelope
    set?: Enumerable<EventsWhereUniqueInput>
    disconnect?: Enumerable<EventsWhereUniqueInput>
    delete?: Enumerable<EventsWhereUniqueInput>
    connect?: Enumerable<EventsWhereUniqueInput>
    update?: Enumerable<EventsUpdateWithWhereUniqueWithoutSpeakerInput>
    updateMany?: Enumerable<EventsUpdateManyWithWhereWithoutSpeakerInput>
    deleteMany?: Enumerable<EventsScalarWhereInput>
  }

  export type EventsUncheckedUpdateManyWithoutSpeakerInput = {
    create?: XOR<Enumerable<EventsCreateWithoutSpeakerInput>, Enumerable<EventsUncheckedCreateWithoutSpeakerInput>>
    connectOrCreate?: Enumerable<EventsCreateOrConnectWithoutSpeakerInput>
    upsert?: Enumerable<EventsUpsertWithWhereUniqueWithoutSpeakerInput>
    createMany?: EventsCreateManySpeakerInputEnvelope
    set?: Enumerable<EventsWhereUniqueInput>
    disconnect?: Enumerable<EventsWhereUniqueInput>
    delete?: Enumerable<EventsWhereUniqueInput>
    connect?: Enumerable<EventsWhereUniqueInput>
    update?: Enumerable<EventsUpdateWithWhereUniqueWithoutSpeakerInput>
    updateMany?: Enumerable<EventsUpdateManyWithWhereWithoutSpeakerInput>
    deleteMany?: Enumerable<EventsScalarWhereInput>
  }

  export type SpeakerCreateNestedOneWithoutEventsInput = {
    create?: XOR<SpeakerCreateWithoutEventsInput, SpeakerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutEventsInput
    connect?: SpeakerWhereUniqueInput
  }

  export type SpeakerUpdateOneRequiredWithoutEventsInput = {
    create?: XOR<SpeakerCreateWithoutEventsInput, SpeakerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutEventsInput
    upsert?: SpeakerUpsertWithoutEventsInput
    connect?: SpeakerWhereUniqueInput
    update?: XOR<SpeakerUpdateWithoutEventsInput, SpeakerUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedManyWithoutSuccessStoryInput = {
    create?: XOR<Enumerable<UserCreateWithoutSuccessStoryInput>, Enumerable<UserUncheckedCreateWithoutSuccessStoryInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSuccessStoryInput>
    createMany?: UserCreateManySuccessStoryInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutSuccessStoryInput = {
    create?: XOR<Enumerable<UserCreateWithoutSuccessStoryInput>, Enumerable<UserUncheckedCreateWithoutSuccessStoryInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSuccessStoryInput>
    createMany?: UserCreateManySuccessStoryInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutSuccessStoryInput = {
    create?: XOR<Enumerable<UserCreateWithoutSuccessStoryInput>, Enumerable<UserUncheckedCreateWithoutSuccessStoryInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSuccessStoryInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSuccessStoryInput>
    createMany?: UserCreateManySuccessStoryInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSuccessStoryInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSuccessStoryInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutSuccessStoryInput = {
    create?: XOR<Enumerable<UserCreateWithoutSuccessStoryInput>, Enumerable<UserUncheckedCreateWithoutSuccessStoryInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutSuccessStoryInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutSuccessStoryInput>
    createMany?: UserCreateManySuccessStoryInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutSuccessStoryInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutSuccessStoryInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type CommentsCreateNestedManyWithoutBlogsInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutBlogsInput>, Enumerable<CommentsUncheckedCreateWithoutBlogsInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutBlogsInput>
    createMany?: CommentsCreateManyBlogsInputEnvelope
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type CommentsUncheckedCreateNestedManyWithoutBlogsInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutBlogsInput>, Enumerable<CommentsUncheckedCreateWithoutBlogsInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutBlogsInput>
    createMany?: CommentsCreateManyBlogsInputEnvelope
    connect?: Enumerable<CommentsWhereUniqueInput>
  }

  export type CommentsUpdateManyWithoutBlogsInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutBlogsInput>, Enumerable<CommentsUncheckedCreateWithoutBlogsInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutBlogsInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutBlogsInput>
    createMany?: CommentsCreateManyBlogsInputEnvelope
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutBlogsInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutBlogsInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type CommentsUncheckedUpdateManyWithoutBlogsInput = {
    create?: XOR<Enumerable<CommentsCreateWithoutBlogsInput>, Enumerable<CommentsUncheckedCreateWithoutBlogsInput>>
    connectOrCreate?: Enumerable<CommentsCreateOrConnectWithoutBlogsInput>
    upsert?: Enumerable<CommentsUpsertWithWhereUniqueWithoutBlogsInput>
    createMany?: CommentsCreateManyBlogsInputEnvelope
    set?: Enumerable<CommentsWhereUniqueInput>
    disconnect?: Enumerable<CommentsWhereUniqueInput>
    delete?: Enumerable<CommentsWhereUniqueInput>
    connect?: Enumerable<CommentsWhereUniqueInput>
    update?: Enumerable<CommentsUpdateWithWhereUniqueWithoutBlogsInput>
    updateMany?: Enumerable<CommentsUpdateManyWithWhereWithoutBlogsInput>
    deleteMany?: Enumerable<CommentsScalarWhereInput>
  }

  export type blogsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<blogsCreateWithoutCommentsInput, blogsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: blogsCreateOrConnectWithoutCommentsInput
    connect?: blogsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMyCommentsInput = {
    create?: XOR<UserCreateWithoutMyCommentsInput, UserUncheckedCreateWithoutMyCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type blogsUpdateOneRequiredWithoutCommentsInput = {
    create?: XOR<blogsCreateWithoutCommentsInput, blogsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: blogsCreateOrConnectWithoutCommentsInput
    upsert?: blogsUpsertWithoutCommentsInput
    connect?: blogsWhereUniqueInput
    update?: XOR<blogsUpdateWithoutCommentsInput, blogsUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutMyCommentsInput = {
    create?: XOR<UserCreateWithoutMyCommentsInput, UserUncheckedCreateWithoutMyCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMyCommentsInput
    upsert?: UserUpsertWithoutMyCommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMyCommentsInput, UserUncheckedUpdateWithoutMyCommentsInput>
  }

  export type EnumContactUsStatusFieldUpdateOperationsInput = {
    set?: ContactUsStatus
  }

  export type UserCreateNestedOneWithoutAttendenceInput = {
    create?: XOR<UserCreateWithoutAttendenceInput, UserUncheckedCreateWithoutAttendenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendenceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendenceInput = {
    create?: XOR<UserCreateWithoutAttendenceInput, UserUncheckedCreateWithoutAttendenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendenceInput
    upsert?: UserUpsertWithoutAttendenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAttendenceInput, UserUncheckedUpdateWithoutAttendenceInput>
  }

  export type UserCreateNestedOneWithoutFeesInput = {
    create?: XOR<UserCreateWithoutFeesInput, UserUncheckedCreateWithoutFeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeesInput = {
    create?: XOR<UserCreateWithoutFeesInput, UserUncheckedCreateWithoutFeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeesInput
    upsert?: UserUpsertWithoutFeesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeesInput, UserUncheckedUpdateWithoutFeesInput>
  }

  export type EnumEnrollStatusFieldUpdateOperationsInput = {
    set?: EnrollStatus
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: StudentStatus
  }

  export type EnumStaffRoleFieldUpdateOperationsInput = {
    set?: StaffRole
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumPermissionFilter = {
    equals?: Permission
    in?: Enumerable<Permission>
    notIn?: Enumerable<Permission>
    not?: NestedEnumPermissionFilter | Permission
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedEnumPermissionWithAggregatesFilter = {
    equals?: Permission
    in?: Enumerable<Permission>
    notIn?: Enumerable<Permission>
    not?: NestedEnumPermissionWithAggregatesFilter | Permission
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionFilter
    _max?: NestedEnumPermissionFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumFeeStatusFilter = {
    equals?: FeeStatus
    in?: Enumerable<FeeStatus>
    notIn?: Enumerable<FeeStatus>
    not?: NestedEnumFeeStatusFilter | FeeStatus
  }

  export type NestedEnumFeeStatusWithAggregatesFilter = {
    equals?: FeeStatus
    in?: Enumerable<FeeStatus>
    notIn?: Enumerable<FeeStatus>
    not?: NestedEnumFeeStatusWithAggregatesFilter | FeeStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFeeStatusFilter
    _max?: NestedEnumFeeStatusFilter
  }

  export type NestedEnumStatusFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusFilter | Status
  }

  export type NestedEnumStatusWithAggregatesFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusWithAggregatesFilter | Status
    _count?: NestedIntFilter
    _min?: NestedEnumStatusFilter
    _max?: NestedEnumStatusFilter
  }

  export type NestedEnumContactUsStatusFilter = {
    equals?: ContactUsStatus
    in?: Enumerable<ContactUsStatus>
    notIn?: Enumerable<ContactUsStatus>
    not?: NestedEnumContactUsStatusFilter | ContactUsStatus
  }

  export type NestedEnumContactUsStatusWithAggregatesFilter = {
    equals?: ContactUsStatus
    in?: Enumerable<ContactUsStatus>
    notIn?: Enumerable<ContactUsStatus>
    not?: NestedEnumContactUsStatusWithAggregatesFilter | ContactUsStatus
    _count?: NestedIntFilter
    _min?: NestedEnumContactUsStatusFilter
    _max?: NestedEnumContactUsStatusFilter
  }

  export type NestedEnumEnrollStatusFilter = {
    equals?: EnrollStatus
    in?: Enumerable<EnrollStatus>
    notIn?: Enumerable<EnrollStatus>
    not?: NestedEnumEnrollStatusFilter | EnrollStatus
  }

  export type NestedEnumEnrollStatusWithAggregatesFilter = {
    equals?: EnrollStatus
    in?: Enumerable<EnrollStatus>
    notIn?: Enumerable<EnrollStatus>
    not?: NestedEnumEnrollStatusWithAggregatesFilter | EnrollStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnrollStatusFilter
    _max?: NestedEnumEnrollStatusFilter
  }

  export type NestedEnumStudentStatusFilter = {
    equals?: StudentStatus
    in?: Enumerable<StudentStatus>
    notIn?: Enumerable<StudentStatus>
    not?: NestedEnumStudentStatusFilter | StudentStatus
  }

  export type NestedEnumStudentStatusWithAggregatesFilter = {
    equals?: StudentStatus
    in?: Enumerable<StudentStatus>
    notIn?: Enumerable<StudentStatus>
    not?: NestedEnumStudentStatusWithAggregatesFilter | StudentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumStudentStatusFilter
    _max?: NestedEnumStudentStatusFilter
  }

  export type NestedEnumStaffRoleFilter = {
    equals?: StaffRole
    in?: Enumerable<StaffRole>
    notIn?: Enumerable<StaffRole>
    not?: NestedEnumStaffRoleFilter | StaffRole
  }

  export type NestedEnumStaffRoleWithAggregatesFilter = {
    equals?: StaffRole
    in?: Enumerable<StaffRole>
    notIn?: Enumerable<StaffRole>
    not?: NestedEnumStaffRoleWithAggregatesFilter | StaffRole
    _count?: NestedIntFilter
    _min?: NestedEnumStaffRoleFilter
    _max?: NestedEnumStaffRoleFilter
  }

  export type CoursesCreateWithoutInstructorInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutInstructorInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutInstructorInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutInstructorInput, CoursesUncheckedCreateWithoutInstructorInput>
  }

  export type CoursesCreateManyInstructorInputEnvelope = {
    data: Enumerable<CoursesCreateManyInstructorInput>
  }

  export type MyCartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    courses: CoursesCreateNestedOneWithoutCartListInput
  }

  export type MyCartUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    coursesId: string
  }

  export type MyCartCreateOrConnectWithoutUserInput = {
    where: MyCartWhereUniqueInput
    create: XOR<MyCartCreateWithoutUserInput, MyCartUncheckedCreateWithoutUserInput>
  }

  export type MyCartCreateManyUserInputEnvelope = {
    data: Enumerable<MyCartCreateManyUserInput>
  }

  export type SuccessStoriesCreateWithoutUserInput = {
    id?: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status?: Status
    totalEarnedAmount: string
    city: string
    whyReject?: string
  }

  export type SuccessStoriesUncheckedCreateWithoutUserInput = {
    id?: string
    freelancingProfileUrl: string
    paymentProof: string
    description: string
    status?: Status
    totalEarnedAmount: string
    city: string
    whyReject?: string
  }

  export type SuccessStoriesCreateOrConnectWithoutUserInput = {
    where: SuccessStoriesWhereUniqueInput
    create: XOR<SuccessStoriesCreateWithoutUserInput, SuccessStoriesUncheckedCreateWithoutUserInput>
  }

  export type CommentsCreateWithoutUserInput = {
    id?: string
    blogs: blogsCreateNestedOneWithoutCommentsInput
    createdAt?: Date | string
    comment: string
  }

  export type CommentsUncheckedCreateWithoutUserInput = {
    id?: string
    blogsId: string
    createdAt?: Date | string
    comment: string
  }

  export type CommentsCreateOrConnectWithoutUserInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsCreateManyUserInputEnvelope = {
    data: Enumerable<CommentsCreateManyUserInput>
  }

  export type AttendenceCreateWithoutUserInput = {
    id?: string
    attendence: boolean
    date: Date | string
  }

  export type AttendenceUncheckedCreateWithoutUserInput = {
    id?: string
    attendence: boolean
    date: Date | string
  }

  export type AttendenceCreateOrConnectWithoutUserInput = {
    where: AttendenceWhereUniqueInput
    create: XOR<AttendenceCreateWithoutUserInput, AttendenceUncheckedCreateWithoutUserInput>
  }

  export type AttendenceCreateManyUserInputEnvelope = {
    data: Enumerable<AttendenceCreateManyUserInput>
  }

  export type FeesCreateWithoutStudentInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FeesUncheckedCreateWithoutStudentInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type FeesCreateOrConnectWithoutStudentInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutStudentInput, FeesUncheckedCreateWithoutStudentInput>
  }

  export type FeesCreateManyStudentInputEnvelope = {
    data: Enumerable<FeesCreateManyStudentInput>
  }

  export type MyCourseCreateWithoutStudentInput = {
    id?: string
    courses: CoursesCreateNestedOneWithoutEnrollListInput
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatches: CourseBatchesCreateNestedOneWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedCreateWithoutStudentInput = {
    id?: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type MyCourseCreateOrConnectWithoutStudentInput = {
    where: MyCourseWhereUniqueInput
    create: XOR<MyCourseCreateWithoutStudentInput, MyCourseUncheckedCreateWithoutStudentInput>
  }

  export type MyCourseCreateManyStudentInputEnvelope = {
    data: Enumerable<MyCourseCreateManyStudentInput>
  }

  export type CoursesUpsertWithWhereUniqueWithoutInstructorInput = {
    where: CoursesWhereUniqueInput
    update: XOR<CoursesUpdateWithoutInstructorInput, CoursesUncheckedUpdateWithoutInstructorInput>
    create: XOR<CoursesCreateWithoutInstructorInput, CoursesUncheckedCreateWithoutInstructorInput>
  }

  export type CoursesUpdateWithWhereUniqueWithoutInstructorInput = {
    where: CoursesWhereUniqueInput
    data: XOR<CoursesUpdateWithoutInstructorInput, CoursesUncheckedUpdateWithoutInstructorInput>
  }

  export type CoursesUpdateManyWithWhereWithoutInstructorInput = {
    where: CoursesScalarWhereInput
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyWithoutCoursesInput>
  }

  export type CoursesScalarWhereInput = {
    AND?: Enumerable<CoursesScalarWhereInput>
    OR?: Enumerable<CoursesScalarWhereInput>
    NOT?: Enumerable<CoursesScalarWhereInput>
    id?: StringFilter | string
    courseName?: StringFilter | string
    courseDesc?: StringFilter | string
    courseIntro?: StringFilter | string
    instructorId?: StringFilter | string
    courseCategoryId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    courseStatus?: EnumStatusFilter | Status
    whatYouLearn?: JsonNullableListFilter
    coursePrice?: StringFilter | string
  }

  export type MyCartUpsertWithWhereUniqueWithoutUserInput = {
    where: MyCartWhereUniqueInput
    update: XOR<MyCartUpdateWithoutUserInput, MyCartUncheckedUpdateWithoutUserInput>
    create: XOR<MyCartCreateWithoutUserInput, MyCartUncheckedCreateWithoutUserInput>
  }

  export type MyCartUpdateWithWhereUniqueWithoutUserInput = {
    where: MyCartWhereUniqueInput
    data: XOR<MyCartUpdateWithoutUserInput, MyCartUncheckedUpdateWithoutUserInput>
  }

  export type MyCartUpdateManyWithWhereWithoutUserInput = {
    where: MyCartScalarWhereInput
    data: XOR<MyCartUpdateManyMutationInput, MyCartUncheckedUpdateManyWithoutMyCartInput>
  }

  export type MyCartScalarWhereInput = {
    AND?: Enumerable<MyCartScalarWhereInput>
    OR?: Enumerable<MyCartScalarWhereInput>
    NOT?: Enumerable<MyCartScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    coursesId?: StringFilter | string
    userId?: StringNullableFilter | string | null
  }

  export type SuccessStoriesUpsertWithoutUserInput = {
    update: XOR<SuccessStoriesUpdateWithoutUserInput, SuccessStoriesUncheckedUpdateWithoutUserInput>
    create: XOR<SuccessStoriesCreateWithoutUserInput, SuccessStoriesUncheckedCreateWithoutUserInput>
  }

  export type SuccessStoriesUpdateWithoutUserInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
  }

  export type SuccessStoriesUncheckedUpdateWithoutUserInput = {
    freelancingProfileUrl?: StringFieldUpdateOperationsInput | string
    paymentProof?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    totalEarnedAmount?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    whyReject?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
  }

  export type CommentsUpdateManyWithWhereWithoutUserInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutMyCommentsInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: Enumerable<CommentsScalarWhereInput>
    OR?: Enumerable<CommentsScalarWhereInput>
    NOT?: Enumerable<CommentsScalarWhereInput>
    id?: StringFilter | string
    blogsId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    comment?: StringFilter | string
    userId?: StringNullableFilter | string | null
  }

  export type AttendenceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendenceWhereUniqueInput
    update: XOR<AttendenceUpdateWithoutUserInput, AttendenceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendenceCreateWithoutUserInput, AttendenceUncheckedCreateWithoutUserInput>
  }

  export type AttendenceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendenceWhereUniqueInput
    data: XOR<AttendenceUpdateWithoutUserInput, AttendenceUncheckedUpdateWithoutUserInput>
  }

  export type AttendenceUpdateManyWithWhereWithoutUserInput = {
    where: AttendenceScalarWhereInput
    data: XOR<AttendenceUpdateManyMutationInput, AttendenceUncheckedUpdateManyWithoutAttendenceInput>
  }

  export type AttendenceScalarWhereInput = {
    AND?: Enumerable<AttendenceScalarWhereInput>
    OR?: Enumerable<AttendenceScalarWhereInput>
    NOT?: Enumerable<AttendenceScalarWhereInput>
    id?: StringFilter | string
    attendence?: BoolFilter | boolean
    date?: DateTimeFilter | Date | string
    userId?: StringFilter | string
  }

  export type FeesUpsertWithWhereUniqueWithoutStudentInput = {
    where: FeesWhereUniqueInput
    update: XOR<FeesUpdateWithoutStudentInput, FeesUncheckedUpdateWithoutStudentInput>
    create: XOR<FeesCreateWithoutStudentInput, FeesUncheckedCreateWithoutStudentInput>
  }

  export type FeesUpdateWithWhereUniqueWithoutStudentInput = {
    where: FeesWhereUniqueInput
    data: XOR<FeesUpdateWithoutStudentInput, FeesUncheckedUpdateWithoutStudentInput>
  }

  export type FeesUpdateManyWithWhereWithoutStudentInput = {
    where: FeesScalarWhereInput
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyWithoutFeesInput>
  }

  export type FeesScalarWhereInput = {
    AND?: Enumerable<FeesScalarWhereInput>
    OR?: Enumerable<FeesScalarWhereInput>
    NOT?: Enumerable<FeesScalarWhereInput>
    id?: StringFilter | string
    amountPaid?: StringFilter | string
    remainingAmount?: StringFilter | string
    studentId?: StringFilter | string
    studentName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MyCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: MyCourseWhereUniqueInput
    update: XOR<MyCourseUpdateWithoutStudentInput, MyCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<MyCourseCreateWithoutStudentInput, MyCourseUncheckedCreateWithoutStudentInput>
  }

  export type MyCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: MyCourseWhereUniqueInput
    data: XOR<MyCourseUpdateWithoutStudentInput, MyCourseUncheckedUpdateWithoutStudentInput>
  }

  export type MyCourseUpdateManyWithWhereWithoutStudentInput = {
    where: MyCourseScalarWhereInput
    data: XOR<MyCourseUpdateManyMutationInput, MyCourseUncheckedUpdateManyWithoutMyCourseInput>
  }

  export type MyCourseScalarWhereInput = {
    AND?: Enumerable<MyCourseScalarWhereInput>
    OR?: Enumerable<MyCourseScalarWhereInput>
    NOT?: Enumerable<MyCourseScalarWhereInput>
    id?: StringFilter | string
    coursesId?: StringFilter | string
    studentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
    courseApproval?: BoolFilter | boolean
    whyReject?: StringFilter | string
    feeStatus?: EnumFeeStatusFilter | FeeStatus
    courseBatchesId?: StringFilter | string
  }

  export type CoursesCreateWithoutEnrollListInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutEnrollListInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutEnrollListInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutEnrollListInput, CoursesUncheckedCreateWithoutEnrollListInput>
  }

  export type UserCreateWithoutMyCourseInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutMyCourseInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutMyCourseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMyCourseInput, UserUncheckedCreateWithoutMyCourseInput>
  }

  export type CourseBatchesCreateWithoutEnrolledStudentInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizCreateNestedManyWithoutCourseBatchesInput
    courses: CoursesCreateNestedOneWithoutTotalBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseBatchesUncheckedCreateWithoutEnrolledStudentInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedCreateNestedManyWithoutCourseBatchesInput
    coursesId: string
    courseName: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseBatchesCreateOrConnectWithoutEnrolledStudentInput = {
    where: CourseBatchesWhereUniqueInput
    create: XOR<CourseBatchesCreateWithoutEnrolledStudentInput, CourseBatchesUncheckedCreateWithoutEnrolledStudentInput>
  }

  export type CoursesUpsertWithoutEnrollListInput = {
    update: XOR<CoursesUpdateWithoutEnrollListInput, CoursesUncheckedUpdateWithoutEnrollListInput>
    create: XOR<CoursesCreateWithoutEnrollListInput, CoursesUncheckedCreateWithoutEnrollListInput>
  }

  export type CoursesUpdateWithoutEnrollListInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutEnrollListInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutMyCourseInput = {
    update: XOR<UserUpdateWithoutMyCourseInput, UserUncheckedUpdateWithoutMyCourseInput>
    create: XOR<UserCreateWithoutMyCourseInput, UserUncheckedCreateWithoutMyCourseInput>
  }

  export type UserUpdateWithoutMyCourseInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutMyCourseInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseBatchesUpsertWithoutEnrolledStudentInput = {
    update: XOR<CourseBatchesUpdateWithoutEnrolledStudentInput, CourseBatchesUncheckedUpdateWithoutEnrolledStudentInput>
    create: XOR<CourseBatchesCreateWithoutEnrolledStudentInput, CourseBatchesUncheckedCreateWithoutEnrolledStudentInput>
  }

  export type CourseBatchesUpdateWithoutEnrolledStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUpdateManyWithoutCourseBatchesInput
    courses?: CoursesUpdateOneRequiredWithoutTotalBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseBatchesUncheckedUpdateWithoutEnrolledStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedUpdateManyWithoutCourseBatchesInput
    coursesId?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursesCreateWithoutCartListInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutCartListInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutCartListInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCartListInput, CoursesUncheckedCreateWithoutCartListInput>
  }

  export type UserCreateWithoutMyCartInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutMyCartInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutMyCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMyCartInput, UserUncheckedCreateWithoutMyCartInput>
  }

  export type CoursesUpsertWithoutCartListInput = {
    update: XOR<CoursesUpdateWithoutCartListInput, CoursesUncheckedUpdateWithoutCartListInput>
    create: XOR<CoursesCreateWithoutCartListInput, CoursesUncheckedCreateWithoutCartListInput>
  }

  export type CoursesUpdateWithoutCartListInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutCartListInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutMyCartInput = {
    update: XOR<UserUpdateWithoutMyCartInput, UserUncheckedUpdateWithoutMyCartInput>
    create: XOR<UserCreateWithoutMyCartInput, UserUncheckedCreateWithoutMyCartInput>
  }

  export type UserUpdateWithoutMyCartInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutMyCartInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursesCreateWithoutCourseCategoryInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutCourseCategoryInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutCourseCategoryInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCourseCategoryInput, CoursesUncheckedCreateWithoutCourseCategoryInput>
  }

  export type CoursesCreateManyCourseCategoryInputEnvelope = {
    data: Enumerable<CoursesCreateManyCourseCategoryInput>
  }

  export type CoursesUpsertWithWhereUniqueWithoutCourseCategoryInput = {
    where: CoursesWhereUniqueInput
    update: XOR<CoursesUpdateWithoutCourseCategoryInput, CoursesUncheckedUpdateWithoutCourseCategoryInput>
    create: XOR<CoursesCreateWithoutCourseCategoryInput, CoursesUncheckedCreateWithoutCourseCategoryInput>
  }

  export type CoursesUpdateWithWhereUniqueWithoutCourseCategoryInput = {
    where: CoursesWhereUniqueInput
    data: XOR<CoursesUpdateWithoutCourseCategoryInput, CoursesUncheckedUpdateWithoutCourseCategoryInput>
  }

  export type CoursesUpdateManyWithWhereWithoutCourseCategoryInput = {
    where: CoursesScalarWhereInput
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyWithoutAllCoursesInput>
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type CategoryCreateWithoutAllCoursesInput = {
    id?: string
    categoryName: string
    imageUrl?: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutAllCoursesInput = {
    id?: string
    categoryName: string
    imageUrl?: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutAllCoursesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutAllCoursesInput, CategoryUncheckedCreateWithoutAllCoursesInput>
  }

  export type LecturesCreateWithoutCoursesInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type LecturesUncheckedCreateWithoutCoursesInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type LecturesCreateOrConnectWithoutCoursesInput = {
    where: LecturesWhereUniqueInput
    create: XOR<LecturesCreateWithoutCoursesInput, LecturesUncheckedCreateWithoutCoursesInput>
  }

  export type LecturesCreateManyCoursesInputEnvelope = {
    data: Enumerable<LecturesCreateManyCoursesInput>
  }

  export type CourseBatchesCreateWithoutCoursesInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizCreateNestedManyWithoutCourseBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedCreateNestedManyWithoutCourseBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseUncheckedCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesCreateOrConnectWithoutCoursesInput = {
    where: CourseBatchesWhereUniqueInput
    create: XOR<CourseBatchesCreateWithoutCoursesInput, CourseBatchesUncheckedCreateWithoutCoursesInput>
  }

  export type CourseBatchesCreateManyCoursesInputEnvelope = {
    data: Enumerable<CourseBatchesCreateManyCoursesInput>
  }

  export type CourseAssignmentCreateWithoutCoursesInput = {
    id?: string
    name: string
    CourseBatches: CourseBatchesCreateNestedOneWithoutAssignmentInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    courseBatchesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentCreateOrConnectWithoutCoursesInput = {
    where: CourseAssignmentWhereUniqueInput
    create: XOR<CourseAssignmentCreateWithoutCoursesInput, CourseAssignmentUncheckedCreateWithoutCoursesInput>
  }

  export type CourseAssignmentCreateManyCoursesInputEnvelope = {
    data: Enumerable<CourseAssignmentCreateManyCoursesInput>
  }

  export type CourseQuizCreateWithoutCoursesInput = {
    id?: string
    courseBatches: CourseBatchesCreateNestedOneWithoutQuizInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizUncheckedCreateWithoutCoursesInput = {
    id?: string
    courseBatchesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizCreateOrConnectWithoutCoursesInput = {
    where: CourseQuizWhereUniqueInput
    create: XOR<CourseQuizCreateWithoutCoursesInput, CourseQuizUncheckedCreateWithoutCoursesInput>
  }

  export type CourseQuizCreateManyCoursesInputEnvelope = {
    data: Enumerable<CourseQuizCreateManyCoursesInput>
  }

  export type MyCourseCreateWithoutCoursesInput = {
    id?: string
    student: UserCreateNestedOneWithoutMyCourseInput
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatches: CourseBatchesCreateNestedOneWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedCreateWithoutCoursesInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type MyCourseCreateOrConnectWithoutCoursesInput = {
    where: MyCourseWhereUniqueInput
    create: XOR<MyCourseCreateWithoutCoursesInput, MyCourseUncheckedCreateWithoutCoursesInput>
  }

  export type MyCourseCreateManyCoursesInputEnvelope = {
    data: Enumerable<MyCourseCreateManyCoursesInput>
  }

  export type MyCartCreateWithoutCoursesInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    user?: UserCreateNestedOneWithoutMyCartInput
  }

  export type MyCartUncheckedCreateWithoutCoursesInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    userId?: string | null
  }

  export type MyCartCreateOrConnectWithoutCoursesInput = {
    where: MyCartWhereUniqueInput
    create: XOR<MyCartCreateWithoutCoursesInput, MyCartUncheckedCreateWithoutCoursesInput>
  }

  export type MyCartCreateManyCoursesInputEnvelope = {
    data: Enumerable<MyCartCreateManyCoursesInput>
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutAllCoursesInput = {
    update: XOR<CategoryUpdateWithoutAllCoursesInput, CategoryUncheckedUpdateWithoutAllCoursesInput>
    create: XOR<CategoryCreateWithoutAllCoursesInput, CategoryUncheckedCreateWithoutAllCoursesInput>
  }

  export type CategoryUpdateWithoutAllCoursesInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutAllCoursesInput = {
    categoryName?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesUpsertWithWhereUniqueWithoutCoursesInput = {
    where: LecturesWhereUniqueInput
    update: XOR<LecturesUpdateWithoutCoursesInput, LecturesUncheckedUpdateWithoutCoursesInput>
    create: XOR<LecturesCreateWithoutCoursesInput, LecturesUncheckedCreateWithoutCoursesInput>
  }

  export type LecturesUpdateWithWhereUniqueWithoutCoursesInput = {
    where: LecturesWhereUniqueInput
    data: XOR<LecturesUpdateWithoutCoursesInput, LecturesUncheckedUpdateWithoutCoursesInput>
  }

  export type LecturesUpdateManyWithWhereWithoutCoursesInput = {
    where: LecturesScalarWhereInput
    data: XOR<LecturesUpdateManyMutationInput, LecturesUncheckedUpdateManyWithoutLecturesInput>
  }

  export type LecturesScalarWhereInput = {
    AND?: Enumerable<LecturesScalarWhereInput>
    OR?: Enumerable<LecturesScalarWhereInput>
    NOT?: Enumerable<LecturesScalarWhereInput>
    id?: StringFilter | string
    lectureTitle?: StringFilter | string
    lectureVideo?: StringFilter | string
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CourseBatchesUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CourseBatchesWhereUniqueInput
    update: XOR<CourseBatchesUpdateWithoutCoursesInput, CourseBatchesUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseBatchesCreateWithoutCoursesInput, CourseBatchesUncheckedCreateWithoutCoursesInput>
  }

  export type CourseBatchesUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CourseBatchesWhereUniqueInput
    data: XOR<CourseBatchesUpdateWithoutCoursesInput, CourseBatchesUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseBatchesUpdateManyWithWhereWithoutCoursesInput = {
    where: CourseBatchesScalarWhereInput
    data: XOR<CourseBatchesUpdateManyMutationInput, CourseBatchesUncheckedUpdateManyWithoutTotalBatchesInput>
  }

  export type CourseBatchesScalarWhereInput = {
    AND?: Enumerable<CourseBatchesScalarWhereInput>
    OR?: Enumerable<CourseBatchesScalarWhereInput>
    NOT?: Enumerable<CourseBatchesScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    coursesId?: StringFilter | string
    courseName?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CourseAssignmentUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CourseAssignmentWhereUniqueInput
    update: XOR<CourseAssignmentUpdateWithoutCoursesInput, CourseAssignmentUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseAssignmentCreateWithoutCoursesInput, CourseAssignmentUncheckedCreateWithoutCoursesInput>
  }

  export type CourseAssignmentUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CourseAssignmentWhereUniqueInput
    data: XOR<CourseAssignmentUpdateWithoutCoursesInput, CourseAssignmentUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseAssignmentUpdateManyWithWhereWithoutCoursesInput = {
    where: CourseAssignmentScalarWhereInput
    data: XOR<CourseAssignmentUpdateManyMutationInput, CourseAssignmentUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type CourseAssignmentScalarWhereInput = {
    AND?: Enumerable<CourseAssignmentScalarWhereInput>
    OR?: Enumerable<CourseAssignmentScalarWhereInput>
    NOT?: Enumerable<CourseAssignmentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    courseBatchesId?: StringFilter | string
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CourseQuizUpsertWithWhereUniqueWithoutCoursesInput = {
    where: CourseQuizWhereUniqueInput
    update: XOR<CourseQuizUpdateWithoutCoursesInput, CourseQuizUncheckedUpdateWithoutCoursesInput>
    create: XOR<CourseQuizCreateWithoutCoursesInput, CourseQuizUncheckedCreateWithoutCoursesInput>
  }

  export type CourseQuizUpdateWithWhereUniqueWithoutCoursesInput = {
    where: CourseQuizWhereUniqueInput
    data: XOR<CourseQuizUpdateWithoutCoursesInput, CourseQuizUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseQuizUpdateManyWithWhereWithoutCoursesInput = {
    where: CourseQuizScalarWhereInput
    data: XOR<CourseQuizUpdateManyMutationInput, CourseQuizUncheckedUpdateManyWithoutCourseQuizInput>
  }

  export type CourseQuizScalarWhereInput = {
    AND?: Enumerable<CourseQuizScalarWhereInput>
    OR?: Enumerable<CourseQuizScalarWhereInput>
    NOT?: Enumerable<CourseQuizScalarWhereInput>
    id?: StringFilter | string
    courseBatchesId?: StringFilter | string
    coursesId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type MyCourseUpsertWithWhereUniqueWithoutCoursesInput = {
    where: MyCourseWhereUniqueInput
    update: XOR<MyCourseUpdateWithoutCoursesInput, MyCourseUncheckedUpdateWithoutCoursesInput>
    create: XOR<MyCourseCreateWithoutCoursesInput, MyCourseUncheckedCreateWithoutCoursesInput>
  }

  export type MyCourseUpdateWithWhereUniqueWithoutCoursesInput = {
    where: MyCourseWhereUniqueInput
    data: XOR<MyCourseUpdateWithoutCoursesInput, MyCourseUncheckedUpdateWithoutCoursesInput>
  }

  export type MyCourseUpdateManyWithWhereWithoutCoursesInput = {
    where: MyCourseScalarWhereInput
    data: XOR<MyCourseUpdateManyMutationInput, MyCourseUncheckedUpdateManyWithoutEnrollListInput>
  }

  export type MyCartUpsertWithWhereUniqueWithoutCoursesInput = {
    where: MyCartWhereUniqueInput
    update: XOR<MyCartUpdateWithoutCoursesInput, MyCartUncheckedUpdateWithoutCoursesInput>
    create: XOR<MyCartCreateWithoutCoursesInput, MyCartUncheckedCreateWithoutCoursesInput>
  }

  export type MyCartUpdateWithWhereUniqueWithoutCoursesInput = {
    where: MyCartWhereUniqueInput
    data: XOR<MyCartUpdateWithoutCoursesInput, MyCartUncheckedUpdateWithoutCoursesInput>
  }

  export type MyCartUpdateManyWithWhereWithoutCoursesInput = {
    where: MyCartScalarWhereInput
    data: XOR<MyCartUpdateManyMutationInput, MyCartUncheckedUpdateManyWithoutCartListInput>
  }

  export type CoursesCreateWithoutLecturesInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutLecturesInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutLecturesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutLecturesInput, CoursesUncheckedCreateWithoutLecturesInput>
  }

  export type CoursesUpsertWithoutLecturesInput = {
    update: XOR<CoursesUpdateWithoutLecturesInput, CoursesUncheckedUpdateWithoutLecturesInput>
    create: XOR<CoursesCreateWithoutLecturesInput, CoursesUncheckedCreateWithoutLecturesInput>
  }

  export type CoursesUpdateWithoutLecturesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutLecturesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAssignmentCreateWithoutCourseBatchesInput = {
    id?: string
    name: string
    courses: CoursesCreateNestedOneWithoutAssignmentInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentUncheckedCreateWithoutCourseBatchesInput = {
    id?: string
    name: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentCreateOrConnectWithoutCourseBatchesInput = {
    where: CourseAssignmentWhereUniqueInput
    create: XOR<CourseAssignmentCreateWithoutCourseBatchesInput, CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>
  }

  export type CourseAssignmentCreateManyCourseBatchesInputEnvelope = {
    data: Enumerable<CourseAssignmentCreateManyCourseBatchesInput>
  }

  export type CourseQuizCreateWithoutCourseBatchesInput = {
    id?: string
    courses: CoursesCreateNestedOneWithoutCourseQuizInput
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizUncheckedCreateWithoutCourseBatchesInput = {
    id?: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizCreateOrConnectWithoutCourseBatchesInput = {
    where: CourseQuizWhereUniqueInput
    create: XOR<CourseQuizCreateWithoutCourseBatchesInput, CourseQuizUncheckedCreateWithoutCourseBatchesInput>
  }

  export type CourseQuizCreateManyCourseBatchesInputEnvelope = {
    data: Enumerable<CourseQuizCreateManyCourseBatchesInput>
  }

  export type CoursesCreateWithoutTotalBatchesInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutTotalBatchesInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutTotalBatchesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutTotalBatchesInput, CoursesUncheckedCreateWithoutTotalBatchesInput>
  }

  export type MyCourseCreateWithoutCourseBatchesInput = {
    id?: string
    courses: CoursesCreateNestedOneWithoutEnrollListInput
    student: UserCreateNestedOneWithoutMyCourseInput
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
  }

  export type MyCourseUncheckedCreateWithoutCourseBatchesInput = {
    id?: string
    coursesId: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
  }

  export type MyCourseCreateOrConnectWithoutCourseBatchesInput = {
    where: MyCourseWhereUniqueInput
    create: XOR<MyCourseCreateWithoutCourseBatchesInput, MyCourseUncheckedCreateWithoutCourseBatchesInput>
  }

  export type MyCourseCreateManyCourseBatchesInputEnvelope = {
    data: Enumerable<MyCourseCreateManyCourseBatchesInput>
  }

  export type CourseAssignmentUpsertWithWhereUniqueWithoutCourseBatchesInput = {
    where: CourseAssignmentWhereUniqueInput
    update: XOR<CourseAssignmentUpdateWithoutCourseBatchesInput, CourseAssignmentUncheckedUpdateWithoutCourseBatchesInput>
    create: XOR<CourseAssignmentCreateWithoutCourseBatchesInput, CourseAssignmentUncheckedCreateWithoutCourseBatchesInput>
  }

  export type CourseAssignmentUpdateWithWhereUniqueWithoutCourseBatchesInput = {
    where: CourseAssignmentWhereUniqueInput
    data: XOR<CourseAssignmentUpdateWithoutCourseBatchesInput, CourseAssignmentUncheckedUpdateWithoutCourseBatchesInput>
  }

  export type CourseAssignmentUpdateManyWithWhereWithoutCourseBatchesInput = {
    where: CourseAssignmentScalarWhereInput
    data: XOR<CourseAssignmentUpdateManyMutationInput, CourseAssignmentUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type CourseQuizUpsertWithWhereUniqueWithoutCourseBatchesInput = {
    where: CourseQuizWhereUniqueInput
    update: XOR<CourseQuizUpdateWithoutCourseBatchesInput, CourseQuizUncheckedUpdateWithoutCourseBatchesInput>
    create: XOR<CourseQuizCreateWithoutCourseBatchesInput, CourseQuizUncheckedCreateWithoutCourseBatchesInput>
  }

  export type CourseQuizUpdateWithWhereUniqueWithoutCourseBatchesInput = {
    where: CourseQuizWhereUniqueInput
    data: XOR<CourseQuizUpdateWithoutCourseBatchesInput, CourseQuizUncheckedUpdateWithoutCourseBatchesInput>
  }

  export type CourseQuizUpdateManyWithWhereWithoutCourseBatchesInput = {
    where: CourseQuizScalarWhereInput
    data: XOR<CourseQuizUpdateManyMutationInput, CourseQuizUncheckedUpdateManyWithoutQuizInput>
  }

  export type CoursesUpsertWithoutTotalBatchesInput = {
    update: XOR<CoursesUpdateWithoutTotalBatchesInput, CoursesUncheckedUpdateWithoutTotalBatchesInput>
    create: XOR<CoursesCreateWithoutTotalBatchesInput, CoursesUncheckedCreateWithoutTotalBatchesInput>
  }

  export type CoursesUpdateWithoutTotalBatchesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutTotalBatchesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type MyCourseUpsertWithWhereUniqueWithoutCourseBatchesInput = {
    where: MyCourseWhereUniqueInput
    update: XOR<MyCourseUpdateWithoutCourseBatchesInput, MyCourseUncheckedUpdateWithoutCourseBatchesInput>
    create: XOR<MyCourseCreateWithoutCourseBatchesInput, MyCourseUncheckedCreateWithoutCourseBatchesInput>
  }

  export type MyCourseUpdateWithWhereUniqueWithoutCourseBatchesInput = {
    where: MyCourseWhereUniqueInput
    data: XOR<MyCourseUpdateWithoutCourseBatchesInput, MyCourseUncheckedUpdateWithoutCourseBatchesInput>
  }

  export type MyCourseUpdateManyWithWhereWithoutCourseBatchesInput = {
    where: MyCourseScalarWhereInput
    data: XOR<MyCourseUpdateManyMutationInput, MyCourseUncheckedUpdateManyWithoutEnrolledStudentInput>
  }

  export type CourseBatchesCreateWithoutAssignmentInput = {
    id?: string
    name: string
    quiz?: CourseQuizCreateNestedManyWithoutCourseBatchesInput
    courses: CoursesCreateNestedOneWithoutTotalBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedCreateWithoutAssignmentInput = {
    id?: string
    name: string
    quiz?: CourseQuizUncheckedCreateNestedManyWithoutCourseBatchesInput
    coursesId: string
    courseName: string
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseUncheckedCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesCreateOrConnectWithoutAssignmentInput = {
    where: CourseBatchesWhereUniqueInput
    create: XOR<CourseBatchesCreateWithoutAssignmentInput, CourseBatchesUncheckedCreateWithoutAssignmentInput>
  }

  export type CoursesCreateWithoutAssignmentInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    courseQuiz?: CourseQuizCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutAssignmentInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    courseQuiz?: CourseQuizUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutAssignmentInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutAssignmentInput, CoursesUncheckedCreateWithoutAssignmentInput>
  }

  export type CourseBatchesUpsertWithoutAssignmentInput = {
    update: XOR<CourseBatchesUpdateWithoutAssignmentInput, CourseBatchesUncheckedUpdateWithoutAssignmentInput>
    create: XOR<CourseBatchesCreateWithoutAssignmentInput, CourseBatchesUncheckedCreateWithoutAssignmentInput>
  }

  export type CourseBatchesUpdateWithoutAssignmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    quiz?: CourseQuizUpdateManyWithoutCourseBatchesInput
    courses?: CoursesUpdateOneRequiredWithoutTotalBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedUpdateWithoutAssignmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    quiz?: CourseQuizUncheckedUpdateManyWithoutCourseBatchesInput
    coursesId?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUncheckedUpdateManyWithoutCourseBatchesInput
  }

  export type CoursesUpsertWithoutAssignmentInput = {
    update: XOR<CoursesUpdateWithoutAssignmentInput, CoursesUncheckedUpdateWithoutAssignmentInput>
    create: XOR<CoursesCreateWithoutAssignmentInput, CoursesUncheckedCreateWithoutAssignmentInput>
  }

  export type CoursesUpdateWithoutAssignmentInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutAssignmentInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CourseBatchesCreateWithoutQuizInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentCreateNestedManyWithoutCourseBatchesInput
    courses: CoursesCreateNestedOneWithoutTotalBatchesInput
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedCreateWithoutQuizInput = {
    id?: string
    name: string
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCourseBatchesInput
    coursesId: string
    courseName: string
    createdAt?: Date | string
    updateAt?: Date | string
    enrolledStudent?: MyCourseUncheckedCreateNestedManyWithoutCourseBatchesInput
  }

  export type CourseBatchesCreateOrConnectWithoutQuizInput = {
    where: CourseBatchesWhereUniqueInput
    create: XOR<CourseBatchesCreateWithoutQuizInput, CourseBatchesUncheckedCreateWithoutQuizInput>
  }

  export type CoursesCreateWithoutCourseQuizInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructor: UserCreateNestedOneWithoutCoursesInput
    courseCategory: CategoryCreateNestedOneWithoutAllCoursesInput
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseCreateNestedManyWithoutCoursesInput
    cartList?: MyCartCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesUncheckedCreateWithoutCourseQuizInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    lectures?: LecturesUncheckedCreateNestedManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedCreateNestedManyWithoutCoursesInput
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedCreateNestedManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedCreateNestedManyWithoutCoursesInput
    cartList?: MyCartUncheckedCreateNestedManyWithoutCoursesInput
    coursePrice: string
  }

  export type CoursesCreateOrConnectWithoutCourseQuizInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutCourseQuizInput, CoursesUncheckedCreateWithoutCourseQuizInput>
  }

  export type CourseBatchesUpsertWithoutQuizInput = {
    update: XOR<CourseBatchesUpdateWithoutQuizInput, CourseBatchesUncheckedUpdateWithoutQuizInput>
    create: XOR<CourseBatchesCreateWithoutQuizInput, CourseBatchesUncheckedCreateWithoutQuizInput>
  }

  export type CourseBatchesUpdateWithoutQuizInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUpdateManyWithoutCourseBatchesInput
    courses?: CoursesUpdateOneRequiredWithoutTotalBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedUpdateWithoutQuizInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCourseBatchesInput
    coursesId?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUncheckedUpdateManyWithoutCourseBatchesInput
  }

  export type CoursesUpsertWithoutCourseQuizInput = {
    update: XOR<CoursesUpdateWithoutCourseQuizInput, CoursesUncheckedUpdateWithoutCourseQuizInput>
    create: XOR<CoursesCreateWithoutCourseQuizInput, CoursesUncheckedCreateWithoutCourseQuizInput>
  }

  export type CoursesUpdateWithoutCourseQuizInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutCourseQuizInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type EventsCreateWithoutSpeakerInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
  }

  export type EventsUncheckedCreateWithoutSpeakerInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
  }

  export type EventsCreateOrConnectWithoutSpeakerInput = {
    where: EventsWhereUniqueInput
    create: XOR<EventsCreateWithoutSpeakerInput, EventsUncheckedCreateWithoutSpeakerInput>
  }

  export type EventsCreateManySpeakerInputEnvelope = {
    data: Enumerable<EventsCreateManySpeakerInput>
  }

  export type EventsUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: EventsWhereUniqueInput
    update: XOR<EventsUpdateWithoutSpeakerInput, EventsUncheckedUpdateWithoutSpeakerInput>
    create: XOR<EventsCreateWithoutSpeakerInput, EventsUncheckedCreateWithoutSpeakerInput>
  }

  export type EventsUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: EventsWhereUniqueInput
    data: XOR<EventsUpdateWithoutSpeakerInput, EventsUncheckedUpdateWithoutSpeakerInput>
  }

  export type EventsUpdateManyWithWhereWithoutSpeakerInput = {
    where: EventsScalarWhereInput
    data: XOR<EventsUpdateManyMutationInput, EventsUncheckedUpdateManyWithoutEventsInput>
  }

  export type EventsScalarWhereInput = {
    AND?: Enumerable<EventsScalarWhereInput>
    OR?: Enumerable<EventsScalarWhereInput>
    NOT?: Enumerable<EventsScalarWhereInput>
    id?: StringFilter | string
    eventName?: StringFilter | string
    eventDesc?: StringFilter | string
    eventImage?: StringNullableFilter | string | null
    eventDate?: DateTimeFilter | Date | string
    speakerId?: StringFilter | string
  }

  export type SpeakerCreateWithoutEventsInput = {
    id?: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type SpeakerUncheckedCreateWithoutEventsInput = {
    id?: string
    speakerName: string
    spkearDesc: string
    spekaerImage: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type SpeakerCreateOrConnectWithoutEventsInput = {
    where: SpeakerWhereUniqueInput
    create: XOR<SpeakerCreateWithoutEventsInput, SpeakerUncheckedCreateWithoutEventsInput>
  }

  export type SpeakerUpsertWithoutEventsInput = {
    update: XOR<SpeakerUpdateWithoutEventsInput, SpeakerUncheckedUpdateWithoutEventsInput>
    create: XOR<SpeakerCreateWithoutEventsInput, SpeakerUncheckedCreateWithoutEventsInput>
  }

  export type SpeakerUpdateWithoutEventsInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakerUncheckedUpdateWithoutEventsInput = {
    speakerName?: StringFieldUpdateOperationsInput | string
    spkearDesc?: StringFieldUpdateOperationsInput | string
    spekaerImage?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSuccessStoryInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSuccessStoryInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSuccessStoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSuccessStoryInput, UserUncheckedCreateWithoutSuccessStoryInput>
  }

  export type UserCreateManySuccessStoryInputEnvelope = {
    data: Enumerable<UserCreateManySuccessStoryInput>
  }

  export type UserUpsertWithWhereUniqueWithoutSuccessStoryInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSuccessStoryInput, UserUncheckedUpdateWithoutSuccessStoryInput>
    create: XOR<UserCreateWithoutSuccessStoryInput, UserUncheckedCreateWithoutSuccessStoryInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSuccessStoryInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSuccessStoryInput, UserUncheckedUpdateWithoutSuccessStoryInput>
  }

  export type UserUpdateManyWithWhereWithoutSuccessStoryInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    cnic?: StringFilter | string
    address?: StringFilter | string
    phone?: StringFilter | string
    role?: EnumRoleFilter | Role
    permission?: EnumPermissionFilter | Permission
    emailApproval?: BoolFilter | boolean
    successStoriesId?: StringNullableFilter | string | null
    token?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeFilter | Date | string
  }

  export type CommentsCreateWithoutBlogsInput = {
    id?: string
    createdAt?: Date | string
    comment: string
    User?: UserCreateNestedOneWithoutMyCommentsInput
  }

  export type CommentsUncheckedCreateWithoutBlogsInput = {
    id?: string
    createdAt?: Date | string
    comment: string
    userId?: string | null
  }

  export type CommentsCreateOrConnectWithoutBlogsInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutBlogsInput, CommentsUncheckedCreateWithoutBlogsInput>
  }

  export type CommentsCreateManyBlogsInputEnvelope = {
    data: Enumerable<CommentsCreateManyBlogsInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutBlogsInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutBlogsInput, CommentsUncheckedUpdateWithoutBlogsInput>
    create: XOR<CommentsCreateWithoutBlogsInput, CommentsUncheckedCreateWithoutBlogsInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutBlogsInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutBlogsInput, CommentsUncheckedUpdateWithoutBlogsInput>
  }

  export type CommentsUpdateManyWithWhereWithoutBlogsInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutCommentsInput>
  }

  export type blogsCreateWithoutCommentsInput = {
    id?: string
    blogTitle: string
    blogDescription: string
    createdAt?: Date | string
    updateAt?: Date | string
    featuredImage: string
    commentType: boolean
  }

  export type blogsUncheckedCreateWithoutCommentsInput = {
    id?: string
    blogTitle: string
    blogDescription: string
    createdAt?: Date | string
    updateAt?: Date | string
    featuredImage: string
    commentType: boolean
  }

  export type blogsCreateOrConnectWithoutCommentsInput = {
    where: blogsWhereUniqueInput
    create: XOR<blogsCreateWithoutCommentsInput, blogsUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutMyCommentsInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutMyCommentsInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutMyCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMyCommentsInput, UserUncheckedCreateWithoutMyCommentsInput>
  }

  export type blogsUpsertWithoutCommentsInput = {
    update: XOR<blogsUpdateWithoutCommentsInput, blogsUncheckedUpdateWithoutCommentsInput>
    create: XOR<blogsCreateWithoutCommentsInput, blogsUncheckedCreateWithoutCommentsInput>
  }

  export type blogsUpdateWithoutCommentsInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type blogsUncheckedUpdateWithoutCommentsInput = {
    blogTitle?: StringFieldUpdateOperationsInput | string
    blogDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featuredImage?: StringFieldUpdateOperationsInput | string
    commentType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutMyCommentsInput = {
    update: XOR<UserUpdateWithoutMyCommentsInput, UserUncheckedUpdateWithoutMyCommentsInput>
    create: XOR<UserCreateWithoutMyCommentsInput, UserUncheckedCreateWithoutMyCommentsInput>
  }

  export type UserUpdateWithoutMyCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutMyCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAttendenceInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    fees?: FeesCreateNestedManyWithoutStudentInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutAttendenceInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    fees?: FeesUncheckedCreateNestedManyWithoutStudentInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAttendenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendenceInput, UserUncheckedCreateWithoutAttendenceInput>
  }

  export type UserUpsertWithoutAttendenceInput = {
    update: XOR<UserUpdateWithoutAttendenceInput, UserUncheckedUpdateWithoutAttendenceInput>
    create: XOR<UserCreateWithoutAttendenceInput, UserUncheckedCreateWithoutAttendenceInput>
  }

  export type UserUpdateWithoutAttendenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAttendenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFeesInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesCreateNestedManyWithoutInstructorInput
    myCart?: MyCartCreateNestedManyWithoutUserInput
    successStory?: SuccessStoriesCreateNestedOneWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsCreateNestedManyWithoutUserInput
    attendence?: AttendenceCreateNestedManyWithoutUserInput
    myCourse?: MyCourseCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUncheckedCreateWithoutFeesInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    courses?: CoursesUncheckedCreateNestedManyWithoutInstructorInput
    myCart?: MyCartUncheckedCreateNestedManyWithoutUserInput
    emailApproval?: boolean
    myComments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    attendence?: AttendenceUncheckedCreateNestedManyWithoutUserInput
    successStoriesId?: string | null
    myCourse?: MyCourseUncheckedCreateNestedManyWithoutStudentInput
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserCreateOrConnectWithoutFeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeesInput, UserUncheckedCreateWithoutFeesInput>
  }

  export type UserUpsertWithoutFeesInput = {
    update: XOR<UserUpdateWithoutFeesInput, UserUncheckedUpdateWithoutFeesInput>
    create: XOR<UserCreateWithoutFeesInput, UserUncheckedCreateWithoutFeesInput>
  }

  export type UserUpdateWithoutFeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    successStory?: SuccessStoriesUpdateOneWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutFeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    successStoriesId?: NullableStringFieldUpdateOperationsInput | string | null
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursesCreateManyInstructorInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    courseCategoryId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice: string
  }

  export type MyCartCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    coursesId: string
  }

  export type CommentsCreateManyUserInput = {
    id?: string
    blogsId: string
    createdAt?: Date | string
    comment: string
  }

  export type AttendenceCreateManyUserInput = {
    id?: string
    attendence: boolean
    date: Date | string
  }

  export type FeesCreateManyStudentInput = {
    id?: string
    amountPaid: string
    remainingAmount: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MyCourseCreateManyStudentInput = {
    id?: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type CoursesUpdateWithoutInstructorInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    courseCategory?: CategoryUpdateOneRequiredWithoutAllCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutInstructorInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateManyWithoutCoursesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    courseCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type MyCartUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CoursesUpdateOneRequiredWithoutCartListInput
  }

  export type MyCartUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCartUncheckedUpdateManyWithoutMyCartInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coursesId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUpdateWithoutUserInput = {
    blogs?: blogsUpdateOneRequiredWithoutCommentsInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUncheckedUpdateWithoutUserInput = {
    blogsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type CommentsUncheckedUpdateManyWithoutMyCommentsInput = {
    blogsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type AttendenceUpdateWithoutUserInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendenceUncheckedUpdateWithoutUserInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendenceUncheckedUpdateManyWithoutAttendenceInput = {
    attendence?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUpdateWithoutStudentInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUncheckedUpdateWithoutStudentInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUncheckedUpdateManyWithoutFeesInput = {
    amountPaid?: StringFieldUpdateOperationsInput | string
    remainingAmount?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyCourseUpdateWithoutStudentInput = {
    courses?: CoursesUpdateOneRequiredWithoutEnrollListInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatches?: CourseBatchesUpdateOneRequiredWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedUpdateWithoutStudentInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCourseUncheckedUpdateManyWithoutMyCourseInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesCreateManyCourseCategoryInput = {
    id?: string
    courseName: string
    courseDesc: string
    courseIntro: string
    instructorId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseStatus?: Status
    whatYouLearn?: CoursesCreatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice: string
  }

  export type CoursesUpdateWithoutCourseCategoryInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructor?: UserUpdateOneRequiredWithoutCoursesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUpdateManyWithoutCoursesInput
    cartList?: MyCartUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateWithoutCourseCategoryInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LecturesUncheckedUpdateManyWithoutCoursesInput
    totalBatches?: CourseBatchesUncheckedUpdateManyWithoutCoursesInput
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCoursesInput
    courseQuiz?: CourseQuizUncheckedUpdateManyWithoutCoursesInput
    enrollList?: MyCourseUncheckedUpdateManyWithoutCoursesInput
    cartList?: MyCartUncheckedUpdateManyWithoutCoursesInput
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesUncheckedUpdateManyWithoutAllCoursesInput = {
    courseName?: StringFieldUpdateOperationsInput | string
    courseDesc?: StringFieldUpdateOperationsInput | string
    courseIntro?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseStatus?: EnumStatusFieldUpdateOperationsInput | Status
    whatYouLearn?: CoursesUpdatewhatYouLearnInput | Enumerable<InputJsonValue>
    coursePrice?: StringFieldUpdateOperationsInput | string
  }

  export type LecturesCreateManyCoursesInput = {
    id?: string
    lectureTitle: string
    lectureVideo: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseBatchesCreateManyCoursesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseAssignmentCreateManyCoursesInput = {
    id?: string
    name: string
    courseBatchesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizCreateManyCoursesInput = {
    id?: string
    courseBatchesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MyCourseCreateManyCoursesInput = {
    id?: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
    courseBatchesId: string
  }

  export type MyCartCreateManyCoursesInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    userId?: string | null
  }

  export type LecturesUpdateWithoutCoursesInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesUncheckedUpdateWithoutCoursesInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LecturesUncheckedUpdateManyWithoutLecturesInput = {
    lectureTitle?: StringFieldUpdateOperationsInput | string
    lectureVideo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseBatchesUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUpdateManyWithoutCourseBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignment?: CourseAssignmentUncheckedUpdateManyWithoutCourseBatchesInput
    quiz?: CourseQuizUncheckedUpdateManyWithoutCourseBatchesInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrolledStudent?: MyCourseUncheckedUpdateManyWithoutCourseBatchesInput
  }

  export type CourseBatchesUncheckedUpdateManyWithoutTotalBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    CourseBatches?: CourseBatchesUpdateOneRequiredWithoutAssignmentInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUncheckedUpdateWithoutCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUncheckedUpdateManyWithoutAssignmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUpdateWithoutCoursesInput = {
    courseBatches?: CourseBatchesUpdateOneRequiredWithoutQuizInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateWithoutCoursesInput = {
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateManyWithoutCourseQuizInput = {
    courseBatchesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyCourseUpdateWithoutCoursesInput = {
    student?: UserUpdateOneRequiredWithoutMyCourseInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatches?: CourseBatchesUpdateOneRequiredWithoutEnrolledStudentInput
  }

  export type MyCourseUncheckedUpdateWithoutCoursesInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCourseUncheckedUpdateManyWithoutEnrollListInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
    courseBatchesId?: StringFieldUpdateOperationsInput | string
  }

  export type MyCartUpdateWithoutCoursesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMyCartInput
  }

  export type MyCartUncheckedUpdateWithoutCoursesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MyCartUncheckedUpdateManyWithoutCartListInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseAssignmentCreateManyCourseBatchesInput = {
    id?: string
    name: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type CourseQuizCreateManyCourseBatchesInput = {
    id?: string
    coursesId: string
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type MyCourseCreateManyCourseBatchesInput = {
    id?: string
    coursesId: string
    studentId: string
    createdAt?: Date | string
    updateAt?: Date | string
    courseApproval?: boolean
    whyReject?: string
    feeStatus?: FeeStatus
  }

  export type CourseAssignmentUpdateWithoutCourseBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    courses?: CoursesUpdateOneRequiredWithoutAssignmentInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseAssignmentUncheckedUpdateWithoutCourseBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUpdateWithoutCourseBatchesInput = {
    courses?: CoursesUpdateOneRequiredWithoutCourseQuizInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateWithoutCourseBatchesInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseQuizUncheckedUpdateManyWithoutQuizInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyCourseUpdateWithoutCourseBatchesInput = {
    courses?: CoursesUpdateOneRequiredWithoutEnrollListInput
    student?: UserUpdateOneRequiredWithoutMyCourseInput
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
  }

  export type MyCourseUncheckedUpdateWithoutCourseBatchesInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
  }

  export type MyCourseUncheckedUpdateManyWithoutEnrolledStudentInput = {
    coursesId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseApproval?: BoolFieldUpdateOperationsInput | boolean
    whyReject?: StringFieldUpdateOperationsInput | string
    feeStatus?: EnumFeeStatusFieldUpdateOperationsInput | FeeStatus
  }

  export type EventsCreateManySpeakerInput = {
    id?: string
    eventName: string
    eventDesc: string
    eventImage?: string | null
    eventDate: Date | string
  }

  export type EventsUpdateWithoutSpeakerInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateWithoutSpeakerInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventsUncheckedUpdateManyWithoutEventsInput = {
    eventName?: StringFieldUpdateOperationsInput | string
    eventDesc?: StringFieldUpdateOperationsInput | string
    eventImage?: NullableStringFieldUpdateOperationsInput | string | null
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManySuccessStoryInput = {
    id?: string
    name: string
    email: string
    password: string
    cnic: string
    address?: string
    phone: string
    role?: Role
    permission?: Permission
    emailApproval?: boolean
    token?: string | null
    createdAt?: Date | string
    updateAt?: Date | string
  }

  export type UserUpdateWithoutSuccessStoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUpdateManyWithoutInstructorInput
    myCart?: MyCartUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUpdateManyWithoutUserInput
    attendence?: AttendenceUpdateManyWithoutUserInput
    fees?: FeesUpdateManyWithoutStudentInput
    myCourse?: MyCourseUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSuccessStoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    courses?: CoursesUncheckedUpdateManyWithoutInstructorInput
    myCart?: MyCartUncheckedUpdateManyWithoutUserInput
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    myComments?: CommentsUncheckedUpdateManyWithoutUserInput
    attendence?: AttendenceUncheckedUpdateManyWithoutUserInput
    fees?: FeesUncheckedUpdateManyWithoutStudentInput
    myCourse?: MyCourseUncheckedUpdateManyWithoutStudentInput
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cnic?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permission?: EnumPermissionFieldUpdateOperationsInput | Permission
    emailApproval?: BoolFieldUpdateOperationsInput | boolean
    token?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentsCreateManyBlogsInput = {
    id?: string
    createdAt?: Date | string
    comment: string
    userId?: string | null
  }

  export type CommentsUpdateWithoutBlogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneWithoutMyCommentsInput
  }

  export type CommentsUncheckedUpdateWithoutBlogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentsUncheckedUpdateManyWithoutCommentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}